<?xml version='1.0' encoding='utf-8'?>
<haxe><class path="funkin.backend.system.Main" params="" file="source/funkin/backend/system/Main.hx">
		<extends path="openfl.display.Sprite"/>
		<instance public="1" static="1">
			<c path="funkin.backend.system.Main"/>
			<meta><m n=":keep"/></meta>
		</instance>
		<modToLoad public="1" expr="null" line="36" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":keep"/>
			</meta>
		</modToLoad>
		<forceGPUOnlyBitmapsOff public="1" expr="false" line="37" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
			</meta>
		</forceGPUOnlyBitmapsOff>
		<noTerminalColor public="1" expr="false" line="38" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
			</meta>
		</noTerminalColor>
		<verbose public="1" expr="false" line="39" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
			</meta>
		</verbose>
		<scaleMode public="1" static="1">
			<c path="funkin.backend.system.FunkinRatioScaleMode"/>
			<meta><m n=":keep"/></meta>
		</scaleMode>
		<framerateSprite public="1" static="1">
			<c path="funkin.backend.system.framerate.Framerate"/>
			<meta><m n=":keep"/></meta>
		</framerateSprite>
		<game public="1" static="1">
			<c path="funkin.backend.system.FunkinGame"/>
			<meta><m n=":keep"/></meta>
		</game>
		<timeSinceFocus public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* The time since the game was focused last time in seconds.</haxe_doc>
		</timeSinceFocus>
		<time public="1" expr="0" line="57" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":keep"/>
			</meta>
		</time>
		<gameThreads public="1" expr="[]" line="62" static="1">
			<c path="Array"><x path="sys.thread.Thread"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":keep"/>
			</meta>
		</gameThreads>
		<preInit public="1" set="method" line="65" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</preInit>
		<audioDisconnected public="1" expr="false" line="88" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</audioDisconnected>
		<changeID public="1" expr="0" line="90" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":keep"/>
			</meta>
		</changeID>
		<pathBack public="1" expr="&quot;../../../../&quot;" line="92" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"../../../../"</e></m>
				<m n=":keep"/>
			</meta>
		</pathBack>
		<startedFromSource public="1" expr="false" line="98" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
			</meta>
		</startedFromSource>
		<__threadCycle expr="0" line="101" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":keep"/>
			</meta>
		</__threadCycle>
		<execAsync public="1" set="method" line="102" static="1">
			<f a="func">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</execAsync>
		<getTimer set="method" line="111" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":keep"/></meta>
		</getTimer>
		<loadGameSettings public="1" set="method" line="115" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</loadGameSettings>
		<refreshAssets public="1" set="method" line="176" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</refreshAssets>
		<initTransition public="1" set="method" line="194" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</initTransition>
		<onFocus public="1" set="method" line="205" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</onFocus>
		<onStateSwitch set="method" line="209" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</onStateSwitch>
		<onStateSwitchPost set="method" line="213" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</onStateSwitchPost>
		<noCwdFix public="1" expr="false" line="230" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
			</meta>
		</noCwdFix>
		<fixWorkingDirectory public="1" set="method" line="231" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</fixWorkingDirectory>
		<_tickFocused expr="0" line="243" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":keep"/>
			</meta>
		</_tickFocused>
		<get_timeSinceFocus public="1" set="method" line="244" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":keep"/></meta>
		</get_timeSinceFocus>
		<gameWidth expr="1280">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1280</e></m>
				<m n=":keep"/>
			</meta>
		</gameWidth>
		<gameHeight expr="720">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>720</e></m>
				<m n=":keep"/>
			</meta>
		</gameHeight>
		<skipSplash expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":keep"/>
			</meta>
		</skipSplash>
		<startFullscreen expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":keep"/>
			</meta>
		</startFullscreen>
		<new public="1" set="method" line="71">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<typedef path="funkin.SingleOrFloat" params="" file="source/funkin/Types.hx" module="funkin.Types">
		<x path="Single"/>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<class path="funkin.backend.FlxAnimate" params="" file="source/funkin/backend/FlxAnimate.hx">
		<extends path="flxanimate.FlxAnimate"/>
		<rMatrix expr="new FlxMatrix()" line="10" static="1">
			<c path="flixel.math.FlxMatrix"/>
			<meta><m n=":value"><e>new FlxMatrix()</e></m></meta>
		</rMatrix>
		<drawLimb set="method" line="13" override="1"><f a="limb:_rMatrix:?colorTransform:?blendMode">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.math.FlxMatrix"/>
	<c path="openfl.geom.ColorTransform"/>
	<x path="openfl.display.BlendMode"/>
	<x path="Void"/>
</f></drawLimb>
		<limbOnScreen set="method" line="88" override="1"><f a="limb:m:?Camera">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.math.FlxMatrix"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></limbOnScreen>
		<new public="1" set="method" line="9"><f a="?X:?Y:?Path:?Settings">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Null"><t path="flxanimate.Settings"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.XMLAnimType" params="" file="source/funkin/backend/FunkinSprite.hx" module="funkin.backend.FunkinSprite">
		<this><x path="Int"/></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend._FunkinSprite.XMLAnimType_Impl_" params="" file="source/funkin/backend/FunkinSprite.hx" private="1" module="funkin.backend.FunkinSprite" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="21" static="1">
		<x path="funkin.backend.XMLAnimType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<BEAT public="1" get="inline" set="null" expr="cast 1" line="22" static="1">
		<x path="funkin.backend.XMLAnimType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BEAT>
	<LOOP public="1" get="inline" set="null" expr="cast 2" line="23" static="1">
		<x path="funkin.backend.XMLAnimType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LOOP>
	<fromString public="1" set="method" line="26" static="1">
		<f a="str:?def" v=":XMLAnimType.NONE">
			<c path="String"/>
			<x path="funkin.backend.XMLAnimType"/>
			<x path="funkin.backend.XMLAnimType"/>
		</f>
		<meta><m n=":value"><e>{ def : XMLAnimType.NONE }</e></m></meta>
	</fromString>
	<toString public="1" set="method" line="36" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":to"/></meta>
	</toString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="funkin.backend._FunkinSprite.XMLAnimType_Impl_" params="" file="source/funkin/backend/FunkinSprite.hx" private="1" module="funkin.backend.FunkinSprite" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="21" static="1">
			<x path="funkin.backend.XMLAnimType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<BEAT public="1" get="inline" set="null" expr="cast 1" line="22" static="1">
			<x path="funkin.backend.XMLAnimType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BEAT>
		<LOOP public="1" get="inline" set="null" expr="cast 2" line="23" static="1">
			<x path="funkin.backend.XMLAnimType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LOOP>
		<fromString public="1" set="method" line="26" static="1">
			<f a="str:?def" v=":XMLAnimType.NONE">
				<c path="String"/>
				<x path="funkin.backend.XMLAnimType"/>
				<x path="funkin.backend.XMLAnimType"/>
			</f>
			<meta><m n=":value"><e>{ def : XMLAnimType.NONE }</e></m></meta>
		</fromString>
		<toString public="1" set="method" line="36" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":to"/></meta>
		</toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="funkin.backend.utils.IXMLEvents" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil" interface="1">
		<onPropertySet public="1" set="method"><f a="property:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></onPropertySet>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.interfaces.IOffsetCompatible" params="" file="source/funkin/backend/system/interfaces/IOffsetCompatible.hx" interface="1">
		<addOffset public="1" set="method">
			<f a="anim:?x:?y" v=":0:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</addOffset>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.interfaces.IBeatReceiver" params="" file="source/funkin/backend/system/interfaces/IBeatReceiver.hx" interface="1">
		<measureHit public="1" set="method"><f a="curMeasure">
	<x path="Int"/>
	<x path="Void"/>
</f></measureHit>
		<beatHit public="1" set="method"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.FunkinSprite" params="" file="source/funkin/backend/FunkinSprite.hx">
		<extends path="flixel.addons.effects.FlxSkewedSprite"/>
		<implements path="funkin.backend.utils.IXMLEvents"/>
		<implements path="funkin.backend.system.interfaces.IOffsetCompatible"/>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<copyFrom public="1" set="method" line="92" static="1">
			<f a="source">
				<c path="flixel.FlxSprite"/>
				<c path="funkin.backend.FunkinSprite"/>
			</f>
			<haxe_doc>* Gets the graphics and copies other properties from another sprite (Works both for `FlxSprite` and `FunkinSprite`!).</haxe_doc>
		</copyFrom>
		<extra public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extra>
		<spriteAnimType public="1" expr="NONE">
			<x path="funkin.backend.XMLAnimType"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</spriteAnimType>
		<beatAnims public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.utils.BeatAnim"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</beatAnims>
		<name public="1"><c path="String"/></name>
		<zoomFactor public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</zoomFactor>
		<debugMode public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</debugMode>
		<animDatas public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<t path="funkin.backend.utils.AnimData"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</animDatas>
		<animEnabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</animEnabled>
		<zoomFactorEnabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</zoomFactorEnabled>
		<globalCurFrame public="1" get="accessor" set="accessor"><x path="Int"/></globalCurFrame>
		<beatInterval public="1" set="accessor" expr="2">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
			<haxe_doc>* ODD interval -&gt; not aligned to beats
	 * EVEN interval -&gt; aligned to beats</haxe_doc>
		</beatInterval>
		<beatOffset public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</beatOffset>
		<skipNegativeBeats public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skipNegativeBeats>
		<animateAtlas public="1"><c path="funkin.backend.FlxAnimate"/></animateAtlas>
		<atlasPlayingAnim public="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</atlasPlayingAnim>
		<atlasPath public="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</atlasPath>
		<update public="1" set="method" line="121" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<loadSprite public="1" set="method" line="135">
			<f a="path:?Unique:?Key" v=":false:null">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="funkin.backend.FunkinSprite"/>
			</f>
			<meta><m n=":value"><e>{ Key : null, Unique : false }</e></m></meta>
		</loadSprite>
		<onPropertySet public="1" set="method" line="149"><f a="property:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></onPropertySet>
		<countedBeat expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</countedBeat>
		<beatHit public="1" set="method" line="156"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="168"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<measureHit public="1" set="method" line="172"><f a="curMeasure">
	<x path="Int"/>
	<x path="Void"/>
</f></measureHit>
		<draw public="1" set="method" line="178" override="1"><f a=""><x path="Void"/></f></draw>
		<copyAtlasValues public="1" set="method" line="191"><f a=""><x path="Void"/></f></copyAtlasValues>
		<destroy public="1" set="method" line="216" override="1"><f a=""><x path="Void"/></f></destroy>
		<__shouldDoZoomFactor get="inline" set="null" line="234"><f a=""><x path="Bool"/></f></__shouldDoZoomFactor>
		<getScreenBounds public="1" set="method" line="237" override="1"><f a="?newRect:?camera">
	<c path="flixel.math.FlxRect"/>
	<c path="flixel.FlxCamera"/>
	<c path="flixel.math.FlxRect"/>
</f></getScreenBounds>
		<isOnScreen public="1" set="method" line="260" override="1"><f a="?camera">
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></isOnScreen>
		<doAdditionalMatrixStuff public="1" set="method" line="275" override="1"><f a="matrix:camera">
	<c path="flixel.math.FlxMatrix"/>
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></doAdditionalMatrixStuff>
		<animOffsets public="1" expr="new Map&lt;String,FlxPoint&gt;()">
			<t path="Map">
				<c path="String"/>
				<x path="flixel.math.FlxPoint"/>
			</t>
			<meta><m n=":value"><e>new Map&lt;String,FlxPoint&gt;()</e></m></meta>
		</animOffsets>
		<addOffset public="1" set="method" line="292">
			<f a="name:?x:?y" v=":0:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</addOffset>
		<switchOffset public="1" set="method" line="297"><f a="anim1:anim2">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></switchOffset>
		<lastAnimContext public="1" expr="DANCE">
			<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
			<meta><m n=":value"><e>DANCE</e></m></meta>
		</lastAnimContext>
		<playAnim public="1" set="method" line="309">
			<f a="AnimName:?Force:?Context:?Reversed:?Frame" v="::NONE:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Context : NONE }</e></m></meta>
		</playAnim>
		<addAnim public="1" get="inline" set="null" line="340">
			<f a="name:prefix:?frameRate:?looped:?forced:?indices:?x:?y:?animType" v="::24::::0:0:NONE">
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="funkin.backend.XMLAnimType"/>
				<x path="funkin.backend.utils.ErrorCode"/>
			</f>
			<meta><m n=":value"><e>{ animType : NONE, y : 0, x : 0, frameRate : 24 }</e></m></meta>
		</addAnim>
		<removeAnim public="1" get="inline" set="null" line="355"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeAnim>
		<getAnim public="1" set="method" line="363"><f a="name">
	<c path="String"/>
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="flixel.animation.FlxAnimation"/>
		<c path="flxanimate.animate.FlxSymbolAnimation"/>
	</x>
</f></getAnim>
		<getAnimOffset public="1" get="inline" set="null" line="370"><f a="name">
	<c path="String"/>
	<x path="Null"><x path="flixel.math.FlxPoint"/></x>
</f></getAnimOffset>
		<hasAnim public="1" get="inline" set="null" line="376"><f a="AnimName">
	<c path="String"/>
	<x path="Bool"/>
</f></hasAnim>
		<getAnimName public="1" get="inline" set="null" line="380"><f a=""><c path="String"/></f></getAnimName>
		<isAnimReversed public="1" get="inline" set="null" line="384"><f a=""><x path="Bool"/></f></isAnimReversed>
		<getNameList public="1" get="inline" set="null" line="388"><f a=""><c path="Array"><c path="String"/></c></f></getNameList>
		<stopAnim public="1" get="inline" set="null" line="396"><f a=""><x path="Void"/></f></stopAnim>
		<isAnimFinished public="1" get="inline" set="null" line="403"><f a=""><x path="Bool"/></f></isAnimFinished>
		<isAnimAtEnd public="1" get="inline" set="null" line="407"><f a=""><x path="Bool"/></f></isAnimAtEnd>
		<updateAnimation set="method" line="411" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateAnimation>
		<hasAnimation public="1" get="inline" set="null" line="417"><f a="AnimName">
	<c path="String"/>
	<x path="Bool"/>
</f></hasAnimation>
		<removeAnimation public="1" get="inline" set="null" line="418"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeAnimation>
		<stopAnimation public="1" get="inline" set="null" line="419"><f a=""><x path="Void"/></f></stopAnimation>
		<set_beatInterval set="method" line="424">
			<f a="v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_beatInterval>
		<get_globalCurFrame get="inline" set="null" line="431">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_globalCurFrame>
		<set_globalCurFrame get="inline" set="null" line="434">
			<f a="val">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_globalCurFrame>
		<new public="1" set="method" line="73">
			<f a="?X:?Y:?SimpleGraphic" v="0:0:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.FunkinText" params="" file="source/funkin/backend/FunkinText.hx">
		<extends path="flixel.text.FlxText"/>
		<new public="1" set="method" line="7">
			<f a="?X:?Y:?FieldWidth:?Text:?Size:?Border" v="0:0:0::16:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Border : true, Size : 16, FieldWidth : 0, Y : 0, X : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.MusicBeatGroup" params="" file="source/funkin/backend/MusicBeatGroup.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<beatHit public="1" set="method" line="9"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="12"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<measureHit public="1" set="method" line="15"><f a="curMeasure">
	<x path="Int"/>
	<x path="Void"/>
</f></measureHit>
		<new public="1" set="method" line="8"><f a="?X:?Y:?MaxSize">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Group of FlxSprites, if the sprite implements `IBeatReceiver`, then beatHit, stepHit and measureHit will be called.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.MusicBeatState" params="" file="source/funkin/backend/MusicBeatState.hx">
		<extends path="flixel.FlxState"/>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<lastScriptName public="1" expr="null" line="100" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastScriptName>
		<lastStateName public="1" expr="null" line="101" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastStateName>
		<skipTransOut public="1" expr="false" line="105" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skipTransOut>
		<skipTransIn public="1" expr="false" line="106" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skipTransIn>
		<ALLOW_DEV_RELOAD public="1" expr="true" line="108" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</ALLOW_DEV_RELOAD>
		<lastBeat expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastBeat>
		<lastStep expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastStep>
		<graphicCache public="1" expr="new GraphicCacheSprite()">
			<c path="funkin.backend.system.GraphicCacheSprite"/>
			<meta><m n=":value"><e>new GraphicCacheSprite()</e></m></meta>
			<haxe_doc>* Dummy sprite used to cache graphics to GPU.</haxe_doc>
		</graphicCache>
		<cancelConductorUpdate public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the Conductor auto update should be enabled or not.</haxe_doc>
		</cancelConductorUpdate>
		<curStep public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current step</haxe_doc>
		</curStep>
		<curBeat public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current beat</haxe_doc>
		</curBeat>
		<curMeasure public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current beat</haxe_doc>
		</curMeasure>
		<curStepFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current step, as a `Float` (ex: 4.94, instead of 4)</haxe_doc>
		</curStepFloat>
		<curBeatFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current beat, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curBeatFloat>
		<curMeasureFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current beat, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curMeasureFloat>
		<songPos public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current song position (in milliseconds).</haxe_doc>
		</songPos>
		<get_curStep get="inline" set="null" line="64"><f a=""><x path="Int"/></f></get_curStep>
		<get_curBeat get="inline" set="null" line="66"><f a=""><x path="Int"/></f></get_curBeat>
		<get_curMeasure get="inline" set="null" line="68"><f a=""><x path="Int"/></f></get_curMeasure>
		<get_curStepFloat get="inline" set="null" line="70"><f a=""><x path="Float"/></f></get_curStepFloat>
		<get_curBeatFloat get="inline" set="null" line="72"><f a=""><x path="Float"/></f></get_curBeatFloat>
		<get_curMeasureFloat get="inline" set="null" line="74"><f a=""><x path="Float"/></f></get_curMeasureFloat>
		<get_songPos get="inline" set="null" line="76"><f a=""><x path="Float"/></f></get_songPos>
		<controls public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls. (All players / Solo)</haxe_doc>
		</controls>
		<controlsP1 public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls (Player 1 only)</haxe_doc>
		</controlsP1>
		<controlsP2 public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls (Player 2 only)</haxe_doc>
		</controlsP2>
		<stateScripts public="1">
			<c path="funkin.backend.scripting.ScriptPack"/>
			<haxe_doc>* Current injected script attached to the state. To add one, create a file at path "data/states/stateName" (ex: data/states/FreeplayState)</haxe_doc>
		</stateScripts>
		<scriptsAllowed public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</scriptsAllowed>
		<scriptName public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scriptName>
		<get_controls get="inline" set="null" line="111"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controls>
		<get_controlsP1 get="inline" set="null" line="113"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controlsP1>
		<get_controlsP2 get="inline" set="null" line="115"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controlsP2>
		<loadScript set="method" line="128"><f a=""><x path="Void"/></f></loadScript>
		<tryUpdate public="1" set="method" line="151" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></tryUpdate>
		<create public="1" set="method" line="173" override="1"><f a=""><x path="Void"/></f></create>
		<createPost public="1" set="method" line="180" override="1"><f a=""><x path="Void"/></f></createPost>
		<startTransition public="1" set="method" line="192">
			<f a="?newState:?skipSubStates" v=":false">
				<c path="flixel.FlxState"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ skipSubStates : false }</e></m></meta>
		</startTransition>
		<call public="1" set="method" line="217"><f a="name:?args:?defaultVal">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
	<d/>
</f></call>
		<event public="1" params="T" set="method" line="224"><f a="name:event">
	<c path="String"/>
	<c path="event.T"/>
	<c path="event.T"/>
</f></event>
		<update public="1" set="method" line="231" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<stepHit public="1" set="method" line="238">
			<f a="curStep">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</stepHit>
		<beatHit public="1" set="method" line="244">
			<f a="curBeat">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</beatHit>
		<measureHit public="1" set="method" line="250">
			<f a="curMeasure">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</measureHit>
		<lerp public="1" set="method" line="262">
			<f a="v1:v2:ratio:?fpsSensitive" v=":::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ fpsSensitive : false }</e></m></meta>
			<haxe_doc>* Shortcut to `FlxMath.lerp` or `CoolUtil.lerp`, depending on `fpsSensitive`
	 * @param v1 Value 1
	 * @param v2 Value 2
	 * @param ratio Ratio
	 * @param fpsSensitive Whenever the ratio should not be adjusted to run at the same speed independent of framerate.</haxe_doc>
		</lerp>
		<openSubState public="1" set="method" line="272" override="1">
			<f a="subState">
				<c path="flixel.FlxSubState"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* SCRIPTING STUFF</haxe_doc>
		</openSubState>
		<onResize public="1" set="method" line="278" override="1"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<destroy public="1" set="method" line="283" override="1"><f a=""><x path="Void"/></f></destroy>
		<draw public="1" set="method" line="290" override="1"><f a=""><x path="Void"/></f></draw>
		<switchTo public="1" set="method" line="298" override="1"><f a="nextState">
	<c path="flixel.FlxState"/>
	<x path="Bool"/>
</f></switchTo>
		<onFocus public="1" set="method" line="313" override="1"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost public="1" set="method" line="318" override="1"><f a=""><x path="Void"/></f></onFocusLost>
		<resetSubState public="1" set="method" line="323" override="1"><f a=""><x path="Void"/></f></resetSubState>
		<new public="1" set="method" line="117">
			<f a="?scriptsAllowed:?scriptName" v="true:">
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scriptsAllowed : true }</e></m></meta>
		</new>
		<haxe_doc>* Base class for all the states.
 * Handles the scripts, the transitions, and the beat and step events.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.MusicBeatSubstate" params="" file="source/funkin/backend/MusicBeatSubstate.hx">
		<extends path="flixel.FlxSubState"/>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<lastBeat expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastBeat>
		<lastStep expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastStep>
		<canOpenCustomTransition public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this specific substate can open custom transitions</haxe_doc>
		</canOpenCustomTransition>
		<curStep public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current step</haxe_doc>
		</curStep>
		<curBeat public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current beat</haxe_doc>
		</curBeat>
		<curMeasure public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Current beat</haxe_doc>
		</curMeasure>
		<curStepFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current step, as a `Float` (ex: 4.94, instead of 4)</haxe_doc>
		</curStepFloat>
		<curBeatFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current beat, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curBeatFloat>
		<curMeasureFloat public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current beat, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curMeasureFloat>
		<songPos public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Current song position (in milliseconds).</haxe_doc>
		</songPos>
		<get_curStep get="inline" set="null" line="57"><f a=""><x path="Int"/></f></get_curStep>
		<get_curBeat get="inline" set="null" line="59"><f a=""><x path="Int"/></f></get_curBeat>
		<get_curMeasure get="inline" set="null" line="61"><f a=""><x path="Int"/></f></get_curMeasure>
		<get_curStepFloat get="inline" set="null" line="63"><f a=""><x path="Float"/></f></get_curStepFloat>
		<get_curBeatFloat get="inline" set="null" line="65"><f a=""><x path="Float"/></f></get_curBeatFloat>
		<get_curMeasureFloat get="inline" set="null" line="67"><f a=""><x path="Float"/></f></get_curMeasureFloat>
		<get_songPos get="inline" set="null" line="69"><f a=""><x path="Float"/></f></get_songPos>
		<stateScripts public="1">
			<c path="funkin.backend.scripting.ScriptPack"/>
			<haxe_doc>* Current injected script attached to the state. To add one, create a file at path "data/states/stateName" (ex: "data/states/PauseMenuSubstate.hx")</haxe_doc>
		</stateScripts>
		<scriptsAllowed public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</scriptsAllowed>
		<scriptName public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</scriptName>
		<controls public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls. (All players / Solo)</haxe_doc>
		</controls>
		<controlsP1 public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls (Player 1 only)</haxe_doc>
		</controlsP1>
		<controlsP2 public="1" get="accessor" set="null">
			<c path="funkin.backend.system.Controls"/>
			<haxe_doc>* Game Controls (Player 2 only)</haxe_doc>
		</controlsP2>
		<get_controls get="inline" set="null" line="96"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controls>
		<get_controlsP1 get="inline" set="null" line="98"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controlsP1>
		<get_controlsP2 get="inline" set="null" line="100"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controlsP2>
		<loadScript set="method" line="109"><f a=""><x path="Void"/></f></loadScript>
		<tryUpdate public="1" set="method" line="132" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></tryUpdate>
		<close public="1" set="method" line="154" override="1"><f a=""><x path="Void"/></f></close>
		<create public="1" set="method" line="163" override="1"><f a=""><x path="Void"/></f></create>
		<createPost public="1" set="method" line="169" override="1"><f a=""><x path="Void"/></f></createPost>
		<call public="1" set="method" line="173"><f a="name:?args:?defaultVal">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
	<d/>
</f></call>
		<event public="1" params="T" set="method" line="180"><f a="name:event">
	<c path="String"/>
	<c path="event.T"/>
	<c path="event.T"/>
</f></event>
		<update public="1" set="method" line="187" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<stepHit public="1" set="method" line="193">
			<f a="curStep">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</stepHit>
		<beatHit public="1" set="method" line="199">
			<f a="curBeat">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</beatHit>
		<measureHit public="1" set="method" line="205">
			<f a="curMeasure">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</measureHit>
		<lerp public="1" set="method" line="217">
			<f a="v1:v2:ratio:?fpsSensitive" v=":::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ fpsSensitive : false }</e></m></meta>
			<haxe_doc>* Shortcut to `FlxMath.lerp` or `CoolUtil.lerp`, depending on `fpsSensitive`
	 * @param v1 Value 1
	 * @param v2 Value 2
	 * @param ratio Ratio
	 * @param fpsSensitive Whenever the ratio should not be adjusted to run at the same speed independent of framerate.</haxe_doc>
		</lerp>
		<openSubState public="1" set="method" line="227" override="1">
			<f a="subState">
				<c path="flixel.FlxSubState"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* SCRIPTING STUFF</haxe_doc>
		</openSubState>
		<onResize public="1" set="method" line="233" override="1"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<destroy public="1" set="method" line="238" override="1"><f a=""><x path="Void"/></f></destroy>
		<switchTo public="1" set="method" line="244" override="1"><f a="nextState">
	<c path="flixel.FlxState"/>
	<x path="Bool"/>
</f></switchTo>
		<onFocus public="1" set="method" line="251" override="1"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost public="1" set="method" line="256" override="1"><f a=""><x path="Void"/></f></onFocusLost>
		<parent public="1"><c path="flixel.FlxState"/></parent>
		<onSubstateOpen public="1" set="method" line="263"><f a=""><x path="Void"/></f></onSubstateOpen>
		<resetSubState public="1" set="method" line="265" override="1"><f a=""><x path="Void"/></f></resetSubState>
		<new public="1" set="method" line="103">
			<f a="?scriptsAllowed:?scriptName" v="true:">
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scriptsAllowed : true }</e></m></meta>
		</new>
		<haxe_doc>* Base class for all the sub states.
 * Handles the scripts, the transitions, and the beat and step events.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.Flags" params="" file="source/funkin/backend/system/Flags.hx">
		<addonFlags public="1" expr="[]" line="19" static="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":bypass"/>
			</meta>
		</addonFlags>
		<MOD_NAME public="1" expr="&quot;&quot;" line="22" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</MOD_NAME>
		<MOD_DESCRIPTION public="1" expr="&quot;&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</MOD_DESCRIPTION>
		<MOD_AUTHOR public="1" expr="&quot;&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</MOD_AUTHOR>
		<MOD_API_VERSION public="1" expr="1" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</MOD_API_VERSION>
		<MOD_DOWNLOAD_LINK public="1" expr="&quot;&quot;" line="26" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</MOD_DOWNLOAD_LINK>
		<MOD_DEPENDENCIES public="1" expr="[]" line="27" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</MOD_DEPENDENCIES>
		<MOD_ICON64 public="1" expr="&quot;&quot;" line="29" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>""</e></m>
				<m n=":noCompletion"/>
			</meta>
		</MOD_ICON64>
		<MOD_ICON32 public="1" expr="&quot;&quot;" line="30" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>""</e></m>
				<m n=":noCompletion"/>
			</meta>
		</MOD_ICON32>
		<MOD_ICON16 public="1" expr="&quot;&quot;" line="31" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>""</e></m>
				<m n=":noCompletion"/>
			</meta>
		</MOD_ICON16>
		<MOD_ICON public="1" expr="&quot;&quot;" line="32" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</MOD_ICON>
		<MOD_DISCORD_CLIENT_ID public="1" expr="&quot;&quot;" line="34" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</MOD_DISCORD_CLIENT_ID>
		<MOD_DISCORD_LOGO_KEY public="1" expr="&quot;&quot;" line="35" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</MOD_DISCORD_LOGO_KEY>
		<MOD_DISCORD_LOGO_TEXT public="1" expr="&quot;&quot;" line="36" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</MOD_DISCORD_LOGO_TEXT>
		<MOD_REDIRECT_STATES public="1" expr="[]" line="38" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</MOD_REDIRECT_STATES>
		<SAVE_PATH public="1" static="1">
			<c path="String"/>
			<meta><m n=":lazy"/></meta>
		</SAVE_PATH>
		<SAVE_NAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":lazy"/></meta>
		</SAVE_NAME>
		<CURRENT_API_VERSION public="1" expr="1" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CURRENT_API_VERSION>
		<COMMIT_NUMBER public="1" expr="GitCommitMacro.commitNumber" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GitCommitMacro.commitNumber</e></m></meta>
		</COMMIT_NUMBER>
		<COMMIT_HASH public="1" expr="GitCommitMacro.commitHash" line="46" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>GitCommitMacro.commitHash</e></m></meta>
		</COMMIT_HASH>
		<COMMIT_MESSAGE public="1" expr="&quot;Commit $COMMIT_NUMBER ($COMMIT_HASH)&quot;" line="47" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Commit $COMMIT_NUMBER ($COMMIT_HASH)"</e></m></meta>
		</COMMIT_MESSAGE>
		<TITLE public="1" static="1">
			<c path="String"/>
			<meta><m n=":lazy"/></meta>
		</TITLE>
		<VERSION public="1" static="1">
			<c path="String"/>
			<meta><m n=":lazy"/></meta>
		</VERSION>
		<VERSION_MESSAGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":lazy"/></meta>
		</VERSION_MESSAGE>
		<REPO_NAME public="1" expr="&quot;CodenameEngine&quot;" line="54" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"CodenameEngine"</e></m></meta>
		</REPO_NAME>
		<REPO_OWNER public="1" expr="&quot;CodenameCrew&quot;" line="55" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"CodenameCrew"</e></m></meta>
		</REPO_OWNER>
		<REPO_URL public="1" expr="&quot;https://github.com/$REPO_OWNER/$REPO_NAME&quot;" line="56" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"https://github.com/$REPO_OWNER/$REPO_NAME"</e></m></meta>
		</REPO_URL>
		<SOUND_EXT public="1" expr="&quot;ogg&quot;" line="62" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ogg"</e></m></meta>
			<haxe_doc>* Preferred sound extension for the game's audio files.
	 * Currently is set to `mp3` for web targets, and `ogg` for other targets.</haxe_doc>
		</SOUND_EXT>
		<VIDEO_EXT public="1" expr="&quot;mp4&quot;" line="63" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mp4"</e></m></meta>
		</VIDEO_EXT>
		<IMAGE_EXT public="1" expr="&quot;png&quot;" line="64" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"png"</e></m></meta>
		</IMAGE_EXT>
		<DEFAULT_DISCORD_LOGO_KEY public="1" expr="&quot;icon&quot;" line="66" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"icon"</e></m></meta>
		</DEFAULT_DISCORD_LOGO_KEY>
		<DEFAULT_DISCORD_CLIENT_ID public="1" expr="&quot;1383853614589673472&quot;" line="67" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"1383853614589673472"</e></m></meta>
		</DEFAULT_DISCORD_CLIENT_ID>
		<DEFAULT_DISCORD_LOGO_TEXT public="1" expr="&quot;Codename Engine&quot;" line="68" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Codename Engine"</e></m></meta>
		</DEFAULT_DISCORD_LOGO_TEXT>
		<DEFAULT_CHARACTER public="1" expr="&quot;bf&quot;" line="71" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"bf"</e></m>
				<m n=":also"><e>funkin.game.Character.FALLBACK_CHARACTER</e></m>
			</meta>
		</DEFAULT_CHARACTER>
		<DEFAULT_GIRLFRIEND public="1" expr="&quot;gf&quot;" line="72" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"gf"</e></m></meta>
		</DEFAULT_GIRLFRIEND>
		<DEFAULT_OPPONENT public="1" expr="&quot;dad&quot;" line="73" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"dad"</e></m></meta>
		</DEFAULT_OPPONENT>
		<DEFAULT_DIFFICULTY public="1" expr="&quot;normal&quot;" line="76" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"normal"</e></m>
				<m n=":also"><e>funkin.game.PlayState.difficulty</e></m>
			</meta>
		</DEFAULT_DIFFICULTY>
		<DEFAULT_STAGE public="1" expr="&quot;stage&quot;" line="77" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"stage"</e></m></meta>
		</DEFAULT_STAGE>
		<DEFAULT_SCROLL_SPEED public="1" expr="2.0" line="78" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.0</e></m></meta>
		</DEFAULT_SCROLL_SPEED>
		<DEFAULT_HEALTH_ICON public="1" expr="&quot;face&quot;" line="79" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"face"</e></m></meta>
		</DEFAULT_HEALTH_ICON>
		<SONGS_LIST_MOD_MODE public="1" expr="&quot;override&quot;" line="81" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"override"</e></m></meta>
		</SONGS_LIST_MOD_MODE>
		<WEEKS_LIST_MOD_MODE public="1" expr="&quot;override&quot;" line="82" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"override"</e></m></meta>
		</WEEKS_LIST_MOD_MODE>
		<DEFAULT_LANGUAGE public="1" expr="&quot;en&quot;" line="85" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"en"</e></m></meta>
		</DEFAULT_LANGUAGE>
		<DEFAULT_LANGUAGE_NAME public="1" expr="&quot;English&quot;" line="86" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"English"</e></m></meta>
		</DEFAULT_LANGUAGE_NAME>
		<BLACKLISTED_LANGUAGES public="1" expr="[]" line="91" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* **NOTICE:** This will only contain the id of the language, not the full name.
	 * If you blacklist the default language, you will need to change DEFAULT_LANGUAGE and DEFAULT_LANGUAGE_NAME.</haxe_doc>
		</BLACKLISTED_LANGUAGES>
		<WHITELISTED_LANGUAGES public="1" expr="[]" line="96" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* **NOTICE:** This will only contain the id of the language, not the full name.
	 * If this list is not empty, the languages listed will be the only ones able to be used.</haxe_doc>
		</WHITELISTED_LANGUAGES>
		<DEFAULT_BPM public="1" expr="100.0" line="99" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>100.0</e></m></meta>
		</DEFAULT_BPM>
		<DEFAULT_BEATS_PER_MEASURE public="1" expr="4" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</DEFAULT_BEATS_PER_MEASURE>
		<DEFAULT_STEPS_PER_BEAT public="1" expr="4" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</DEFAULT_STEPS_PER_BEAT>
		<DEFAULT_LOOP_TIME public="1" expr="0.0" line="102" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</DEFAULT_LOOP_TIME>
		<SUPPORTED_CHART_RUNTIME_FORMATS public="1" expr="[&quot;Legacy&quot;, &quot;Psych Engine&quot;]" line="104" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["Legacy", "Psych Engine"]</e></m></meta>
		</SUPPORTED_CHART_RUNTIME_FORMATS>
		<SUPPORTED_CHART_FORMATS public="1" expr="[&quot;BaseGame&quot;]" line="105" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["BaseGame"]</e></m></meta>
		</SUPPORTED_CHART_FORMATS>
		<VSLICE_SONG_METADATA_VERSION public="1" expr="&quot;2.2.2&quot;" line="107" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"2.2.2"</e></m></meta>
		</VSLICE_SONG_METADATA_VERSION>
		<VSLICE_SONG_CHART_DATA_VERSION public="1" expr="&quot;2.0.0&quot;" line="108" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"2.0.0"</e></m></meta>
		</VSLICE_SONG_CHART_DATA_VERSION>
		<VSLICE_DEFAULT_NOTE_STYLE public="1" expr="&quot;funkin&quot;" line="109" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"funkin"</e></m></meta>
		</VSLICE_DEFAULT_NOTE_STYLE>
		<VSLICE_DEFAULT_ALBUM_ID public="1" expr="&quot;volume1&quot;" line="110" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"volume1"</e></m></meta>
		</VSLICE_DEFAULT_ALBUM_ID>
		<VSLICE_DEFAULT_PREVIEW_START public="1" expr="0" line="111" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</VSLICE_DEFAULT_PREVIEW_START>
		<VSLICE_DEFAULT_PREVIEW_END public="1" expr="15000" line="112" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15000</e></m></meta>
		</VSLICE_DEFAULT_PREVIEW_END>
		<DEFAULT_COLOR public="1" expr="0xFF9271FD" line="117" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF9271FD</e></m></meta>
			<haxe_doc>* Default background colors for songs or more without bg color</haxe_doc>
		</DEFAULT_COLOR>
		<DEFAULT_WEEK_COLOR public="1" expr="0xFFF9CF51" line="118" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFFF9CF51</e></m></meta>
		</DEFAULT_WEEK_COLOR>
		<DEFAULT_COOP_ALLOWED public="1" expr="false" line="119" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</DEFAULT_COOP_ALLOWED>
		<DEFAULT_OPPONENT_MODE_ALLOWED public="1" expr="false" line="120" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</DEFAULT_OPPONENT_MODE_ALLOWED>
		<DEFAULT_COOP_MODE public="1" expr="false" line="123" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":also"><e>funkin.game.PlayState.coopMode</e></m>
			</meta>
		</DEFAULT_COOP_MODE>
		<DEFAULT_OPPONENT_MODE public="1" expr="false" line="125" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":also"><e>funkin.game.PlayState.opponentMode</e></m>
			</meta>
		</DEFAULT_OPPONENT_MODE>
		<DEFAULT_NOTE_MS_LIMIT public="1" expr="1500" line="127" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1500</e></m></meta>
		</DEFAULT_NOTE_MS_LIMIT>
		<DEFAULT_NOTE_SCALE public="1" expr="0.7" line="128" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.7</e></m></meta>
		</DEFAULT_NOTE_SCALE>
		<DEFAULT_GAMEOVER_CHARACTER public="1" expr="&quot;bf-dead&quot;" line="131" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"bf-dead"</e></m>
				<m n=":also"><e>funkin.game.Character.FALLBACK_DEAD_CHARACTER</e></m>
			</meta>
		</DEFAULT_GAMEOVER_CHARACTER>
		<DEFAULT_CAM_ZOOM_INTERVAL public="1" expr="1" line="133" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</DEFAULT_CAM_ZOOM_INTERVAL>
		<DEFAULT_CAM_ZOOM_OFFSET public="1" expr="0" line="134" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</DEFAULT_CAM_ZOOM_OFFSET>
		<DEFAULT_CAM_ZOOM_STRENGTH public="1" expr="1" line="136" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</DEFAULT_CAM_ZOOM_STRENGTH>
		<DEFAULT_CAM_ZOOM public="1" expr="1.05" line="137" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.05</e></m></meta>
		</DEFAULT_CAM_ZOOM>
		<DEFAULT_HUD_ZOOM public="1" expr="1.0" line="138" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</DEFAULT_HUD_ZOOM>
		<MAX_CAMERA_ZOOM_MULT public="1" expr="1.35" line="139" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.35</e></m></meta>
		</MAX_CAMERA_ZOOM_MULT>
		<DEFAULT_PAUSE_ITEMS public="1" expr="[&quot;Resume&quot;, &quot;Restart Song&quot;, &quot;Change Controls&quot;, &quot;Change Options&quot;, &quot;Exit to menu&quot;, &quot;Exit to charter&quot;]" line="151" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["Resume", "Restart Song", "Change Controls", "Change Options", "Exit to menu", "Exit to charter"]</e></m></meta>
		</DEFAULT_PAUSE_ITEMS>
		<DEFAULT_CUTSCENE_PAUSE_ITEMS public="1" expr="[&quot;Resume Cutscene&quot;, &quot;Skip Cutscene&quot;, &quot;Restart Cutscene&quot;, &quot;Exit to menu&quot;]" line="152" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["Resume Cutscene", "Skip Cutscene", "Restart Cutscene", "Exit to menu"]</e></m></meta>
		</DEFAULT_CUTSCENE_PAUSE_ITEMS>
		<DEFAULT_GITAROO public="1" expr="true" line="153" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</DEFAULT_GITAROO>
		<GITAROO_CHANCE public="1" expr="0.1" line="154" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
		</GITAROO_CHANCE>
		<DEFAULT_MUTE_VOCALS_ON_MISS public="1" expr="true" line="155" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</DEFAULT_MUTE_VOCALS_ON_MISS>
		<DEFAULT_MAX_HEALTH public="1" expr="2.0" line="157" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.0</e></m></meta>
		</DEFAULT_MAX_HEALTH>
		<DEFAULT_HEALTH public="1" expr="null" line="158" static="1">
			<x path="Null"><x path="Null"><x path="Float"/></x></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</DEFAULT_HEALTH>
		<DEFAULT_ICONBOP public="1" expr="true" line="159" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</DEFAULT_ICONBOP>
		<BOP_ICON_SCALE public="1" expr="1.2" line="160" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.2</e></m></meta>
		</BOP_ICON_SCALE>
		<ICON_OFFSET public="1" expr="26" line="161" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>26</e></m></meta>
		</ICON_OFFSET>
		<ICON_LERP public="1" expr="0.33" line="162" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.33</e></m></meta>
		</ICON_LERP>
		<DEFAULT_INTRO_LENGTH public="1" expr="5" line="164" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</DEFAULT_INTRO_LENGTH>
		<DEFAULT_INTRO_SPRITES public="1" expr="[null, &quot;game/ready&quot;, &quot;game/set&quot;, &quot;game/go&quot;]" line="165" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[null, "game/ready", "game/set", "game/go"]</e></m></meta>
		</DEFAULT_INTRO_SPRITES>
		<CAM_BOP_STRENGTH public="1" expr="0.015" line="167" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.015</e></m></meta>
		</CAM_BOP_STRENGTH>
		<HUD_BOP_STRENGTH public="1" expr="0.03" line="168" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.03</e></m></meta>
		</HUD_BOP_STRENGTH>
		<DEFAULT_CAM_ZOOM_LERP public="1" expr="0.05" line="169" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.05</e></m></meta>
		</DEFAULT_CAM_ZOOM_LERP>
		<DEFAULT_HUD_ZOOM_LERP public="1" expr="0.05" line="170" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.05</e></m></meta>
		</DEFAULT_HUD_ZOOM_LERP>
		<MAX_SPLASHES public="1" expr="8" line="172" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</MAX_SPLASHES>
		<STUNNED_TIME public="1" expr="5 / 60" line="173" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>5 / 60</e></m></meta>
		</STUNNED_TIME>
		<PIXEL_ART_SCALE public="1" expr="6.0" line="176" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>6.0</e></m>
				<m n=":also"><e>funkin.game.PlayState.daPixelZoom</e></m>
			</meta>
		</PIXEL_ART_SCALE>
		<DEFAULT_COMBO_GROUP_MAX_SIZE public="1" expr="25" line="178" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</DEFAULT_COMBO_GROUP_MAX_SIZE>
		<DEFAULT_STRUM_AMOUNT public="1" expr="4" line="180" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</DEFAULT_STRUM_AMOUNT>
		<DEFAULT_CAMERA_FOLLOW_SPEED public="1" expr="0.04" line="181" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.04</e></m></meta>
		</DEFAULT_CAMERA_FOLLOW_SPEED>
		<VOCAL_OFFSET_VIOLATION_THRESHOLD public="1" expr="25" line="183" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</VOCAL_OFFSET_VIOLATION_THRESHOLD>
		<MAIN_DEVS_COLOR public="1" expr="0xFF9C35D5" line="186" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF9C35D5</e></m></meta>
		</MAIN_DEVS_COLOR>
		<MIN_CONTRIBUTIONS_COLOR public="1" expr="0xFFB4A7DA" line="187" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFFB4A7DA</e></m></meta>
		</MIN_CONTRIBUTIONS_COLOR>
		<UNDO_PREFIX public="1" expr="&quot;* &quot;" line="189" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"* "</e></m></meta>
		</UNDO_PREFIX>
		<JSON_PRETTY_PRINT public="1" expr="&quot;\t&quot;" line="190" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"\t"</e></m></meta>
		</JSON_PRETTY_PRINT>
		<DISABLE_EDITORS public="1" expr="false" line="192" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</DISABLE_EDITORS>
		<DISABLE_WARNING_SCREEN public="1" expr="true" line="193" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</DISABLE_WARNING_SCREEN>
		<DISABLE_TRANSITIONS public="1" expr="false" line="194" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</DISABLE_TRANSITIONS>
		<DISABLE_LANGUAGES public="1" expr="false" line="195" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</DISABLE_LANGUAGES>
		<DEFAULT_TRANSITION_SCRIPT public="1" expr="&quot;&quot;" line="198" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>""</e></m>
				<m n=":also"><e>funkin.backend.MusicBeatTransition.script</e></m>
			</meta>
		</DEFAULT_TRANSITION_SCRIPT>
		<DEFAULT_PAUSE_SCRIPT public="1" expr="&quot;&quot;" line="200" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>""</e></m>
				<m n=":also"><e>funkin.menus.PauseSubState.script</e></m>
			</meta>
		</DEFAULT_PAUSE_SCRIPT>
		<DEFAULT_GAMEOVER_SCRIPT public="1" expr="&quot;&quot;" line="202" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>""</e></m>
				<m n=":also"><e>funkin.game.GameOverSubstate.script</e></m>
			</meta>
		</DEFAULT_GAMEOVER_SCRIPT>
		<URL_WIKI public="1" expr="&quot;https://codename-engine.com/&quot;" line="204" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"https://codename-engine.com/"</e></m></meta>
		</URL_WIKI>
		<URL_EDITOR_FALLBACK public="1" expr="&quot;https://www.youtube.com/watch?v=9Youam7GYdQ&quot;" line="205" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"https://www.youtube.com/watch?v=9Youam7GYdQ"</e></m></meta>
		</URL_EDITOR_FALLBACK>
		<URL_FNF_ITCH public="1" expr="&quot;https://ninja-muffin24.itch.io/funkin&quot;" line="206" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"https://ninja-muffin24.itch.io/funkin"</e></m></meta>
		</URL_FNF_ITCH>
		<DEFAULT_MENU_MUSIC public="1" expr="&quot;freakyMenu&quot;" line="211" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"freakyMenu"</e></m></meta>
			<haxe_doc>* Default audio paths</haxe_doc>
		</DEFAULT_MENU_MUSIC>
		<DEFAULT_PAUSE_MENU_MUSIC public="1" expr="&quot;breakfast&quot;" line="212" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"breakfast"</e></m></meta>
		</DEFAULT_PAUSE_MENU_MUSIC>
		<DEFAULT_GAMEOVER_MUSIC public="1" expr="&quot;gameOver&quot;" line="213" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"gameOver"</e></m></meta>
		</DEFAULT_GAMEOVER_MUSIC>
		<DEFAULT_MISS_SOUNDS public="1" expr="[&quot;missnote1&quot;, &quot;missnote2&quot;, &quot;missnote3&quot;]" line="215" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["missnote1", "missnote2", "missnote3"]</e></m></meta>
		</DEFAULT_MISS_SOUNDS>
		<DEFAULT_INTRO_SOUNDS public="1" expr="[&quot;intro3&quot;, &quot;intro2&quot;, &quot;intro1&quot;, &quot;introGo&quot;]" line="216" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["intro3", "intro2", "intro1", "introGo"]</e></m></meta>
		</DEFAULT_INTRO_SOUNDS>
		<DEFAULT_GAMEOVERSFX_SOUND public="1" expr="&quot;gameOverSFX&quot;" line="217" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"gameOverSFX"</e></m></meta>
		</DEFAULT_GAMEOVERSFX_SOUND>
		<DEFAULT_GAMEOVEREND_SOUND public="1" expr="&quot;gameOverEnd&quot;" line="218" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"gameOverEnd"</e></m></meta>
		</DEFAULT_GAMEOVEREND_SOUND>
		<DEFAULT_MENU_SCROLL_SOUND public="1" expr="&quot;menu/scroll&quot;" line="220" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"menu/scroll"</e></m></meta>
		</DEFAULT_MENU_SCROLL_SOUND>
		<DEFAULT_MENU_CONFIRM_SOUND public="1" expr="&quot;menu/confirm&quot;" line="221" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"menu/confirm"</e></m></meta>
		</DEFAULT_MENU_CONFIRM_SOUND>
		<DEFAULT_MENU_CANCEL_SOUND public="1" expr="&quot;menu/cancel&quot;" line="222" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"menu/cancel"</e></m></meta>
		</DEFAULT_MENU_CANCEL_SOUND>
		<DEFAULT_MENU_VOLUME_SOUND public="1" expr="&quot;menu/volume&quot;" line="223" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"menu/volume"</e></m></meta>
		</DEFAULT_MENU_VOLUME_SOUND>
		<DEFAULT_EDITOR_CHECKBOXCHECKED_SOUND public="1" expr="&quot;editors/checkboxChecked&quot;" line="225" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/checkboxChecked"</e></m></meta>
		</DEFAULT_EDITOR_CHECKBOXCHECKED_SOUND>
		<DEFAULT_EDITOR_CHECKBOXUNCHECKED_SOUND public="1" expr="&quot;editors/checkboxUnchecked&quot;" line="226" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/checkboxUnchecked"</e></m></meta>
		</DEFAULT_EDITOR_CHECKBOXUNCHECKED_SOUND>
		<DEFAULT_EDITOR_WARNING_SOUND public="1" expr="&quot;editors/warningMenu&quot;" line="227" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/warningMenu"</e></m></meta>
		</DEFAULT_EDITOR_WARNING_SOUND>
		<DEFAULT_EDITOR_AUTOSAVE_SOUND public="1" expr="&quot;editors/autosave&quot;" line="228" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/autosave"</e></m></meta>
		</DEFAULT_EDITOR_AUTOSAVE_SOUND>
		<DEFAULT_EDITOR_BUTTONCLICK_SOUND public="1" expr="&quot;editors/buttonClick&quot;" line="229" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/buttonClick"</e></m></meta>
		</DEFAULT_EDITOR_BUTTONCLICK_SOUND>
		<DEFAULT_EDITOR_CLICK_SOUND public="1" expr="&quot;editors/click&quot;" line="230" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/click"</e></m></meta>
		</DEFAULT_EDITOR_CLICK_SOUND>
		<DEFAULT_EDITOR_COPY_SOUND public="1" expr="&quot;editors/copy&quot;" line="231" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/copy"</e></m></meta>
		</DEFAULT_EDITOR_COPY_SOUND>
		<DEFAULT_EDITOR_CUT_SOUND public="1" expr="&quot;editors/cut&quot;" line="232" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/cut"</e></m></meta>
		</DEFAULT_EDITOR_CUT_SOUND>
		<DEFAULT_EDITOR_DELETE_SOUND public="1" expr="&quot;editors/delete&quot;" line="233" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/delete"</e></m></meta>
		</DEFAULT_EDITOR_DELETE_SOUND>
		<DEFAULT_EDITOR_OFFSETDRAG_SOUND public="1" expr="&quot;editors/offsetDrag&quot;" line="234" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/offsetDrag"</e></m></meta>
		</DEFAULT_EDITOR_OFFSETDRAG_SOUND>
		<DEFAULT_EDITOR_PASTE_SOUND public="1" expr="&quot;editors/paste&quot;" line="235" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/paste"</e></m></meta>
		</DEFAULT_EDITOR_PASTE_SOUND>
		<DEFAULT_EDITOR_REDO_SOUND public="1" expr="&quot;editors/redo&quot;" line="236" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/redo"</e></m></meta>
		</DEFAULT_EDITOR_REDO_SOUND>
		<DEFAULT_EDITOR_SAVE_SOUND public="1" expr="&quot;editors/save&quot;" line="237" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/save"</e></m></meta>
		</DEFAULT_EDITOR_SAVE_SOUND>
		<DEFAULT_EDITOR_TEXTREMOVE_SOUND public="1" expr="&quot;editors/textRemove&quot;" line="238" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/textRemove"</e></m></meta>
		</DEFAULT_EDITOR_TEXTREMOVE_SOUND>
		<DEFAULT_EDITOR_TEXTTYPE_SOUND public="1" expr="&quot;editors/textType&quot;" line="239" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/textType"</e></m></meta>
		</DEFAULT_EDITOR_TEXTTYPE_SOUND>
		<DEFAULT_EDITOR_UNDO_SOUND public="1" expr="&quot;editors/undo&quot;" line="240" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/undo"</e></m></meta>
		</DEFAULT_EDITOR_UNDO_SOUND>
		<DEFAULT_EDITOR_WINDOWAPPEAR_SOUND public="1" expr="&quot;editors/windowAppear&quot;" line="241" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/windowAppear"</e></m></meta>
		</DEFAULT_EDITOR_WINDOWAPPEAR_SOUND>
		<DEFAULT_EDITOR_WINDOWCLOSE_SOUND public="1" expr="&quot;editors/windowClose&quot;" line="242" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/windowClose"</e></m></meta>
		</DEFAULT_EDITOR_WINDOWCLOSE_SOUND>
		<DEFAULT_EDITOR_DROPDOWNAPPEAR_SOUND public="1" expr="&quot;editors/dropdownAppear&quot;" line="243" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/dropdownAppear"</e></m></meta>
		</DEFAULT_EDITOR_DROPDOWNAPPEAR_SOUND>
		<DEFAULT_CHARTER_HITSOUND_SOUND public="1" expr="&quot;editors/charter/hitsound&quot;" line="244" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/charter/hitsound"</e></m></meta>
		</DEFAULT_CHARTER_HITSOUND_SOUND>
		<DEFAULT_CHARTER_METRONOME_SOUND public="1" expr="&quot;editors/charter/metronome&quot;" line="245" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/charter/metronome"</e></m></meta>
		</DEFAULT_CHARTER_METRONOME_SOUND>
		<DEFAULT_CHARTER_NOTEDELETE_SOUND public="1" expr="&quot;editors/charter/noteDelete&quot;" line="246" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/charter/noteDelete"</e></m></meta>
		</DEFAULT_CHARTER_NOTEDELETE_SOUND>
		<DEFAULT_CHARTER_NOTEPLACE_SOUND public="1" expr="&quot;editors/charter/notePlace&quot;" line="247" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/charter/notePlace"</e></m></meta>
		</DEFAULT_CHARTER_NOTEPLACE_SOUND>
		<DEFAULT_CHARTER_SCROLL_SOUND public="1" expr="&quot;editors/charter/scroll&quot;" line="248" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/charter/scroll"</e></m></meta>
		</DEFAULT_CHARTER_SCROLL_SOUND>
		<DEFAULT_CHARTER_SNAPPINGCHANGE_SOUND public="1" expr="&quot;editors/charter/snappingChange&quot;" line="249" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/charter/snappingChange"</e></m></meta>
		</DEFAULT_CHARTER_SNAPPINGCHANGE_SOUND>
		<DEFAULT_CHARTER_STRUMLOCK_SOUND public="1" expr="&quot;editors/charter/strumLock&quot;" line="250" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/charter/strumLock"</e></m></meta>
		</DEFAULT_CHARTER_STRUMLOCK_SOUND>
		<DEFAULT_CHARTER_STRUMUNLOCK_SOUND public="1" expr="&quot;editors/charter/strumUnlock&quot;" line="251" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/charter/strumUnlock"</e></m></meta>
		</DEFAULT_CHARTER_STRUMUNLOCK_SOUND>
		<DEFAULT_CHARTER_SUSTAINADD_SOUND public="1" expr="&quot;editors/charter/sustainAdd&quot;" line="252" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/charter/sustainAdd"</e></m></meta>
		</DEFAULT_CHARTER_SUSTAINADD_SOUND>
		<DEFAULT_CHARTER_SUSTAINDELETE_SOUND public="1" expr="&quot;editors/charter/sustainDelete&quot;" line="253" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/charter/sustainDelete"</e></m></meta>
		</DEFAULT_CHARTER_SUSTAINDELETE_SOUND>
		<DEFAULT_CHARACTER_GHOSTDISABLE_SOUND public="1" expr="&quot;editors/character/ghostDisable&quot;" line="254" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/character/ghostDisable"</e></m></meta>
		</DEFAULT_CHARACTER_GHOSTDISABLE_SOUND>
		<DEFAULT_CHARACTER_GHOSTENABLE_SOUND public="1" expr="&quot;editors/character/ghostEnable&quot;" line="255" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/character/ghostEnable"</e></m></meta>
		</DEFAULT_CHARACTER_GHOSTENABLE_SOUND>
		<DEFAULT_GLSL_VERSION public="1" expr="&quot;120&quot;" line="257" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"120"</e></m></meta>
		</DEFAULT_GLSL_VERSION>
		<USER_AGENT public="1" expr="&quot;request&quot;" line="259" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"request"</e></m>
				<m n=":also"><e>funkin.backend.utils.HttpUtil.userAgent</e></m>
			</meta>
		</USER_AGENT>
		<customFlags public="1" expr="[]" line="265" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":bypass"/>
			</meta>
			<haxe_doc>* Flags that Codename couldn't recognize as it's own defaults (they can only be `string`! due to them being unparsed).</haxe_doc>
		</customFlags>
		<loadFromData public="1" set="method" line="267" static="1"><f a="flags:data">
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
	<c path="String"/>
	<x path="Void"/>
</f></loadFromData>
		<loadFromDatas public="1" set="method" line="286" static="1"><f a="datas">
	<c path="Array"><c path="String"/></c>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
</f></loadFromDatas>
		<parseFlags public="1" set="method" line="295" static="1"><f a="flags">
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
	<x path="Void"/>
</f></parseFlags>
		<load public="1" set="method" line="304" static="1">
			<f a="?libs" v="null">
				<c path="Array"><t path="lime.utils._AssetLibrary.LimeAssetLibrary"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ libs : null }</e></m></meta>
			<haxe_doc>* Loads the flags from the assets.</haxe_doc>
		</load>
		<reset public="1" set="method" line="253" static="1"><f a=""><x path="Void"/></f></reset>
		<parse public="1" set="method" line="266" static="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></parse>
		<parseBool set="method" line="283" static="1"><f a="e">
	<c path="String"/>
	<x path="Bool"/>
</f></parseBool>
		<haxe_doc>* A class that reads the `flags.ini` file, allowing to read settable Flags (customs too).</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.FlagMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.MusicBeatTransition" params="" file="source/funkin/backend/MusicBeatTransition.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<script public="1" expr="Flags.DEFAULT_TRANSITION_SCRIPT" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_TRANSITION_SCRIPT</e></m></meta>
		</script>
		<transitionScript public="1"><c path="funkin.backend.scripting.Script"/></transitionScript>
		<nextFrameSkip expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</nextFrameSkip>
		<transitionTween public="1" expr="null">
			<c path="flixel.tweens.FlxTween"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</transitionTween>
		<transitionCamera public="1"><c path="flixel.FlxCamera"/></transitionCamera>
		<newState public="1"><c path="flixel.FlxState"/></newState>
		<transOut public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transOut>
		<allowSkip public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowSkip>
		<blackSpr public="1"><c path="flixel.FlxSprite"/></blackSpr>
		<transitionSprite public="1"><c path="funkin.backend.FunkinSprite"/></transitionSprite>
		<create public="1" set="method" line="32" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="75" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onResize public="1" set="method" line="104" override="1"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<resizeDefaultSprites public="1" set="method" line="110"><f a=""><x path="Void"/></f></resizeDefaultSprites>
		<finish public="1" set="method" line="126"><f a=""><x path="Void"/></f></finish>
		<destroy public="1" set="method" line="138" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="27"><f a="?newState">
	<c path="flixel.FlxState"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.TurboBasic" params="" file="source/funkin/backend/TurboControls.hx" module="funkin.backend.TurboControls">
		<extends path="flixel.FlxBasic"/>
		<DEFAULT_DELAY public="1" expr="0.4" line="14" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.4</e></m></meta>
		</DEFAULT_DELAY>
		<DEFAULT_INTERVAL public="1" expr="1 / 18" line="15" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1 / 18</e></m></meta>
		</DEFAULT_INTERVAL>
		<delay public="1"><x path="Float"/></delay>
		<interval public="1"><x path="Float"/></interval>
		<activated public="1" set="null"><x path="Bool"/></activated>
		<pressed public="1" get="accessor" set="null"><x path="Bool"/></pressed>
		<get_pressed set="method" line="20"><f a=""><x path="Bool"/></f></get_pressed>
		<allPress public="1"><x path="Bool"/></allPress>
		<time expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</time>
		<update public="1" set="method" line="32" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="25">
			<f a="?delay:?interval:?allPress" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ allPress : false }</e></m></meta>
		</new>
	</class>
	<class path="funkin.backend.TurboControls" params="" file="source/funkin/backend/TurboControls.hx">
		<extends path="funkin.backend.TurboBasic"/>
		<controlsInstance public="1"><c path="funkin.backend.system.Controls"/></controlsInstance>
		<controls public="1"><c path="Array"><e path="funkin.backend.system.Control"/></c></controls>
		<get_pressed set="method" line="56" override="1"><f a=""><x path="Bool"/></f></get_pressed>
		<new public="1" set="method" line="50"><f a="controls:?controlsInstance:?delay:?interval:?allPress">
	<c path="Array"><e path="funkin.backend.system.Control"/></c>
	<c path="funkin.backend.system.Controls"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.TurboActions" params="" file="source/funkin/backend/TurboControls.hx" module="funkin.backend.TurboControls">
		<extends path="funkin.backend.TurboBasic"/>
		<actions public="1"><c path="Array"><c path="flixel.input.actions.FlxAction"/></c></actions>
		<get_pressed set="method" line="74" override="1"><f a=""><x path="Bool"/></f></get_pressed>
		<new public="1" set="method" line="69"><f a="actions:?delay:?interval:?allPress">
	<c path="Array"><c path="flixel.input.actions.FlxAction"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.backend.TurboKeys" params="" file="source/funkin/backend/TurboControls.hx" module="funkin.backend.TurboControls">
		<extends path="funkin.backend.TurboBasic"/>
		<keys public="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></keys>
		<get_pressed set="method" line="92" override="1"><f a=""><x path="Bool"/></f></get_pressed>
		<new public="1" set="method" line="87"><f a="keys:?delay:?interval:?allPress">
	<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.backend.TurboButtons" params="" file="source/funkin/backend/TurboControls.hx" module="funkin.backend.TurboControls">
		<extends path="funkin.backend.TurboBasic"/>
		<inputs public="1"><c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c></inputs>
		<gamepad public="1"><c path="flixel.input.gamepad.FlxGamepad"/></gamepad>
		<get_pressed set="method" line="112" override="1"><f a=""><x path="Bool"/></f></get_pressed>
		<new public="1" set="method" line="106"><f a="inputs:?gamepad:?delay:?interval:?allPress">
	<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
	<c path="flixel.input.gamepad.FlxGamepad"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="funkin.backend.assets.AssetSource" params="" file="source/funkin/backend/assets/AssetSource.hx">
		<from>
			<icast><x path="Null"><x path="Int"/></x></icast>
			<icast field="fromString"><c path="String"/></icast>
		</from>
		<this><x path="Null"><x path="Int"/></x></this>
		<to>
			<icast><x path="Null"><x path="Int"/></x></icast>
			<icast field="toString"><c path="String"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.assets._AssetSource.AssetSource_Impl_" params="" file="source/funkin/backend/assets/AssetSource.hx" private="1" module="funkin.backend.assets.AssetSource" final="1">
	<SOURCE public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="funkin.backend.assets.AssetSource"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SOURCE>
	<MODS public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="funkin.backend.assets.AssetSource"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MODS>
	<BOTH public="1" get="inline" set="null" expr="cast -1" line="6" static="1">
		<x path="funkin.backend.assets.AssetSource"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BOTH>
	<fromString public="1" set="method" line="9" static="1">
		<f a="str">
			<c path="String"/>
			<x path="funkin.backend.assets.AssetSource"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString public="1" get="inline" set="null" line="31" static="1">
		<f a="this">
			<x path="Null"><x path="Int"/></x>
			<c path="String"/>
		</f>
		<meta><m n=":to"/></meta>
	</toString>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.assets._AssetSource.AssetSource_Impl_" params="" file="source/funkin/backend/assets/AssetSource.hx" private="1" module="funkin.backend.assets.AssetSource" final="1">
		<SOURCE public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="funkin.backend.assets.AssetSource"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SOURCE>
		<MODS public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="funkin.backend.assets.AssetSource"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MODS>
		<BOTH public="1" get="inline" set="null" expr="cast -1" line="6" static="1">
			<x path="funkin.backend.assets.AssetSource"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BOTH>
		<fromString public="1" set="method" line="9" static="1">
			<f a="str">
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString public="1" get="inline" set="null" line="31" static="1">
			<f a="this">
				<x path="Null"><x path="Int"/></x>
				<c path="String"/>
			</f>
			<meta><m n=":to"/></meta>
		</toString>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.assets.AssetsLibraryList" params="" file="source/funkin/backend/assets/AssetsLibraryList.hx">
		<extends path="lime.utils.AssetLibrary"/>
		<getCleanLibrary public="1" set="method" line="201" static="1"><f a="e">
	<c path="lime.utils.AssetLibrary"/>
	<c path="lime.utils.AssetLibrary"/>
</f></getCleanLibrary>
		<libraries public="1" expr="[]">
			<c path="Array"><c path="lime.utils.AssetLibrary"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</libraries>
		<__defaultLibraries expr="[]">
			<c path="Array"><c path="lime.utils.AssetLibrary"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":allow"><e>funkin.backend.system.Main</e></m>
				<m n=":allow"><e>funkin.backend.system.MainState</e></m>
			</meta>
		</__defaultLibraries>
		<base public="1"><c path="lime.utils.AssetLibrary"/></base>
		<transLib public="1"><c path="funkin.backend.assets.TranslatedAssetLibrary"/></transLib>
		<removeLibrary public="1" set="method" line="21"><f a="lib">
	<c path="lime.utils.AssetLibrary"/>
	<c path="lime.utils.AssetLibrary"/>
</f></removeLibrary>
		<existsSpecific public="1" set="method" line="41">
			<f a="id:type:?source" v="::BOTH">
				<c path="String"/>
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</existsSpecific>
		<exists public="1" get="inline" set="null" line="53" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getSpecificPath public="1" set="method" line="55">
			<f a="id:?source" v=":BOTH">
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</getSpecificPath>
		<getPath public="1" get="inline" set="null" line="70" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<getFiles public="1" set="method" line="72">
			<f a="folder:?source" v=":BOTH">
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</getFiles>
		<getFolders public="1" set="method" line="91">
			<f a="folder:?source" v=":BOTH">
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</getFolders>
		<getSpecificAsset public="1" set="method" line="110">
			<f a="id:type:?source" v="::BOTH">
				<c path="String"/>
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</getSpecificAsset>
		<shouldSkipLib set="method" line="137"><f a="lib:source">
	<c path="lime.utils.AssetLibrary"/>
	<x path="funkin.backend.assets.AssetSource"/>
	<x path="Bool"/>
</f></shouldSkipLib>
		<getAsset public="1" get="inline" set="null" line="142" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></getAsset>
		<isLocal public="1" set="method" line="144" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<unloadLibraries public="1" set="method" line="169"><f a=""><x path="Void"/></f></unloadLibraries>
		<reset public="1" set="method" line="175"><f a=""><x path="Void"/></f></reset>
		<addLibrary public="1" set="method" line="184">
			<f a="lib:?tag:?addTransLib" v="::true">
				<c path="lime.utils.AssetLibrary"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<x path="Bool"/>
				<c path="lime.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ addTransLib : true }</e></m></meta>
		</addLibrary>
		<new public="1" set="method" line="148"><f a="?base">
	<c path="lime.utils.AssetLibrary"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.IModsAssetLibrary" params="" file="source/funkin/backend/assets/IModsAssetLibrary.hx" interface="1">
		<prefix public="1"><c path="String"/></prefix>
		<modName public="1"><c path="String"/></modName>
		<libName public="1"><c path="String"/></libName>
		<basePath public="1"><c path="String"/></basePath>
		<_parsedAsset public="1"><c path="String"/></_parsedAsset>
		<getAssetPath set="method"><f a=""><c path="String"/></f></getAssetPath>
		<__isCacheValid set="method">
			<f a="cache:asset:?isLocal" v="::false">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ isLocal : false }</e></m></meta>
		</__isCacheValid>
		<__parseAsset set="method"><f a="asset">
	<c path="String"/>
	<x path="Bool"/>
</f></__parseAsset>
		<getFiles public="1" set="method"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFiles>
		<getFolders public="1" set="method"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFolders>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.LimeLibrarySymbol" params="" file="source/funkin/backend/assets/LimeLibrarySymbol.hx">
		<library public="1"><c path="lime.utils.AssetLibrary"/></library>
		<libraryName public="1"><c path="String"/></libraryName>
		<symbolName public="1"><c path="String"/></symbolName>
		<isLocal public="1" get="inline" set="null" line="21"><f a="?type">
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<exists public="1" get="inline" set="null" line="24"><f a="?type">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<new public="1" get="inline" set="null" line="13"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* COPIED DIRECTLY FROM LIME SOURCE CAUSE LIME IS SO FUCKING DUMB!!</haxe_doc>
	</class>
	<class path="funkin.backend.assets.ModsFolder" params="" file="source/funkin/backend/assets/ModsFolder.hx">
		<onModSwitch public="1" expr="new FlxTypedSignal&lt;String&gt;()" line="21" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta>
				<m n=":value"><e>new FlxTypedSignal&lt;String&gt;()</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>* INTERNAL - Only use when editing source mods!!</haxe_doc>
		</onModSwitch>
		<currentModFolder public="1" expr="null" line="26" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Current mod folder. Will affect `Paths`.</haxe_doc>
		</currentModFolder>
		<modsPath public="1" expr="&quot;./mods/&quot;" line="30" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"./mods/"</e></m></meta>
			<haxe_doc>* Path to the `mods` folder.</haxe_doc>
		</modsPath>
		<addonsPath public="1" expr="&quot;./addons/&quot;" line="34" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"./addons/"</e></m></meta>
			<haxe_doc>* Path to the `addons` folder.</haxe_doc>
		</addonsPath>
		<useLibFile public="1" expr="true" line="39" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If accessing a file as assets/data/global/LIB_mymod.hx should redirect to mymod:assets/data/global.hx</haxe_doc>
		</useLibFile>
		<__firstTime expr="true" line="44" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever its the first time mods has been reloaded.</haxe_doc>
		</__firstTime>
		<init public="1" set="method" line="49" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Initializes `mods` folder.</haxe_doc>
		</init>
		<switchMod public="1" set="method" line="61" static="1">
			<f a="mod">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Switches mod - unloads all the other mods, then load this one.
	 * @param libName</haxe_doc>
		</switchMod>
		<reloadMods public="1" set="method" line="73" static="1"><f a=""><x path="Void"/></f></reloadMods>
		<loadModLib public="1" set="method" line="84" static="1">
			<f a="path:?force:?modName" v=":false:">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="openfl.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
			<haxe_doc>* Loads a mod library from the specified path. Supports folders and zips.
	 * @param modName Name of the mod
	 * @param force Whenever the mod should be reloaded if it has already been loaded</haxe_doc>
		</loadModLib>
		<getModsList public="1" set="method" line="96" static="1"><f a=""><c path="Array"><c path="String"/></c></f></getModsList>
		<getLoadedModsLibs public="1" set="method" line="124" static="1">
			<f a="?skipTranslated" v="false">
				<x path="Bool"/>
				<c path="Array"><c path="funkin.backend.assets.IModsAssetLibrary"/></c>
			</f>
			<meta><m n=":value"><e>{ skipTranslated : false }</e></m></meta>
		</getLoadedModsLibs>
		<getLoadedMods public="1" set="method" line="136" static="1">
			<f a="?skipTranslated" v="false">
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ skipTranslated : false }</e></m></meta>
		</getLoadedMods>
		<prepareLibrary public="1" set="method" line="138" static="1">
			<f a="libName:?force" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</prepareLibrary>
		<registerFont public="1" set="method" line="148" static="1"><f a="font">
	<c path="lime.text.Font"/>
	<c path="lime.text.Font"/>
</f></registerFont>
		<prepareModLibrary public="1" set="method" line="156" static="1">
			<f a="libName:lib:?force:?tag" v="::false:">
				<c path="String"/>
				<c path="funkin.backend.assets.IModsAssetLibrary"/>
				<x path="Bool"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="openfl.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</prepareModLibrary>
		<loadLibraryFromFolder public="1" set="method" line="169" static="1">
			<f a="libName:folder:?force:?modName:?tag" v="::false::MODS">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="openfl.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ tag : MODS, force : false }</e></m></meta>
		</loadLibraryFromFolder>
		<loadLibraryFromZip public="1" set="method" line="173" static="1">
			<f a="libName:zipPath:?force:?modName:?tag" v="::false::MODS">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="openfl.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ tag : MODS, force : false }</e></m></meta>
		</loadLibraryFromZip>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.ModsFolderLibrary" params="" file="source/funkin/backend/assets/ModsFolderLibrary.hx">
		<extends path="openfl.utils.AssetLibrary"/>
		<implements path="funkin.backend.assets.IModsAssetLibrary"/>
		<basePath public="1"><c path="String"/></basePath>
		<modName public="1"><c path="String"/></modName>
		<libName public="1"><c path="String"/></libName>
		<prefix public="1" expr="&quot;assets/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"assets/"</e></m></meta>
		</prefix>
		<toString set="method" line="31"><f a=""><c path="String"/></f></toString>
		<editedTimes expr="[]">
			<t path="Map">
				<c path="String"/>
				<x path="Float"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</editedTimes>
		<_parsedAsset public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_parsedAsset>
		<getEditedTime public="1" set="method" line="39"><f a="asset">
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
</f></getEditedTime>
		<getAudioBuffer public="1" set="method" line="43" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="53" override="1"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="62" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="70" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="80" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<getFolders public="1" get="inline" set="null" line="86"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFolders>
		<getFiles public="1" get="inline" set="null" line="89"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFiles>
		<__getFiles public="1" set="method" line="91">
			<f a="folder:?folders" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ folders : false }</e></m></meta>
		</__getFiles>
		<exists public="1" set="method" line="107" override="1"><f a="asset:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAssetPath set="method" line="112"><f a=""><c path="String"/></f></getAssetPath>
		<__isCacheValid set="method" line="116">
			<f a="cache:asset:?isLocalCache" v="::false">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ isLocalCache : false }</e></m></meta>
		</__isCacheValid>
		<__parseAsset set="method" line="138"><f a="asset">
	<c path="String"/>
	<x path="Bool"/>
</f></__parseAsset>
		<folderPath public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</folderPath>
		<get_folderPath get="inline" set="null" line="157">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_folderPath>
		<set_folderPath get="inline" set="null" line="160">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_folderPath>
		<new public="1" set="method" line="23"><f a="basePath:libName:?modName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.MultiFramesCollection" params="" file="source/funkin/backend/assets/MultiFramesCollection.hx">
		<extends path="flixel.graphics.frames.FlxFramesCollection"/>
		<findFrame public="1" set="method" line="34" static="1">
			<f a="graphic:?border">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="flixel.math.FlxPoint"/>
				<c path="funkin.backend.assets.MultiFramesCollection"/>
			</f>
			<haxe_doc>* Returns the `FlxAtlasFrame` of the specified `FlxGraphic` object.
	 *
	 * @param   graphic   `FlxGraphic` object to find the `FlxAtlasFrames` collection for.
	 * @return  `FlxAtlasFrames` collection for the specified `FlxGraphic` object
	 *          Could be `null` if `FlxGraphic` doesn't have it yet.</haxe_doc>
		</findFrame>
		<parentedFrames public="1" expr="[]">
			<c path="Array"><c path="flixel.graphics.frames.FlxFramesCollection"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</parentedFrames>
		<addFrames public="1" set="method" line="47"><f a="collection">
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
	<x path="Void"/>
</f></addFrames>
		<destroy public="1" set="method" line="62" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="21"><f a="parent:?border">
	<c path="flixel.graphics.FlxGraphic"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Base class for all frame collections.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.Paths" params="" file="source/funkin/backend/assets/Paths.hx">
		<assetsTree public="1" static="1"><c path="funkin.backend.assets.AssetsLibraryList"/></assetsTree>
		<tempFramesCache public="1" expr="[]" line="18" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</tempFramesCache>
		<init public="1" set="method" line="20" static="1"><f a=""><x path="Void"/></f></init>
		<getPath public="1" get="inline" set="null" line="27" static="1"><f a="file:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<video public="1" get="inline" set="null" line="30" static="1"><f a="key:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></video>
		<ndll public="1" get="inline" set="null" line="33" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></ndll>
		<file public="1" get="inline" set="null" line="36" static="1"><f a="file:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></file>
		<txt public="1" get="inline" set="null" line="39" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></txt>
		<pack public="1" get="inline" set="null" line="42" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></pack>
		<ini public="1" get="inline" set="null" line="45" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></ini>
		<fragShader public="1" get="inline" set="null" line="48" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fragShader>
		<vertShader public="1" get="inline" set="null" line="51" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></vertShader>
		<xml public="1" get="inline" set="null" line="54" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></xml>
		<json public="1" get="inline" set="null" line="57" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></json>
		<ps1 public="1" get="inline" set="null" line="60" static="1"><f a="key:?library">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></ps1>
		<sound public="1" set="method" line="63" static="1"><f a="key:?library:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></sound>
		<soundRandom public="1" get="inline" set="null" line="66" static="1"><f a="key:min:max:?library">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></soundRandom>
		<music public="1" get="inline" set="null" line="69" static="1"><f a="key:?library:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></music>
		<voices public="1" get="inline" set="null" line="71" static="1">
			<f a="song:?difficulty:?prefix:?ext" v="::&quot;&quot;:">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prefix : "" }</e></m></meta>
		</voices>
		<inst public="1" get="inline" set="null" line="78" static="1">
			<f a="song:?difficulty:?prefix:?ext" v="::&quot;&quot;:">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prefix : "" }</e></m></meta>
		</inst>
		<image public="1" set="method" line="85" static="1">
			<f a="key:?library:?checkForAtlas:?ext" v="::false:">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ checkForAtlas : false }</e></m></meta>
		</image>
		<script public="1" get="inline" set="null" line="96" static="1">
			<f a="key:?library:?isAssetsPath" v="::false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ isAssetsPath : false }</e></m></meta>
		</script>
		<chart public="1" set="method" line="111" static="1"><f a="song:?difficulty">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></chart>
		<character public="1" set="method" line="117" static="1"><f a="character">
	<c path="String"/>
	<c path="String"/>
</f></character>
		<getFontName public="1" get="inline" set="null" line="125" static="1">
			<f a="font">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets the name of a registered font.
	 * @param font The font's path (if it's already passed as a font name, the same name will be returned)</haxe_doc>
		</getFontName>
		<font public="1" get="inline" set="null" line="129" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></font>
		<obj public="1" get="inline" set="null" line="133" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></obj>
		<dae public="1" get="inline" set="null" line="137" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></dae>
		<md2 public="1" get="inline" set="null" line="141" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></md2>
		<md5 public="1" get="inline" set="null" line="145" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></md5>
		<awd public="1" get="inline" set="null" line="149" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></awd>
		<getSparrowAtlas public="1" get="inline" set="null" line="154" static="1"><f a="key:?library:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getSparrowAtlas>
		<getSparrowAtlasAlt public="1" get="inline" set="null" line="157" static="1"><f a="key:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getSparrowAtlasAlt>
		<getPackerAtlas public="1" get="inline" set="null" line="160" static="1"><f a="key:?library:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getPackerAtlas>
		<getPackerAtlasAlt public="1" get="inline" set="null" line="163" static="1"><f a="key:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getPackerAtlasAlt>
		<getAsepriteAtlas public="1" get="inline" set="null" line="166" static="1"><f a="key:?library:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getAsepriteAtlas>
		<getAsepriteAtlasAlt public="1" get="inline" set="null" line="169" static="1"><f a="key:?ext">
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></getAsepriteAtlasAlt>
		<getAssetsRoot public="1" get="inline" set="null" line="172" static="1"><f a=""><c path="String"/></f></getAssetsRoot>
		<getFrames public="1" set="method" line="179" static="1">
			<f a="key:?assetsPath:?library:?ext" v=":false::null">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Null"><c path="flixel.graphics.frames.FlxFramesCollection"/></x>
			</f>
			<meta><m n=":value"><e>{ ext : null, assetsPath : false }</e></m></meta>
			<haxe_doc>* Gets frames at specified path.
	 * @param key Path to the frames
	 * @param library (Additional) library to load the frames from.</haxe_doc>
		</getFrames>
		<framesExists public="1" set="method" line="198" static="1">
			<f a="key:?checkAtlas:?checkMulti:?assetsPath:?library" v=":false:true:false:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ assetsPath : false, checkMulti : true, checkAtlas : false }</e></m></meta>
			<haxe_doc>* Checks if the images needed for using getFrames() exist.
	 * @param key Path to the image
	 * @param checkAtlas Whenever to check for the Animation.json file (used in FlxAnimate)
	 * @param assetsPath Whenever to use the raw path or to pass it through Paths.image()
	 * @param library (Additional) library to load the frames from.
	 * @return True if the images exist, false otherwise.</haxe_doc>
		</framesExists>
		<loadFrames set="method" line="224" static="1">
			<f a="path:?Unique:?Key:?SkipAtlasCheck:?SkipMultiCheck:?Ext" v=":false:null:false:false:null">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
			</f>
			<meta><m n=":value"><e>{ Ext : null, SkipMultiCheck : false, SkipAtlasCheck : false, Key : null, Unique : false }</e></m></meta>
			<haxe_doc>* Loads frames from a specific image path. Supports Sparrow Atlases, Packer Atlases, and multiple spritesheets.
	 * @param path Path to the image
	 * @param Unique Whenever the image should be unique in the cache
	 * @param Key Key to the image in the cache
	 * @param SkipAtlasCheck Whenever the atlas check should be skipped.
	 * @param SkipMultiCheck Whenever the multi spritesheet check should be skipped.
	 * @param Ext Extension of the image.
	 * @return FlxFramesCollection Frames</haxe_doc>
		</loadFrames>
		<getFolderDirectories public="1" set="method" line="259" static="1">
			<f a="key:?addPath:?source" v=":false:BOTH">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ source : BOTH, addPath : false }</e></m></meta>
		</getFolderDirectories>
		<getFolderContent public="1" set="method" line="268" static="1">
			<f a="key:?addPath:?source:?noExtension" v=":false:BOTH:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ noExtension : false, source : BOTH, addPath : false }</e></m></meta>
		</getFolderContent>
		<getFilenameFromLibFile public="1" set="method" line="280" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getFilenameFromLibFile>
		<getLibFromLibFile public="1" set="method" line="288" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</getLibFromLibFile>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.ScriptPathInfo" params="" file="source/funkin/backend/assets/Paths.hx" module="funkin.backend.assets.Paths">
		<file public="1"><c path="String"/></file>
		<library public="1"><c path="lime.utils.AssetLibrary"/></library>
		<new public="1" set="method" line="301"><f a="file:library">
	<c path="String"/>
	<c path="lime.utils.AssetLibrary"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.backend.assets.ScriptedAssetLibrary" params="" file="source/funkin/backend/assets/ScriptedAssetLibrary.hx">
		<extends path="funkin.backend.assets.ModsFolderLibrary"/>
		<nullValue expr="{ }" line="21" static="1">
			<d/>
			<meta><m n=":value"><e>{ }</e></m></meta>
		</nullValue>
		<script public="1"><c path="funkin.backend.scripting.Script"/></script>
		<scriptName public="1"><c path="String"/></scriptName>
		<toString set="method" line="35" override="1"><f a=""><c path="String"/></f></toString>
		<getEditedTime public="1" set="method" line="40" override="1"><f a="asset">
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
</f></getEditedTime>
		<getAudioBuffer public="1" set="method" line="48" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="56" override="1"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="64" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="72" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="80" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<__getFiles public="1" set="method" line="88" override="1">
			<f a="folder:?folders" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Null"><x path="Null"><c path="Array"><c path="String"/></c></x></x>
			</f>
			<meta><m n=":value"><e>{ folders : false }</e></m></meta>
		</__getFiles>
		<exists public="1" set="method" line="96" override="1"><f a="asset:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAssetPath set="method" line="104" override="1"><f a=""><x path="Null"><x path="Null"><c path="String"/></x></x></f></getAssetPath>
		<list public="1" set="method" line="112" override="1"><f a="type">
	<c path="String"/>
	<x path="Null"><x path="Null"><c path="Array"><c path="String"/></c></x></x>
</f></list>
		<__isCacheValid set="method" line="120" override="1">
			<f a="cache:asset:?isLocalCache" v="::false">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ isLocalCache : false }</e></m></meta>
		</__isCacheValid>
		<__parseAsset set="method" line="128" override="1"><f a="asset">
	<c path="String"/>
	<x path="Bool"/>
</f></__parseAsset>
		<new public="1" set="method" line="23">
			<f a="scriptName:?args:?basePath:?libName:?modName" v=":null:&quot;./assets/&quot;:&quot;assets&quot;:">
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ libName : "assets", basePath : "./assets/", args : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.TranslatedAssetLibrary" params="" file="source/funkin/backend/assets/TranslatedAssetLibrary.hx">
		<extends path="openfl.utils.AssetLibrary"/>
		<implements path="funkin.backend.assets.IModsAssetLibrary"/>
		<libName public="1"><c path="String"/></libName>
		<modName public="1"><c path="String"/></modName>
		<basePath public="1"><c path="String"/></basePath>
		<prefix public="1" expr="TranslationUtil.LANG_FOLDER + &quot;/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>TranslationUtil.LANG_FOLDER + "/"</e></m></meta>
		</prefix>
		<forLibrary public="1"><c path="funkin.backend.assets.IModsAssetLibrary"/></forLibrary>
		<langFolder public="1" get="accessor" set="accessor"><c path="String"/></langFolder>
		<get_langFolder get="inline" set="null" line="19">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_langFolder>
		<set_langFolder get="inline" set="null" line="22">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_langFolder>
		<toString set="method" line="34"><f a=""><c path="String"/></f></toString>
		<getAssetPath get="inline" set="null" line="37"><f a=""><c path="String"/></f></getAssetPath>
		<formatPath public="1" get="inline" set="null" line="39"><f a="mainPath:?asset">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></formatPath>
		<getAudioBuffer public="1" set="method" line="45" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="57" override="1"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getText public="1" set="method" line="68" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getText>
		<getFont public="1" set="method" line="79" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="90" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="101" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<_parsedAsset public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_parsedAsset>
		<getFiles public="1" set="method" line="115"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFiles>
		<getFolders public="1" set="method" line="126"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFolders>
		<__isCacheValid set="method" line="137">
			<f a="cache:asset:?isLocal" v="::false">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ isLocal : false }</e></m></meta>
		</__isCacheValid>
		<__parseAsset set="method" line="156"><f a="asset">
	<c path="String"/>
	<x path="Bool"/>
</f></__parseAsset>
		<exists public="1" set="method" line="168" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<new public="1" set="method" line="27"><f a="lib:?langFolder">
	<c path="funkin.backend.assets.IModsAssetLibrary"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.assets.ZipFolderLibrary" params="" file="source/funkin/backend/assets/ZipFolderLibrary.hx">
		<extends path="openfl.utils.AssetLibrary"/>
		<implements path="funkin.backend.assets.IModsAssetLibrary"/>
		<basePath public="1"><c path="String"/></basePath>
		<modName public="1"><c path="String"/></modName>
		<libName public="1"><c path="String"/></libName>
		<useImageCache public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</useImageCache>
		<prefix public="1" expr="&quot;assets/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"assets/"</e></m></meta>
		</prefix>
		<zip public="1"><c path="funkin.backend.utils.SysZip"/></zip>
		<assets public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<t path="funkin.backend.utils.SysZipEntry"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</assets>
		<lowerCaseAssets public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<t path="funkin.backend.utils.SysZipEntry"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</lowerCaseAssets>
		<nameMap public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</nameMap>
		<toString set="method" line="43"><f a=""><c path="String"/></f></toString>
		<_parsedAsset public="1"><c path="String"/></_parsedAsset>
		<getAudioBuffer public="1" set="method" line="49" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="53" override="1"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="57" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="61" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="66" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<unzip public="1" get="inline" set="null" line="74"><f a="f">
	<t path="funkin.backend.utils.SysZipEntry"/>
	<x path="Null"><x path="Null"><c path="haxe.io.Bytes"/></x></x>
</f></unzip>
		<__parseAsset public="1" set="method" line="76"><f a="asset">
	<c path="String"/>
	<x path="Bool"/>
</f></__parseAsset>
		<__isCacheValid public="1" set="method" line="95">
			<f a="cache:asset:?isLocal" v="::false">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ isLocal : false }</e></m></meta>
		</__isCacheValid>
		<exists public="1" set="method" line="100" override="1"><f a="asset:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAssetPath set="method" line="106"><f a=""><c path="String"/></f></getAssetPath>
		<getFiles public="1" set="method" line="112"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFiles>
		<getFolders public="1" set="method" line="133"><f a="folder">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getFolders>
		<zipPath public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</zipPath>
		<get_zipPath get="inline" set="null" line="160">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_zipPath>
		<set_zipPath get="inline" set="null" line="163">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_zipPath>
		<new public="1" set="method" line="26"><f a="basePath:libName:?modName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.chart.ChartFormat" params="" file="source/funkin/backend/chart/Chart.hx" module="funkin.backend.chart.Chart">
		<this><x path="Int"/></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.chart._Chart.ChartFormat_Impl_" params="" file="source/funkin/backend/chart/Chart.hx" private="1" module="funkin.backend.chart.Chart" final="1">
	<CODENAME public="1" get="inline" set="null" expr="cast 0" line="16" static="1">
		<x path="funkin.backend.chart.ChartFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CODENAME>
	<LEGACY public="1" get="inline" set="null" expr="cast 1" line="17" static="1">
		<x path="funkin.backend.chart.ChartFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEGACY>
	<VSLICE public="1" get="inline" set="null" expr="cast 2" line="18" static="1">
		<x path="funkin.backend.chart.ChartFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VSLICE>
	<PSYCH_NEW public="1" get="inline" set="null" expr="cast 3" line="19" static="1">
		<x path="funkin.backend.chart.ChartFormat"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</PSYCH_NEW>
	<toString public="1" set="method" line="21" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":to"/></meta>
	</toString>
	<fromString public="1" set="method" line="30" static="1">
		<f a="str:?def" v=":ChartFormat.LEGACY">
			<c path="String"/>
			<x path="funkin.backend.chart.ChartFormat"/>
			<x path="funkin.backend.chart.ChartFormat"/>
		</f>
		<meta><m n=":value"><e>{ def : ChartFormat.LEGACY }</e></m></meta>
	</fromString>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.chart._Chart.ChartFormat_Impl_" params="" file="source/funkin/backend/chart/Chart.hx" private="1" module="funkin.backend.chart.Chart" final="1">
		<CODENAME public="1" get="inline" set="null" expr="cast 0" line="16" static="1">
			<x path="funkin.backend.chart.ChartFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CODENAME>
		<LEGACY public="1" get="inline" set="null" expr="cast 1" line="17" static="1">
			<x path="funkin.backend.chart.ChartFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEGACY>
		<VSLICE public="1" get="inline" set="null" expr="cast 2" line="18" static="1">
			<x path="funkin.backend.chart.ChartFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VSLICE>
		<PSYCH_NEW public="1" get="inline" set="null" expr="cast 3" line="19" static="1">
			<x path="funkin.backend.chart.ChartFormat"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</PSYCH_NEW>
		<toString public="1" set="method" line="21" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":to"/></meta>
		</toString>
		<fromString public="1" set="method" line="30" static="1">
			<f a="str:?def" v=":ChartFormat.LEGACY">
				<c path="String"/>
				<x path="funkin.backend.chart.ChartFormat"/>
				<x path="funkin.backend.chart.ChartFormat"/>
			</f>
			<meta><m n=":value"><e>{ def : ChartFormat.LEGACY }</e></m></meta>
		</fromString>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.chart.Chart" params="" file="source/funkin/backend/chart/Chart.hx">
		<version final="1" public="1" set="null" expr="&quot;1.6.0&quot;" line="48" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"1.6.0"</e></m></meta>
		</version>
		<cleanSongData public="1" set="method" line="50" static="1"><f a="data">
	<d/>
	<d/>
</f></cleanSongData>
		<detectChartFormat public="1" set="method" line="59" static="1"><f a="data">
	<d/>
	<x path="funkin.backend.chart.ChartFormat"/>
</f></detectChartFormat>
		<loadEventsJson public="1" set="method" line="74" static="1"><f a="songName">
	<c path="String"/>
	<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
</f></loadEventsJson>
		<loadChartMeta public="1" set="method" line="86" static="1">
			<f a="songName:?difficulty:?fromMods" v="::true">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<t path="funkin.backend.chart.ChartMetaData"/>
			</f>
			<meta><m n=":value"><e>{ fromMods : true }</e></m></meta>
		</loadChartMeta>
		<parse public="1" set="method" line="138" static="1"><f a="songName:?difficulty">
	<c path="String"/>
	<c path="String"/>
	<t path="funkin.backend.chart.ChartData"/>
</f></parse>
		<addNoteType public="1" set="method" line="226" static="1">
			<f a="chart:noteTypeName">
				<t path="funkin.backend.chart.ChartData"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Set defaults on strum lines</haxe_doc>
		</addNoteType>
		<save public="1" set="method" line="246" static="1">
			<f a="songFolderPath:chart:?difficulty:?saveSettings">
				<c path="String"/>
				<t path="funkin.backend.chart.ChartData"/>
				<c path="String"/>
				<x path="Null"><t path="funkin.backend.chart.ChartSaveSettings"/></x>
				<t path="funkin.backend.chart.ChartData"/>
			</f>
			<haxe_doc>* Saves the chart to the specific song folder path.
	 * @param songFolderPath Path to the song folder (ex: `mods/your mod/songs/song/`)
	 * @param chart Chart to save
	 * @param difficulty Name of the difficulty
	 * @param saveSettings
	 * @return Filtered chart used for saving.</haxe_doc>
		</save>
		<filterChartForSaving public="1" set="method" line="274" static="1"><f a="chart:?saveMetaInChart:?saveLocalEvents:?saveGlobalEvents">
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<t path="funkin.backend.chart.ChartData"/>
</f></filterChartForSaving>
		<makeMetaSaveable public="1" get="inline" set="null" line="306" static="1">
			<f a="meta:?prettyPrint" v=":true">
				<t path="funkin.backend.chart.ChartMetaData"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ prettyPrint : true }</e></m></meta>
		</makeMetaSaveable>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.chart.ChartSaveSettings" params="" file="source/funkin/backend/chart/Chart.hx" module="funkin.backend.chart.Chart"><a>
	<saveMetaInChart>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</saveMetaInChart>
	<saveLocalEvents>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</saveLocalEvents>
	<saveGlobalEvents>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</saveGlobalEvents>
	<prettyPrint>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</prettyPrint>
	<overrideExistingMeta>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</overrideExistingMeta>
	<folder>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</folder>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartData" params="" file="source/funkin/backend/chart/ChartData.hx"><a>
	<strumLines><c path="Array"><t path="funkin.backend.chart.ChartStrumLine"/></c></strumLines>
	<stage><c path="String"/></stage>
	<scrollSpeed><x path="Float"/></scrollSpeed>
	<noteTypes><c path="Array"><c path="String"/></c></noteTypes>
	<meta><t path="funkin.backend.chart.ChartMetaData"/></meta>
	<fromMods>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</fromMods>
	<events><c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c></events>
	<codenameChart><x path="Bool"/></codenameChart>
	<chartVersion>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</chartVersion>
	<bookmarks>
		<x path="Null"><c path="Array"><t path="funkin.backend.chart.ChartBookmark"/></c></x>
		<meta><m n=":optional"/></meta>
	</bookmarks>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartMetaData" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData"><a>
	<stepsPerBeat>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</stepsPerBeat>
	<opponentModeAllowed>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</opponentModeAllowed>
	<needsVoices>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</needsVoices>
	<name><c path="String"/></name>
	<icon>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</icon>
	<displayName>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</displayName>
	<difficulties>
		<x path="Null"><c path="Array"><c path="String"/></c></x>
		<meta><m n=":optional"/></meta>
	</difficulties>
	<customValues>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</customValues>
	<coopAllowed>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</coopAllowed>
	<color>
		<x path="Null"><x path="flixel.util.FlxColor"/></x>
		<meta><m n=":optional"/></meta>
	</color>
	<bpm>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</bpm>
	<beatsPerMeasure>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</beatsPerMeasure>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartStrumLine" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData"><a>
	<vocalsSuffix>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</vocalsSuffix>
	<visible>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</visible>
	<type><x path="funkin.backend.chart.ChartStrumLineType"/></type>
	<strumSpacing>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</strumSpacing>
	<strumScale>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</strumScale>
	<strumPos>
		<x path="Null"><c path="Array"><x path="Float"/></c></x>
		<meta><m n=":optional"/></meta>
	</strumPos>
	<strumLinePos>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</strumLinePos>
	<scrollSpeed>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</scrollSpeed>
	<position><c path="String"/></position>
	<notes><c path="Array"><t path="funkin.backend.chart.ChartNote"/></c></notes>
	<keyCount>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</keyCount>
	<characters><c path="Array"><c path="String"/></c></characters>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartNote" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData"><a>
	<type><x path="Int"/></type>
	<time><x path="Float"/></time>
	<sLen><x path="Float"/></sLen>
	<id><x path="Int"/></id>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartBookmark" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData"><a>
	<time><x path="Float"/></time>
	<name><c path="String"/></name>
	<color><c path="String"/></color>
</a></typedef>
	<typedef path="funkin.backend.chart.ChartEvent" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData"><a>
	<time><x path="Float"/></time>
	<params><c path="Array"><d/></c></params>
	<name><c path="String"/></name>
	<global>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</global>
</a></typedef>
	<abstract path="funkin.backend.chart.ChartStrumLineType" params="" file="source/funkin/backend/chart/ChartData.hx" module="funkin.backend.chart.ChartData">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.chart._ChartData.ChartStrumLineType_Impl_" params="" file="source/funkin/backend/chart/ChartData.hx" private="1" module="funkin.backend.chart.ChartData" extern="1" final="1">
	<OPPONENT public="1" get="inline" set="null" expr="cast 0" line="74" static="1">
		<x path="funkin.backend.chart.ChartStrumLineType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* STRUMLINE IS MARKED AS OPPONENT - WILL BE PLAYED BY CPU, OR PLAYED BY PLAYER IF OPPONENT MODE IS ON</haxe_doc>
	</OPPONENT>
	<PLAYER public="1" get="inline" set="null" expr="cast 1" line="78" static="1">
		<x path="funkin.backend.chart.ChartStrumLineType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* STRUMLINE IS MARKED AS PLAYER - WILL BE PLAYED AS PLAYER, OR PLAYED AS CPU IF OPPONENT MODE IS ON</haxe_doc>
	</PLAYER>
	<ADDITIONAL public="1" get="inline" set="null" expr="cast 2" line="82" static="1">
		<x path="funkin.backend.chart.ChartStrumLineType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* STRUMLINE IS MARKED AS ADDITIONAL - WILL BE PLAYED AS CPU EVEN IF OPPONENT MODE IS ENABLED</haxe_doc>
	</ADDITIONAL>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.chart._ChartData.ChartStrumLineType_Impl_" params="" file="source/funkin/backend/chart/ChartData.hx" private="1" module="funkin.backend.chart.ChartData" extern="1" final="1">
		<OPPONENT public="1" get="inline" set="null" expr="cast 0" line="74" static="1">
			<x path="funkin.backend.chart.ChartStrumLineType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* STRUMLINE IS MARKED AS OPPONENT - WILL BE PLAYED BY CPU, OR PLAYED BY PLAYER IF OPPONENT MODE IS ON</haxe_doc>
		</OPPONENT>
		<PLAYER public="1" get="inline" set="null" expr="cast 1" line="78" static="1">
			<x path="funkin.backend.chart.ChartStrumLineType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* STRUMLINE IS MARKED AS PLAYER - WILL BE PLAYED AS PLAYER, OR PLAYED AS CPU IF OPPONENT MODE IS ON</haxe_doc>
		</PLAYER>
		<ADDITIONAL public="1" get="inline" set="null" expr="cast 2" line="82" static="1">
			<x path="funkin.backend.chart.ChartStrumLineType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* STRUMLINE IS MARKED AS ADDITIONAL - WILL BE PLAYED AS CPU EVEN IF OPPONENT MODE IS ENABLED</haxe_doc>
		</ADDITIONAL>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="funkin.backend.chart.EventParamType" params="" file="source/funkin/backend/chart/EventsData.hx" module="funkin.backend.chart.EventsData">
		<TBool/>
		<TInt a="?min:?max:?step">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Float"/>
		</TInt>
		<TFloat a="?min:?max:?step:?precision">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Int"/>
		</TFloat>
		<TString/>
		<TStrumLine/>
		<TColorWheel/>
		<TDropDown a="?options"><c path="Array"><c path="String"/></c></TDropDown>
		<TCharacter/>
		<TStage/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="funkin.backend.chart.EventsData" params="" file="source/funkin/backend/chart/EventsData.hx">
		<defaultEventsList public="1" expr="[&quot;HScript Call&quot;, &quot;Camera Movement&quot;, &quot;Camera Position&quot;, &quot;Add Camera Zoom&quot;, &quot;Camera Zoom&quot;, &quot;Camera Modulo Change&quot;, &quot;Camera Flash&quot;, &quot;BPM Change&quot;, &quot;Continuous BPM Change&quot;, &quot;Time Signature Change&quot;, &quot;Scroll Speed Change&quot;, &quot;Alt Animation Toggle&quot;, &quot;Play Animation&quot;]" line="13" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["HScript Call", "Camera Movement", "Camera Position", "Add Camera Zoom", "Camera Zoom", "Camera Modulo Change", "Camera Flash", "BPM Change", "Continuous BPM Change", "Time Signature Change", "Scroll Speed Change", "Alt Animation Toggle", "Play Animation"]</e></m></meta>
		</defaultEventsList>
		<defaultEventsParams public="1" expr="[&quot;HScript Call&quot; =&gt; [{ name : &quot;Function Name&quot;, type : TString, defValue : &quot;myFunc&quot; }, { name : &quot;Function Parameters (String split with commas)&quot;, type : TString, defValue : &quot;&quot; }], &quot;Camera Movement&quot; =&gt; [{ name : &quot;Camera Target&quot;, type : TStrumLine, defValue : 0 }, { name : &quot;Tween Movement?&quot;, type : TBool, defValue : true, saveIfDefault : false }, { name : &quot;Tween Time (Steps, IF NOT CLASSIC)&quot;, type : TFloat(0.25, 9999, 0.25, 2), defValue : 4, saveIfDefault : false }, { name : &quot;Tween Ease (ex: circ, quad, cube)&quot;, type : TDropDown([&quot;CLASSIC&quot;, &quot;linear&quot;, &quot;back&quot;, &quot;bounce&quot;, &quot;circ&quot;, &quot;cube&quot;, &quot;elastic&quot;, &quot;expo&quot;, &quot;quad&quot;, &quot;quart&quot;, &quot;quint&quot;, &quot;sine&quot;, &quot;smoothStep&quot;, &quot;smootherStep&quot;]), defValue : &quot;CLASSIC&quot;, saveIfDefault : false }, { name : &quot;Tween Type (excluded if CLASSIC or linear, ex: InOut)&quot;, type : TDropDown([&quot;In&quot;, &quot;Out&quot;, &quot;InOut&quot;]), defValue : &quot;In&quot;, saveIfDefault : false }], &quot;Camera Position&quot; =&gt; [{ name : &quot;X&quot;, type : TFloat(null, null, 10, 3), defValue : 0 }, { name : &quot;Y&quot;, type : TFloat(null, null, 10, 3), defValue : 0 }, { name : &quot;Tween Movement?&quot;, type : TBool, defValue : true, saveIfDefault : false }, { name : &quot;Tween Time (Steps, IF NOT CLASSIC)&quot;, type : TFloat(0.25, 9999, 0.25, 2), defValue : 4, saveIfDefault : false }, { name : &quot;Tween Ease (ex: circ, quad, cube)&quot;, type : TDropDown([&quot;CLASSIC&quot;, &quot;linear&quot;, &quot;back&quot;, &quot;bounce&quot;, &quot;circ&quot;, &quot;cube&quot;, &quot;elastic&quot;, &quot;expo&quot;, &quot;quad&quot;, &quot;quart&quot;, &quot;quint&quot;, &quot;sine&quot;, &quot;smoothStep&quot;, &quot;smootherStep&quot;]), defValue : &quot;CLASSIC&quot;, saveIfDefault : false }, { name : &quot;Tween Type (excluded if CLASSIC or linear, ex: InOut)&quot;, type : TDropDown([&quot;In&quot;, &quot;Out&quot;, &quot;InOut&quot;]), defValue : &quot;In&quot;, saveIfDefault : false }, { name : &quot;Is Offset?&quot;, type : TBool, defValue : false, saveIfDefault : false }], &quot;Add Camera Zoom&quot; =&gt; [{ name : &quot;Amount&quot;, type : TFloat(-10, 10, 0.01, 2), defValue : 0.05 }, { name : &quot;Camera&quot;, type : TDropDown([&quot;camGame&quot;, &quot;camHUD&quot;]), defValue : &quot;camGame&quot; }], &quot;Camera Zoom&quot; =&gt; [{ name : &quot;Tween Zoom?&quot;, type : TBool, defValue : true }, { name : &quot;New Zoom&quot;, type : TFloat(-10, 10, 0.01, 2), defValue : 1 }, { name : &quot;Camera&quot;, type : TDropDown([&quot;camGame&quot;, &quot;camHUD&quot;]), defValue : &quot;camGame&quot; }, { name : &quot;Tween Time (Steps)&quot;, type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }, { name : &quot;Tween Ease (ex: circ, quad, cube)&quot;, type : TDropDown([&quot;linear&quot;, &quot;back&quot;, &quot;bounce&quot;, &quot;circ&quot;, &quot;cube&quot;, &quot;elastic&quot;, &quot;expo&quot;, &quot;quad&quot;, &quot;quart&quot;, &quot;quint&quot;, &quot;sine&quot;, &quot;smoothStep&quot;, &quot;smootherStep&quot;]), defValue : &quot;linear&quot; }, { name : &quot;Tween Type (excluded if linear, ex: InOut)&quot;, type : TDropDown([&quot;In&quot;, &quot;Out&quot;, &quot;InOut&quot;]), defValue : &quot;In&quot; }, { name : &quot;Mode&quot;, type : TDropDown([&quot;direct&quot;, &quot;stage&quot;]), defValue : &quot;direct&quot; }, { name : &quot;Multiplicative?&quot;, type : TBool, defValue : true }], &quot;Camera Modulo Change&quot; =&gt; [{ name : &quot;Modulo Interval&quot;, type : TInt(1, 9999999, 1), defValue : 4 }, { name : &quot;Bump Strength&quot;, type : TFloat(0.1, 10, 0.01, 2), defValue : 1 }, { name : &quot;Every Beat Type&quot;, type : TDropDown([&quot;BEAT&quot;, &quot;MEASURE&quot;, &quot;STEP&quot;]), defValue : &quot;BEAT&quot; }, { name : &quot;Beat Offset&quot;, type : TFloat(-10, 10, 0.25, 2), defValue : 0 }], &quot;Camera Flash&quot; =&gt; [{ name : &quot;Reversed?&quot;, type : TBool, defValue : false }, { name : &quot;Color&quot;, type : TColorWheel, defValue : &quot;#FFFFFF&quot; }, { name : &quot;Time (Steps)&quot;, type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }, { name : &quot;Camera&quot;, type : TDropDown([&quot;camGame&quot;, &quot;camHUD&quot;]), defValue : &quot;camHUD&quot; }], &quot;BPM Change&quot; =&gt; [{ name : &quot;Target BPM&quot;, type : TFloat(1.00, 9999, 0.001, 3), defValue : 100 }], &quot;Continuous BPM Change&quot; =&gt; [{ name : &quot;Target BPM&quot;, type : TFloat(1.00, 9999, 0.001, 3), defValue : 100 }, { name : &quot;Time (steps)&quot;, type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }], &quot;Time Signature Change&quot; =&gt; [{ name : &quot;Target Numerator&quot;, type : TFloat(1), defValue : 4 }, { name : &quot;Target Denominator&quot;, type : TFloat(1), defValue : 4 }, { name : &quot;Denominator is Steps Per Beat&quot;, type : TBool, defValue : false }], &quot;Scroll Speed Change&quot; =&gt; [{ name : &quot;Tween Speed?&quot;, type : TBool, defValue : true }, { name : &quot;New Speed&quot;, type : TFloat(0.01, 99, 0.01, 2), defValue : 1. }, { name : &quot;Tween Time (Steps)&quot;, type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }, { name : &quot;Tween Ease (ex: circ, quad, cube)&quot;, type : TDropDown([&quot;linear&quot;, &quot;back&quot;, &quot;bounce&quot;, &quot;circ&quot;, &quot;cube&quot;, &quot;elastic&quot;, &quot;expo&quot;, &quot;quad&quot;, &quot;quart&quot;, &quot;quint&quot;, &quot;sine&quot;, &quot;smoothStep&quot;, &quot;smootherStep&quot;]), defValue : &quot;linear&quot; }, { name : &quot;Tween Type (excluded if linear, ex: InOut)&quot;, type : TDropDown([&quot;In&quot;, &quot;Out&quot;, &quot;InOut&quot;]), defValue : &quot;In&quot; }, { name : &quot;Multiplicative?&quot;, type : TBool, defValue : false }], &quot;Alt Animation Toggle&quot; =&gt; [{ name : &quot;Enable On Sing Poses&quot;, type : TBool, defValue : true }, { name : &quot;Enable On Idle&quot;, type : TBool, defValue : true }, { name : &quot;Strumline&quot;, type : TStrumLine, defValue : 0 }], &quot;Play Animation&quot; =&gt; [{ name : &quot;Character&quot;, type : TStrumLine, defValue : 0 }, { name : &quot;Animation&quot;, type : TString, defValue : &quot;animation&quot; }, { name : &quot;Is forced?&quot;, type : TBool, defValue : true }, { name : &quot;Animation Context&quot;, type : TDropDown([&quot;NONE&quot;, &quot;SING&quot;, &quot;DANCE&quot;, &quot;MISS&quot;, &quot;LOCK&quot;]), defValue : &quot;NONE&quot; }]]" line="14" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><t path="funkin.backend.chart.EventParamInfo"/></c>
			</t>
			<meta><m n=":value"><e>["HScript Call" =&gt; [{ name : "Function Name", type : TString, defValue : "myFunc" }, { name : "Function Parameters (String split with commas)", type : TString, defValue : "" }], "Camera Movement" =&gt; [{ name : "Camera Target", type : TStrumLine, defValue : 0 }, { name : "Tween Movement?", type : TBool, defValue : true, saveIfDefault : false }, { name : "Tween Time (Steps, IF NOT CLASSIC)", type : TFloat(0.25, 9999, 0.25, 2), defValue : 4, saveIfDefault : false }, { name : "Tween Ease (ex: circ, quad, cube)", type : TDropDown(["CLASSIC", "linear", "back", "bounce", "circ", "cube", "elastic", "expo", "quad", "quart", "quint", "sine", "smoothStep", "smootherStep"]), defValue : "CLASSIC", saveIfDefault : false }, { name : "Tween Type (excluded if CLASSIC or linear, ex: InOut)", type : TDropDown(["In", "Out", "InOut"]), defValue : "In", saveIfDefault : false }], "Camera Position" =&gt; [{ name : "X", type : TFloat(null, null, 10, 3), defValue : 0 }, { name : "Y", type : TFloat(null, null, 10, 3), defValue : 0 }, { name : "Tween Movement?", type : TBool, defValue : true, saveIfDefault : false }, { name : "Tween Time (Steps, IF NOT CLASSIC)", type : TFloat(0.25, 9999, 0.25, 2), defValue : 4, saveIfDefault : false }, { name : "Tween Ease (ex: circ, quad, cube)", type : TDropDown(["CLASSIC", "linear", "back", "bounce", "circ", "cube", "elastic", "expo", "quad", "quart", "quint", "sine", "smoothStep", "smootherStep"]), defValue : "CLASSIC", saveIfDefault : false }, { name : "Tween Type (excluded if CLASSIC or linear, ex: InOut)", type : TDropDown(["In", "Out", "InOut"]), defValue : "In", saveIfDefault : false }, { name : "Is Offset?", type : TBool, defValue : false, saveIfDefault : false }], "Add Camera Zoom" =&gt; [{ name : "Amount", type : TFloat(-10, 10, 0.01, 2), defValue : 0.05 }, { name : "Camera", type : TDropDown(["camGame", "camHUD"]), defValue : "camGame" }], "Camera Zoom" =&gt; [{ name : "Tween Zoom?", type : TBool, defValue : true }, { name : "New Zoom", type : TFloat(-10, 10, 0.01, 2), defValue : 1 }, { name : "Camera", type : TDropDown(["camGame", "camHUD"]), defValue : "camGame" }, { name : "Tween Time (Steps)", type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }, { name : "Tween Ease (ex: circ, quad, cube)", type : TDropDown(["linear", "back", "bounce", "circ", "cube", "elastic", "expo", "quad", "quart", "quint", "sine", "smoothStep", "smootherStep"]), defValue : "linear" }, { name : "Tween Type (excluded if linear, ex: InOut)", type : TDropDown(["In", "Out", "InOut"]), defValue : "In" }, { name : "Mode", type : TDropDown(["direct", "stage"]), defValue : "direct" }, { name : "Multiplicative?", type : TBool, defValue : true }], "Camera Modulo Change" =&gt; [{ name : "Modulo Interval", type : TInt(1, 9999999, 1), defValue : 4 }, { name : "Bump Strength", type : TFloat(0.1, 10, 0.01, 2), defValue : 1 }, { name : "Every Beat Type", type : TDropDown(["BEAT", "MEASURE", "STEP"]), defValue : "BEAT" }, { name : "Beat Offset", type : TFloat(-10, 10, 0.25, 2), defValue : 0 }], "Camera Flash" =&gt; [{ name : "Reversed?", type : TBool, defValue : false }, { name : "Color", type : TColorWheel, defValue : "#FFFFFF" }, { name : "Time (Steps)", type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }, { name : "Camera", type : TDropDown(["camGame", "camHUD"]), defValue : "camHUD" }], "BPM Change" =&gt; [{ name : "Target BPM", type : TFloat(1.00, 9999, 0.001, 3), defValue : 100 }], "Continuous BPM Change" =&gt; [{ name : "Target BPM", type : TFloat(1.00, 9999, 0.001, 3), defValue : 100 }, { name : "Time (steps)", type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }], "Time Signature Change" =&gt; [{ name : "Target Numerator", type : TFloat(1), defValue : 4 }, { name : "Target Denominator", type : TFloat(1), defValue : 4 }, { name : "Denominator is Steps Per Beat", type : TBool, defValue : false }], "Scroll Speed Change" =&gt; [{ name : "Tween Speed?", type : TBool, defValue : true }, { name : "New Speed", type : TFloat(0.01, 99, 0.01, 2), defValue : 1. }, { name : "Tween Time (Steps)", type : TFloat(0.25, 9999, 0.25, 2), defValue : 4 }, { name : "Tween Ease (ex: circ, quad, cube)", type : TDropDown(["linear", "back", "bounce", "circ", "cube", "elastic", "expo", "quad", "quart", "quint", "sine", "smoothStep", "smootherStep"]), defValue : "linear" }, { name : "Tween Type (excluded if linear, ex: InOut)", type : TDropDown(["In", "Out", "InOut"]), defValue : "In" }, { name : "Multiplicative?", type : TBool, defValue : false }], "Alt Animation Toggle" =&gt; [{ name : "Enable On Sing Poses", type : TBool, defValue : true }, { name : "Enable On Idle", type : TBool, defValue : true }, { name : "Strumline", type : TStrumLine, defValue : 0 }], "Play Animation" =&gt; [{ name : "Character", type : TStrumLine, defValue : 0 }, { name : "Animation", type : TString, defValue : "animation" }, { name : "Is forced?", type : TBool, defValue : true }, { name : "Animation Context", type : TDropDown(["NONE", "SING", "DANCE", "MISS", "LOCK"]), defValue : "NONE" }]]</e></m></meta>
		</defaultEventsParams>
		<eventsList public="1" expr="defaultEventsList.copy()" line="121" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>defaultEventsList.copy()</e></m></meta>
		</eventsList>
		<eventsParams public="1" expr="defaultEventsParams.copy()" line="122" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><t path="funkin.backend.chart.EventParamInfo"/></c>
			</t>
			<meta><m n=":value"><e>defaultEventsParams.copy()</e></m></meta>
		</eventsParams>
		<getEventParams public="1" set="method" line="124" static="1"><f a="name">
	<c path="String"/>
	<c path="Array"><t path="funkin.backend.chart.EventParamInfo"/></c>
</f></getEventParams>
		<reloadEvents public="1" set="method" line="128" static="1"><f a=""><x path="Void"/></f></reloadEvents>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.chart.EventInfoFile" params="" file="source/funkin/backend/chart/EventsData.hx" module="funkin.backend.chart.EventsData"><a><params><c path="Array"><a>
	<type><c path="String"/></type>
	<name><c path="String"/></name>
	<defaultValue><d/></defaultValue>
</a></c></params></a></typedef>
	<typedef path="funkin.backend.chart.EventInfo" params="" file="source/funkin/backend/chart/EventsData.hx" module="funkin.backend.chart.EventsData"><a><params><c path="Array"><t path="funkin.backend.chart.EventParamInfo"/></c></params></a></typedef>
	<typedef path="funkin.backend.chart.EventParamInfo" params="" file="source/funkin/backend/chart/EventsData.hx" module="funkin.backend.chart.EventsData"><a>
	<type><e path="funkin.backend.chart.EventParamType"/></type>
	<saveIfDefault>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</saveIfDefault>
	<name><c path="String"/></name>
	<defValue><d/></defValue>
</a></typedef>
	<class path="funkin.backend.chart.FNFLegacyParser" params="" file="source/funkin/backend/chart/FNFLegacyParser.hx">
		<parse public="1" set="method" line="11" static="1"><f a="data:result">
	<d/>
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></parse>
		<encode public="1" set="method" line="128" static="1"><f a="chart">
	<t path="funkin.backend.chart.ChartData"/>
	<d/>
</f></encode>
		<__convertToSwagSong public="1" set="method" line="154" static="1">
			<f a="chart">
				<t path="funkin.backend.chart.ChartData"/>
				<t path="funkin.backend.chart.SwagSong"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__convertToSwagSong>
		<__convertToSwagSections public="1" set="method" line="179" static="1">
			<f a="chart">
				<t path="funkin.backend.chart.ChartData"/>
				<c path="Array"><t path="funkin.backend.chart.SwagSection"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__convertToSwagSections>
		<haxe_doc>* Legacy FNF chart parser.
 * This is for charts that that were made before v0.5.0.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.chart.SwagSong" params="" file="source/funkin/backend/chart/FNFLegacyParser.hx" module="funkin.backend.chart.FNFLegacyParser"><a>
	<validScore><x path="Bool"/></validScore>
	<stepsPerBeat>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</stepsPerBeat>
	<stage>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</stage>
	<speed><x path="Float"/></speed>
	<song><c path="String"/></song>
	<player3>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</player3>
	<player2><c path="String"/></player2>
	<player1><c path="String"/></player1>
	<notes><c path="Array"><t path="funkin.backend.chart.SwagSection"/></c></notes>
	<noteTypes>
		<x path="Null"><c path="Array"><c path="String"/></c></x>
		<meta><m n=":optional"/></meta>
	</noteTypes>
	<needsVoices>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</needsVoices>
	<maxHealth>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</maxHealth>
	<gfVersion>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</gfVersion>
	<gf>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</gf>
	<events>
		<x path="Null"><c path="Array"><d/></c></x>
		<meta><m n=":optional"/></meta>
	</events>
	<bpm><x path="Float"/></bpm>
	<beatsPerMeasure>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</beatsPerMeasure>
</a></typedef>
	<typedef path="funkin.backend.chart.SwagSection" params="" file="source/funkin/backend/chart/FNFLegacyParser.hx" module="funkin.backend.chart.FNFLegacyParser"><a>
	<typeOfSection>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</typeOfSection>
	<sectionNotes><c path="Array"><c path="Array"><d/></c></c></sectionNotes>
	<sectionBeats>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</sectionBeats>
	<mustHitSection><x path="Bool"/></mustHitSection>
	<lengthInSteps><x path="Int"/></lengthInSteps>
	<gfSection>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</gfSection>
	<changeBPM><x path="Bool"/></changeBPM>
	<camTarget>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</camTarget>
	<bpm><x path="Float"/></bpm>
	<altAnim><x path="Null"><x path="Bool"/></x></altAnim>
</a></typedef>
	<class path="funkin.backend.chart.PsychParser" params="" file="source/funkin/backend/chart/PsychParser.hx">
		<ignoreEvents public="1" expr="[&quot;Camera Movement&quot;, &quot;Alt Animation Toggle&quot;, &quot;BPM Change&quot;]" line="14" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["Camera Movement", "Alt Animation Toggle", "BPM Change"]</e></m></meta>
		</ignoreEvents>
		<standardize public="1" set="method" line="23" static="1">
			<f a="data:result">
				<d/>
				<t path="funkin.backend.chart.ChartData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Converts 1.0 Psych charts to older ones</haxe_doc>
		</standardize>
		<parse public="1" set="method" line="36" static="1"><f a="data:result">
	<d/>
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></parse>
		<encode public="1" set="method" line="41" static="1"><f a="chart">
	<t path="funkin.backend.chart.ChartData"/>
	<d/>
</f></encode>
		<haxe_doc>* Parser for Psych Charts.
 * Both for pre-v1.0.0 and v1.0.0 charts.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.chart.ChartDataWithInfo" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser"><a>
	<diffName><c path="String"/></diffName>
	<chart><t path="funkin.backend.chart.ChartData"/></chart>
</a></typedef>
	<class path="funkin.backend.chart.VSliceParser" params="" file="source/funkin/backend/chart/VSliceParser.hx">
		<parse public="1" set="method" line="12" static="1"><f a="metaData:chartData:resultMeta:resultCharts:?songID">
	<d/>
	<d/>
	<t path="funkin.backend.chart.ChartMetaData"/>
	<c path="Array"><t path="funkin.backend.chart.ChartDataWithInfo"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></parse>
		<parseChart public="1" set="method" line="34" static="1"><f a="data:metaData:events:result">
	<d/>
	<d/>
	<d/>
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></parseChart>
		<parseMeta public="1" set="method" line="174" static="1"><f a="data:result:?songID">
	<d/>
	<t path="funkin.backend.chart.ChartMetaData"/>
	<c path="String"/>
	<x path="Void"/>
</f></parseMeta>
		<encodeMeta public="1" set="method" line="198" static="1"><f a="meta:?chart">
	<t path="funkin.backend.chart.ChartMetaData"/>
	<x path="Null"><t path="funkin.backend.chart.ChartData"/></x>
	<t path="funkin.backend.chart.SwagMetadata"/>
</f></encodeMeta>
		<encodeChart public="1" set="method" line="256" static="1"><f a="chart">
	<t path="funkin.backend.chart.ChartData"/>
	<t path="funkin.backend.chart.NewSwagSong"/>
</f></encodeChart>
		<parseEase public="1" set="method" line="261" static="1"><f a="vsliceEase">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></parseEase>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.chart.SwagMetadata" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser"><a>
	<version><c path="String"/></version>
	<timeFormat>
		<x path="Null"><x path="funkin.backend.chart.SwagTimeFormat"/></x>
		<meta><m n=":optional"/></meta>
	</timeFormat>
	<timeChanges><c path="Array"><t path="funkin.backend.chart.SwagTimeChange"/></c></timeChanges>
	<songName><c path="String"/></songName>
	<playData><t path="funkin.backend.chart.SwagPlayData"/></playData>
	<offsets>
		<x path="Null"><t path="funkin.backend.chart.SwagSongOffsets"/></x>
		<meta><m n=":optional"/></meta>
	</offsets>
	<looped>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</looped>
	<generatedBy><c path="String"/></generatedBy>
	<divisions>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</divisions>
	<charter>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</charter>
	<artist><c path="String"/></artist>
</a></typedef>
	<abstract path="funkin.backend.chart.SwagTimeFormat" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.chart._VSliceParser.SwagTimeFormat_Impl_" params="" file="source/funkin/backend/chart/VSliceParser.hx" private="1" module="funkin.backend.chart.VSliceParser" extern="1" final="1">
	<TICKS public="1" get="inline" set="null" expr="cast &quot;ticks&quot;" line="285" static="1">
		<x path="funkin.backend.chart.SwagTimeFormat"/>
		<meta>
			<m n=":value"><e>cast "ticks"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TICKS>
	<FLOAT public="1" get="inline" set="null" expr="cast &quot;float&quot;" line="286" static="1">
		<x path="funkin.backend.chart.SwagTimeFormat"/>
		<meta>
			<m n=":value"><e>cast "float"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</FLOAT>
	<MILLISECONDS public="1" get="inline" set="null" expr="cast &quot;ms&quot;" line="287" static="1">
		<x path="funkin.backend.chart.SwagTimeFormat"/>
		<meta>
			<m n=":value"><e>cast "ms"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MILLISECONDS>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.chart._VSliceParser.SwagTimeFormat_Impl_" params="" file="source/funkin/backend/chart/VSliceParser.hx" private="1" module="funkin.backend.chart.VSliceParser" extern="1" final="1">
		<TICKS public="1" get="inline" set="null" expr="cast &quot;ticks&quot;" line="285" static="1">
			<x path="funkin.backend.chart.SwagTimeFormat"/>
			<meta>
				<m n=":value"><e>cast "ticks"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TICKS>
		<FLOAT public="1" get="inline" set="null" expr="cast &quot;float&quot;" line="286" static="1">
			<x path="funkin.backend.chart.SwagTimeFormat"/>
			<meta>
				<m n=":value"><e>cast "float"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</FLOAT>
		<MILLISECONDS public="1" get="inline" set="null" expr="cast &quot;ms&quot;" line="287" static="1">
			<x path="funkin.backend.chart.SwagTimeFormat"/>
			<meta>
				<m n=":value"><e>cast "ms"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MILLISECONDS>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="funkin.backend.chart.SwagTimeChange" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser"><a>
	<t><x path="Int"/></t>
	<n>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</n>
	<d>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</d>
	<bt>
		<x path="Null"><c path="Array"><x path="Int"/></c></x>
		<meta><m n=":optional"/></meta>
	</bt>
	<bpm><x path="Float"/></bpm>
	<b>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</b>
</a></typedef>
	<typedef path="funkin.backend.chart.SwagSongOffsets" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser"><a>
	<vocals>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</vocals>
	<instrumental>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</instrumental>
	<altVocals>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</altVocals>
	<altInstrumentals>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</altInstrumentals>
</a></typedef>
	<typedef path="funkin.backend.chart.SwagPlayData" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser"><a>
	<stage><c path="String"/></stage>
	<songVariations>
		<x path="Null"><c path="Array"><c path="String"/></c></x>
		<meta><m n=":optional"/></meta>
	</songVariations>
	<ratings>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</ratings>
	<previewStart>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</previewStart>
	<previewEnd>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</previewEnd>
	<noteStyle><c path="String"/></noteStyle>
	<difficulties><c path="Array"><c path="String"/></c></difficulties>
	<characters><t path="funkin.backend.chart.SwagCharactersList"/></characters>
	<album>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</album>
</a></typedef>
	<typedef path="funkin.backend.chart.SwagCharactersList" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser"><a>
	<playerVocals>
		<x path="Null"><c path="Array"><c path="String"/></c></x>
		<meta><m n=":optional"/></meta>
	</playerVocals>
	<player>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</player>
	<opponentVocals>
		<x path="Null"><c path="Array"><c path="String"/></c></x>
		<meta><m n=":optional"/></meta>
	</opponentVocals>
	<opponent>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</opponent>
	<instrumental>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</instrumental>
	<girlfriend>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</girlfriend>
	<altInstrumentals>
		<x path="Null"><c path="Array"><c path="String"/></c></x>
		<meta><m n=":optional"/></meta>
	</altInstrumentals>
</a></typedef>
	<typedef path="funkin.backend.chart.NewSwagSong" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser"><a>
	<version><c path="String"/></version>
	<scrollSpeed><d/></scrollSpeed>
	<notes><d/></notes>
	<generatedBy><c path="String"/></generatedBy>
	<events><c path="Array"><t path="funkin.backend.chart.SwagEvent"/></c></events>
</a></typedef>
	<typedef path="funkin.backend.chart.SwagEvent" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser"><a>
	<v>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</v>
	<t><x path="Float"/></t>
	<e><c path="String"/></e>
</a></typedef>
	<typedef path="funkin.backend.chart.SwagNote" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser"><a>
	<t><x path="Float"/></t>
	<p>
		<x path="Null"><c path="Array"><t path="funkin.backend.chart.SwagNoteParamsData"/></c></x>
		<meta><m n=":optional"/></meta>
	</p>
	<l>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</l>
	<k>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</k>
	<d><x path="Int"/></d>
</a></typedef>
	<typedef path="funkin.backend.chart.SwagNoteParamsData" params="" file="source/funkin/backend/chart/VSliceParser.hx" module="funkin.backend.chart.VSliceParser"><a>
	<v><d/></v>
	<n><c path="String"/></n>
</a></typedef>
	<class path="funkin.backend.scripting.Script" params="" file="source/funkin/backend/scripting/Script.hx">
		<extends path="flixel.FlxBasic"/>
		<implements path="flixel.util.IFlxDestroyable"/>
		<staticVariables public="1" expr="[]" line="18" static="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Use "static var thing = true;" in hscript to use those!!
	 * are reset every mod switch so once you're done with them make sure to make them null!!</haxe_doc>
		</staticVariables>
		<getDefaultVariables public="1" set="method" line="23" static="1">
			<f a="?script">
				<c path="funkin.backend.scripting.Script"/>
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
			</f>
			<haxe_doc>* Gets the default variables for a script.</haxe_doc>
		</getDefaultVariables>
		<getDefaultImportRedirects public="1" set="method" line="114" static="1">
			<f a=""><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></f>
			<haxe_doc>* Used internally to keep backwards compatibility with old scripts.
	 * This gets set on `hscript.Interp.importRedirects`,
	 * if you wanna modify it, please edit `hscript.Interp.importRedirects` directly.</haxe_doc>
		</getDefaultImportRedirects>
		<getDefaultPreprocessors public="1" set="method" line="159" static="1">
			<f a=""><t path="Map">
	<c path="String"/>
	<d/>
</t></f>
			<haxe_doc>* Gets the default defines for a script.
	 * Includes all of the defines that the build was compiled with.</haxe_doc>
		</getDefaultPreprocessors>
		<scriptExtensions public="1" expr="[&quot;hx&quot;, &quot;hscript&quot;, &quot;hsc&quot;, &quot;hxs&quot;, &quot;pack&quot;, &quot;lua&quot;]" line="170" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["hx", "hscript", "hsc", "hxs", "pack", "lua"]</e></m></meta>
			<haxe_doc>* All available script extensions</haxe_doc>
		</scriptExtensions>
		<curScript public="1" expr="null" line="179" static="1">
			<c path="funkin.backend.scripting.Script"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Currently executing script.</haxe_doc>
		</curScript>
		<create public="1" set="method" line="210" static="1">
			<f a="path">
				<c path="String"/>
				<c path="funkin.backend.scripting.Script"/>
			</f>
			<haxe_doc>* Creates a script from the specified asset path. The language is automatically determined.
	 * @param path Path in assets</haxe_doc>
		</create>
		<fromString public="1" set="method" line="233" static="1">
			<f a="code:path">
				<c path="String"/>
				<c path="String"/>
				<c path="funkin.backend.scripting.Script"/>
			</f>
			<haxe_doc>* Creates a script from the string. The language is determined based on the path.
	 * @param code code
	 * @param path filename</haxe_doc>
		</fromString>
		<fileName public="1">
			<c path="String"/>
			<haxe_doc>* Script name (with extension)</haxe_doc>
		</fileName>
		<extension public="1">
			<c path="String"/>
			<haxe_doc>* Script Extension</haxe_doc>
		</extension>
		<path public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Path to the script.</haxe_doc>
		</path>
		<rawPath expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</rawPath>
		<didLoad expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</didLoad>
		<remappedNames public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Remapped filenames.
	 * Used for trace messages, to show what mod the script is from.</haxe_doc>
		</remappedNames>
		<load public="1" set="method" line="272">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Loads the script</haxe_doc>
		</load>
		<setPublicMap public="1" set="method" line="287">
			<f a="map">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<x path="Void"/>
			</f>
			<haxe_doc>* HSCRIPT ONLY FOR NOW
	 * Sets the "public" variables map for ScriptPack</haxe_doc>
		</setPublicMap>
		<reload public="1" set="method" line="294">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Hot-reloads the script, if possible</haxe_doc>
		</reload>
		<trace public="1" set="method" line="301">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Traces something as this script.</haxe_doc>
		</trace>
		<call public="1" set="method" line="318">
			<f a="func:?parameters">
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>* Calls the function `func` defined in the script.
	 * @param func Name of the function
	 * @param parameters (Optional) Parameters of the function.
	 * @return Result (if void, then null)</haxe_doc>
		</call>
		<loadFromString public="1" set="method" line="332">
			<f a="code">
				<c path="String"/>
				<c path="funkin.backend.scripting.Script"/>
			</f>
			<haxe_doc>* Loads the code from a string, doesn't really work after the script has been loaded
	 * @param code The code.</haxe_doc>
		</loadFromString>
		<setParent public="1" set="method" line="340">
			<f a="variable">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets a script's parent object so that its properties can be accessed easily. Ex: Passing `PlayState.instance` will allow `boyfriend` to be typed instead of `PlayState.instance.boyfriend`.
	 * @param variable Parent variable.</haxe_doc>
		</setParent>
		<get public="1" set="method" line="347">
			<f a="variable">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>* Gets the variable `variable` from the script's variables.
	 * @param variable Name of the variable.
	 * @return Variable (or null if it doesn't exists)</haxe_doc>
		</get>
		<set public="1" set="method" line="354">
			<f a="variable:value">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the variable `variable` from the script's variables.
	 * @param variable Name of the variable.
	 * @return Variable (or null if it doesn't exists)</haxe_doc>
		</set>
		<error public="1" set="method" line="361">
			<f a="text:?additionalInfo">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shows an error from this script.
	 * @param text Text of the error (ex: Null Object Reference).
	 * @param additionalInfo Additional information you could provide.</haxe_doc>
		</error>
		<toString public="1" set="method" line="371" override="1"><f a=""><c path="String"/></f></toString>
		<onCall set="method" line="385">
			<f a="func:parameters">
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>* PRIVATE HANDLERS - DO NOT TOUCH</haxe_doc>
		</onCall>
		<onCreate public="1" set="method" line="392">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when the script is created.
	 * @param path Path to the script</haxe_doc>
		</onCreate>
		<onLoad public="1" set="method" line="397">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the script is loaded.</haxe_doc>
		</onLoad>
		<new public="1" set="method" line="249">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new instance of the script class.
	 * @param path</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.backend.scripting.ScriptPack</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.DummyScript" params="" file="source/funkin/backend/scripting/DummyScript.hx">
		<extends path="funkin.backend.scripting.Script"/>
		<variables public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</variables>
		<get public="1" set="method" line="9" override="1"><f a="v">
	<c path="String"/>
	<x path="Null"><d/></x>
</f></get>
		<set public="1" set="method" line="10" override="1"><f a="v:v2">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<onCall public="1" set="method" line="11" override="1"><f a="method:parameters">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></onCall>
		<new public="1" set="method" line="6"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Simple class for empty scripts or scripts whose language isn't imported yet.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.EventManager" params="" file="source/funkin/backend/scripting/EventManager.hx" final="1">
		<eventValues public="1" expr="[]" line="8" static="1">
			<c path="Array"><c path="funkin.backend.scripting.events.CancellableEvent"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</eventValues>
		<eventKeys public="1" expr="[]" line="9" static="1">
			<c path="Array"><x path="Class"><c path="funkin.backend.scripting.events.CancellableEvent"/></x></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</eventKeys>
		<get public="1" params="T" set="method" line="11" static="1"><f a="cl">
	<x path="Class"><c path="get.T"/></x>
	<c path="get.T"/>
</f></get>
		<reset public="1" set="method" line="25" static="1"><f a=""><x path="Void"/></f></reset>
		<init public="1" set="method" line="32" static="1"><f a=""><x path="Void"/></f></init>
		<onStateSwitch get="inline" set="null" line="37" static="1"><f a="newState">
	<c path="flixel.FlxState"/>
	<x path="Void"/>
</f></onStateSwitch>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.GlobalScript" params="" file="source/funkin/backend/scripting/GlobalScript.hx">
		<scripts public="1" static="1"><c path="funkin.backend.scripting.ScriptPack"/></scripts>
		<initialized expr="false" line="16" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</initialized>
		<reloading expr="false" line="17" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</reloading>
		<_lastAllow_Reload expr="false" line="18" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_lastAllow_Reload>
		<init public="1" set="method" line="20" static="1"><f a=""><x path="Void"/></f></init>
		<event public="1" params="T" set="method" line="109" static="1"><f a="name:event">
	<c path="String"/>
	<c path="event.T"/>
	<c path="event.T"/>
</f></event>
		<call public="1" set="method" line="115" static="1"><f a="name:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></call>
		<onModSwitch public="1" set="method" line="120" static="1"><f a="newMod">
	<c path="String"/>
	<x path="Void"/>
</f></onModSwitch>
		<beatHit public="1" set="method" line="135" static="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="139" static="1"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<haxe_doc>* Class for THE Global Script, aka script that runs in the background at all times.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.HScript" params="" file="source/funkin/backend/scripting/HScript.hx">
		<extends path="funkin.backend.scripting.Script"/>
		<initParser public="1" set="method" line="16" static="1"><f a=""><c path="hscript.Parser"/></f></initParser>
		<interp public="1"><c path="hscript.Interp"/></interp>
		<parser public="1"><c path="hscript.Parser"/></parser>
		<expr public="1"><c path="hscript.Expr"/></expr>
		<code public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</code>
		<__importedPaths><c path="Array"><c path="String"/></c></__importedPaths>
		<onCreate public="1" set="method" line="23" override="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></onCreate>
		<loadFromString public="1" set="method" line="53" override="1"><f a="code">
	<c path="String"/>
	<c path="funkin.backend.scripting.HScript"/>
</f></loadFromString>
		<importFailedCallback set="method" line="66"><f a="cl">
	<c path="Array"><c path="String"/></c>
	<x path="Bool"/>
</f></importFailedCallback>
		<_importFailedCallback set="method" line="72"><f a="cl:prefix">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Bool"/>
</f></_importFailedCallback>
		<_errorHandler set="method" line="102"><f a="error">
	<c path="hscript.Error"/>
	<x path="Void"/>
</f></_errorHandler>
		<setParent public="1" set="method" line="120" override="1"><f a="parent">
	<d/>
	<x path="Void"/>
</f></setParent>
		<onLoad public="1" set="method" line="124" override="1"><f a=""><x path="Void"/></f></onLoad>
		<reload public="1" set="method" line="137" override="1"><f a=""><x path="Void"/></f></reload>
		<onCall set="method" line="162" override="1"><f a="funcName:parameters">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></onCall>
		<get public="1" set="method" line="173" override="1"><f a="val">
	<c path="String"/>
	<d/>
</f></get>
		<set public="1" set="method" line="177" override="1"><f a="val:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<trace public="1" set="method" line="181" override="1"><f a="v">
	<d/>
	<x path="Void"/>
</f></trace>
		<setPublicMap public="1" set="method" line="189" override="1"><f a="map">
	<t path="Map">
		<c path="String"/>
		<d/>
	</t>
	<x path="Void"/>
</f></setPublicMap>
		<new public="1" set="method" line="8"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.ModState" params="" file="source/funkin/backend/scripting/ModState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<lastName public="1" expr="null" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Name of HScript file in assets/data/states.</haxe_doc>
		</lastName>
		<lastData public="1" expr="null" line="12" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Last Optional extra data.</haxe_doc>
		</lastData>
		<data public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Optional extra data.</haxe_doc>
		</data>
		<new public="1" set="method" line="26">
			<f a="_stateName:?_data">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* ModState Constructor.
	* Inherits from MusicBeatState and allows the execution of an HScript from assets/data/states passed via parameters.
	*
	* @param _stateName Name or path to a HScript file from assets/data/states.
	* @param _data Optional extra Dynamic data passed from a previous state (JSON suggested).</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.ModSubState" params="" file="source/funkin/backend/scripting/ModSubState.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<lastName public="1" expr="null" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Name of HScript file in assets/data/states.</haxe_doc>
		</lastName>
		<lastData public="1" expr="null" line="12" static="1">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Last Optional extra data.</haxe_doc>
		</lastData>
		<data public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Optional extra data.</haxe_doc>
		</data>
		<new public="1" set="method" line="26">
			<f a="_stateName:?_data">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* ModSubState Constructor.
	* Inherits from MusicBeatSubstate and allows the execution of an HScript from assets/data/states passed via parameters.
	*
	* @param _stateName Name or path to a HScript file from assets/data/states.
	* @param _data Optional extra Dynamic data passed from a previous state (JSON suggested).</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.MultiThreadedScript" params="" file="source/funkin/backend/scripting/MultiThreadedScript.hx">
		<implements path="hscript.IHScriptCustomBehaviour"/>
		<implements path="flixel.util.IFlxDestroyable"/>
		<thread><x path="sys.thread.Thread"/></thread>
		<script public="1">
			<c path="funkin.backend.scripting.Script"/>
			<haxe_doc>* Script being ran.</haxe_doc>
		</script>
		<__variables><c path="Array"><c path="String"/></c></__variables>
		<returnValue public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Return value of the last call.</haxe_doc>
		</returnValue>
		<callEnded public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the current call has ended.</haxe_doc>
		</callEnded>
		<hget public="1" set="method" line="60"><f a="name">
	<c path="String"/>
	<d/>
</f></hget>
		<hset public="1" set="method" line="62"><f a="name:val">
	<c path="String"/>
	<d/>
	<d/>
</f></hset>
		<call public="1" set="method" line="70"><f a="func:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></call>
		<destroy public="1" set="method" line="83"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="31"><f a="path:?parentScript">
	<c path="String"/>
	<c path="funkin.backend.scripting.Script"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.scripting.ScriptPack" params="" file="source/funkin/backend/scripting/ScriptPack.hx">
		<extends path="funkin.backend.scripting.Script"/>
		<scripts public="1" expr="[]">
			<c path="Array"><c path="funkin.backend.scripting.Script"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</scripts>
		<additionalDefaultVariables public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</additionalDefaultVariables>
		<publicVariables public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</publicVariables>
		<parent public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</parent>
		<load public="1" set="method" line="19" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Loads all scripts in the pack.</haxe_doc>
		</load>
		<contains public="1" set="method" line="29">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if the script pack contains a script with a specific path.
	 * @param path Path to check</haxe_doc>
		</contains>
		<getByPath public="1" set="method" line="44">
			<f a="name">
				<c path="String"/>
				<c path="funkin.backend.scripting.Script"/>
			</f>
			<haxe_doc>* Gets a script by path.
	 * @param name Path to the script</haxe_doc>
		</getByPath>
		<getByName public="1" set="method" line="55">
			<f a="name">
				<c path="String"/>
				<c path="funkin.backend.scripting.Script"/>
			</f>
			<haxe_doc>* Gets a script by name.
	 * @param name Name of the script</haxe_doc>
		</getByName>
		<importScript public="1" set="method" line="67">
			<f a="path">
				<c path="String"/>
				<c path="funkin.backend.scripting.Script"/>
			</f>
			<haxe_doc>* Imports a script by path.
	 * @param path Path to the script
	 * @throws Error if the script does not exist</haxe_doc>
		</importScript>
		<call public="1" set="method" line="84" override="1">
			<f a="func:?parameters">
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>* Calls a function on every single script.
	 * Only calls on scripts that are active.
	 * @param func Function to call
	 * @param parameters Parameters to pass to the function</haxe_doc>
		</call>
		<event public="1" params="T" get="inline" set="null" line="97">
			<f a="func:event">
				<c path="String"/>
				<c path="event.T"/>
				<c path="event.T"/>
			</f>
			<haxe_doc>* Sends an event to every single script, and returns the event.
	 * @param func Function to call
	 * @param event Event (will be the first parameter of the function)
	 * @return (modified by scripts)</haxe_doc>
		</event>
		<get public="1" set="method" line="111" override="1">
			<f a="val">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>* Gets the first script that has a variable with a specific name.
	 * @param val Name of the variable</haxe_doc>
		</get>
		<reload public="1" set="method" line="122" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Reloads all scripts in the pack.</haxe_doc>
		</reload>
		<set public="1" set="method" line="129" override="1">
			<f a="val:value">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets a variable in every script.</haxe_doc>
		</set>
		<setParent public="1" set="method" line="136" override="1">
			<f a="parent">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the parent/this of every script in the pack.</haxe_doc>
		</setParent>
		<destroy public="1" set="method" line="144" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroys all scripts in the pack.</haxe_doc>
		</destroy>
		<onCreate public="1" set="method" line="149" override="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onCreate>
		<add public="1" set="method" line="154">
			<f a="script">
				<c path="funkin.backend.scripting.Script"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a script to the pack, and sets the parent/this of the script.</haxe_doc>
		</add>
		<remove public="1" set="method" line="163">
			<f a="script">
				<c path="funkin.backend.scripting.Script"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes a script from the pack.
	 * Does not reset the parent/this.</haxe_doc>
		</remove>
		<insert public="1" set="method" line="170">
			<f a="pos:script">
				<x path="Int"/>
				<c path="funkin.backend.scripting.Script"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Inserts a script into the pack, and sets the parent/this of the script.</haxe_doc>
		</insert>
		<__configureNewScript set="method" line="179">
			<f a="script">
				<c path="funkin.backend.scripting.Script"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Configures a new script.
	 * @param script Script to configure</haxe_doc>
		</__configureNewScript>
		<toString public="1" set="method" line="185" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="35"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Used to group multiple scripts together, and easily be able to call them.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>CancellableEvent</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.CancellableEvent" params="" file="source/funkin/backend/scripting/events/CancellableEvent.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<cancelled public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</cancelled>
		<__continueCalls expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__continueCalls>
		<data public="1" expr="{ }">
			<d/>
			<meta><m n=":value"><e>{ }</e></m></meta>
			<haxe_doc>* Additional data if used in scripts</haxe_doc>
		</data>
		<preventDefault public="1" set="method" line="21">
			<f a="?c" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ c : false }</e></m></meta>
			<haxe_doc>* Prevents default action from occurring.
	 * @param c Whenever the scripts following this one should be called or not. (Defaults to `true`)</haxe_doc>
		</preventDefault>
		<cancel public="1" set="method" line="27">
			<f a="?c" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ c : true }</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</cancel>
		<recycleBase public="1" set="method" line="35"><f a=""><x path="Void"/></f></recycleBase>
		<toString public="1" set="method" line="47">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns a string representation of the event, in this format:
	 * `[CancellableEvent]`
	 * `[CancellableEvent (Cancelled)]`
	 * @return String</haxe_doc>
		</toString>
		<destroy public="1" set="method" line="54"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a new cancellable event.
	 * This allows scripts to call `cancel()` to cancel the event.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.backend.scripting.ScriptPack</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":noCustomClass"/>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.AmountEvent" params="" file="source/funkin/backend/scripting/events/AmountEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<amount public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>* Amount</haxe_doc>
		</amount>
		<recycle public="1" set="method" line="3"><f a="amount">
	<x path="Null"><x path="Int"/></x>
	<c path="funkin.backend.scripting.events.AmountEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.DrawEvent" params="" file="source/funkin/backend/scripting/events/DrawEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<recycle public="1" set="method" line="3"><f a=""><c path="funkin.backend.scripting.events.DrawEvent"/></f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.DynamicEvent" params="" file="source/funkin/backend/scripting/events/DynamicEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<value1 public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</value1>
		<value2 public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</value2>
		<value3 public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</value3>
		<value4 public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</value4>
		<value5 public="1" expr="null">
			<d/>
			<meta><m n=":value"><e>null</e></m></meta>
		</value5>
		<recycle public="1" set="method" line="6">
			<f a="?value1:?value2:?value3:?value4:?value5" v="null:null:null:null:null">
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
				<c path="funkin.backend.scripting.events.DynamicEvent"/>
			</f>
			<meta><m n=":value"><e>{ value5 : null, value4 : null, value3 : null, value2 : null, value1 : null }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Event with random dynamic values useful for making your own custom events</haxe_doc>
		<meta>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.NameEvent" params="" file="source/funkin/backend/scripting/events/NameEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Name</haxe_doc>
		</name>
		<recycle public="1" set="method" line="3"><f a="name">
	<c path="String"/>
	<c path="funkin.backend.scripting.events.NameEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.PointEvent" params="" file="source/funkin/backend/scripting/events/PointEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>X position</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>Y position</haxe_doc>
		</y>
		<recycle public="1" set="method" line="3"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.backend.scripting.events.PointEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.ResizeEvent" params="" file="source/funkin/backend/scripting/events/ResizeEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>* New width</haxe_doc>
		</width>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>* New height</haxe_doc>
		</height>
		<oldWidth public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>* Old width (may be null)</haxe_doc>
		</oldWidth>
		<oldHeight public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>* Old height (may be null)</haxe_doc>
		</oldHeight>
		<recycle public="1" set="method" line="3"><f a="width:height:oldWidth:oldHeight">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
	<c path="funkin.backend.scripting.events.ResizeEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.StateEvent" params="" file="source/funkin/backend/scripting/events/StateEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<substate public="1">
			<c path="flixel.FlxState"/>
			<haxe_doc>* Substate or State that is about to be opened/closed</haxe_doc>
		</substate>
		<recycle public="1" set="method" line="5"><f a="substate">
	<c path="flixel.FlxState"/>
	<c path="funkin.backend.scripting.events.StateEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.TransitionCreationEvent" params="" file="source/funkin/backend/scripting/events/TransitionCreationEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<transOut public="1">
			<x path="Bool"/>
			<haxe_doc>* If the transition is going out into another state</haxe_doc>
		</transOut>
		<newState public="1">
			<c path="flixel.FlxState"/>
			<haxe_doc>* The state that is about to be loaded (only on trans out)</haxe_doc>
		</newState>
		<recycle public="1" set="method" line="8"><f a="transOut:newState">
	<x path="Bool"/>
	<c path="flixel.FlxState"/>
	<c path="funkin.backend.scripting.events.TransitionCreationEvent"/>
</f></recycle>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to prevent default behaviour!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.character.CharacterNodeEvent" params="" file="source/funkin/backend/scripting/events/character/CharacterNodeEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<character public="1">
			<c path="funkin.game.Character"/>
			<haxe_doc>* The character instance</haxe_doc>
		</character>
		<node public="1">
			<x path="haxe.xml.Access"/>
			<haxe_doc>* The node which is currently being parsed</haxe_doc>
		</node>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the node, quicker access than e.node.name</haxe_doc>
		</name>
		<recycle public="1" set="method" line="6"><f a="character:node:name">
	<c path="funkin.game.Character"/>
	<x path="haxe.xml.Access"/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.character.CharacterNodeEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.character.CharacterXMLEvent" params="" file="source/funkin/backend/scripting/events/character/CharacterXMLEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<character public="1">
			<c path="funkin.game.Character"/>
			<haxe_doc>* The character instance</haxe_doc>
		</character>
		<xml public="1">
			<x path="haxe.xml.Access"/>
			<haxe_doc>* The xml</haxe_doc>
		</xml>
		<recycle public="1" set="method" line="6"><f a="character:xml">
	<c path="funkin.game.Character"/>
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.scripting.events.character.CharacterXMLEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.character.DanceEvent" params="" file="source/funkin/backend/scripting/events/character/DanceEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<danced public="1"><x path="Bool"/></danced>
		<recycle public="1" set="method" line="3"><f a="danced">
	<x path="Bool"/>
	<c path="funkin.backend.scripting.events.character.DanceEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.character.DirectionAnimEvent" params="" file="source/funkin/backend/scripting/events/character/DirectionAnimEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<animName public="1">
			<c path="String"/>
			<haxe_doc>Default animation that will be played</haxe_doc>
		</animName>
		<direction public="1">
			<x path="Int"/>
			<haxe_doc>In which direction the animation will be played</haxe_doc>
		</direction>
		<suffix public="1">
			<c path="String"/>
			<haxe_doc>The suffix of the animation (ex: "-alt") - Defaults to ""</haxe_doc>
		</suffix>
		<context public="1">
			<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
			<haxe_doc>Context of the animation. Is either equal to `SING` or `MISS`.</haxe_doc>
		</context>
		<reversed public="1">
			<x path="Bool"/>
			<haxe_doc>Whenever the animation will play reversed or not.</haxe_doc>
		</reversed>
		<frame public="1">
			<x path="Int"/>
			<haxe_doc>At what frame the animation will start playing</haxe_doc>
		</frame>
		<force public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>Force the animation to replay even if it's already playing  (if it's null it will be forced based on the sprite's data xml, if it has one).</haxe_doc>
		</force>
		<recycle public="1" set="method" line="5"><f a="animName:direction:suffix:context:reversed:frame:force">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Null"><x path="Bool"/></x>
	<c path="funkin.backend.scripting.events.character.DirectionAnimEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueBoxCharPopupEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueBoxCharPopupEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<char public="1"><c path="funkin.game.cutscenes.dialogue.DialogueCharacter"/></char>
		<force public="1"><x path="Bool"/></force>
		<recycle public="1" set="method" line="5"><f a="char:force">
	<c path="funkin.game.cutscenes.dialogue.DialogueCharacter"/>
	<x path="Bool"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueBoxCharPopupEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueBoxPlayBubbleEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueBoxPlayBubbleEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<bubble public="1"><c path="String"/></bubble>
		<suffix public="1"><c path="String"/></suffix>
		<text public="1"><c path="String"/></text>
		<format public="1"><c path="Array"><t path="funkin.backend.utils.TextFormat"/></c></format>
		<speed public="1"><x path="Float"/></speed>
		<customSFX public="1"><c path="flixel.sound.FlxSound"/></customSFX>
		<customTypeSFX public="1"><c path="Array"><c path="flixel.sound.FlxSound"/></c></customTypeSFX>
		<setTextAfter public="1"><x path="Bool"/></setTextAfter>
		<allowDefault public="1"><x path="Bool"/></allowDefault>
		<recycle public="1" set="method" line="6"><f a="bubble:suffix:text:format:speed:customSFX:customTypeSFX:setTextAfter:allowDefault">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
	<x path="Float"/>
	<c path="flixel.sound.FlxSound"/>
	<c path="Array"><c path="flixel.sound.FlxSound"/></c>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueBoxPlayBubbleEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueBoxSetTextEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueBoxSetTextEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<text public="1"><c path="String"/></text>
		<format public="1"><c path="Array"><t path="funkin.backend.utils.TextFormat"/></c></format>
		<speed public="1"><x path="Null"><x path="Float"/></x></speed>
		<customTypeSFX public="1"><c path="Array"><c path="flixel.sound.FlxSound"/></c></customTypeSFX>
		<recycle public="1" set="method" line="6"><f a="text:format:speed:customTypeSFX">
	<c path="String"/>
	<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
	<x path="Null"><x path="Float"/></x>
	<c path="Array"><c path="flixel.sound.FlxSound"/></c>
	<c path="funkin.backend.scripting.events.dialogue.DialogueBoxSetTextEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueBoxStructureEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueBoxStructureEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<name public="1"><c path="String"/></name>
		<textTypeSFX public="1"><c path="String"/></textTypeSFX>
		<dialogueBoxData public="1"><x path="haxe.xml.Access"/></dialogueBoxData>
		<recycle public="1" set="method" line="8"><f a="name:textTypeSFX:dialogueBoxData">
	<c path="String"/>
	<c path="String"/>
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueBoxStructureEvent"/>
</f></recycle>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to customize from 0 the xml structure part!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueCharHideEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueCharHideEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<animation public="1"><c path="String"/></animation>
		<lastAnimContext public="1"><x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/></lastAnimContext>
		<recycle public="1" set="method" line="5"><f a="animation:lastAnimContext">
	<c path="String"/>
	<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueCharHideEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueCharShowEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueCharShowEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<animation public="1"><c path="String"/></animation>
		<lastAnimContext public="1"><x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/></lastAnimContext>
		<recycle public="1" set="method" line="5"><f a="x:y:animation:lastAnimContext">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueCharShowEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueCharStructureEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueCharStructureEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<name public="1"><c path="String"/></name>
		<position public="1"><c path="String"/></position>
		<charData public="1"><x path="haxe.xml.Access"/></charData>
		<recycle public="1" set="method" line="8"><f a="name:position:charData">
	<c path="String"/>
	<c path="String"/>
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueCharStructureEvent"/>
</f></recycle>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to customize from 0 the xml structure part!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueNextLineEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueNextLineEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<playFirst public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If the dialogue has just been opened.</haxe_doc>
		</playFirst>
		<recycle public="1" set="method" line="8">
			<f a="?playFirst" v="false">
				<x path="Bool"/>
				<c path="funkin.backend.scripting.events.dialogue.DialogueNextLineEvent"/>
			</f>
			<meta><m n=":value"><e>{ playFirst : false }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to prevent continuing with the next dialogue.
 *
 * **NOTE**: To access the current, past or next lines, use `curLine`, `lastLine` or also `dialogueLines` in the `DialogueCutscene` class (they're globals and can be accessed at any time as long as the Dialogue Cutscene is active)!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.dialogue.DialogueStructureEvent" params="" file="source/funkin/backend/scripting/events/dialogue/DialogueStructureEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<dialogueData public="1"><x path="haxe.xml.Access"/></dialogueData>
		<recycle public="1" set="method" line="8"><f a="dialogueData">
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.scripting.events.dialogue.DialogueStructureEvent"/>
</f></recycle>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to customize from 0 the xml structure part!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.discord.DiscordPresenceUpdateEvent" params="" file="source/funkin/backend/scripting/events/discord/DiscordPresenceUpdateEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<presence public="1">
			<t path="funkin.backend.utils.DPresence"/>
			<haxe_doc>* Object containing all of the data for the presence. Can be altered.</haxe_doc>
		</presence>
		<recycle public="1" set="method" line="3"><f a="presence">
	<t path="funkin.backend.utils.DPresence"/>
	<c path="funkin.backend.scripting.events.discord.DiscordPresenceUpdateEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.gameover.GameOverCreationEvent" params="" file="source/funkin/backend/scripting/events/gameover/GameOverCreationEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<character public="1"><c path="String"/></character>
		<player public="1"><x path="Bool"/></player>
		<gameOverSong public="1"><c path="String"/></gameOverSong>
		<bpm public="1"><x path="Float"/></bpm>
		<lossSFX public="1"><c path="String"/></lossSFX>
		<retrySFX public="1"><c path="String"/></retrySFX>
		<recycle public="1" set="method" line="6"><f a="x:y:character:player:gameOverSong:bpm:lossSFX:retrySFX">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.gameover.GameOverCreationEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to prevent default behaviour!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.gameplay.CamMoveEvent" params="" file="source/funkin/backend/scripting/events/gameplay/CamMoveEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<position public="1">
			<x path="flixel.math.FlxPoint"/>
			<haxe_doc>* Final camera position.</haxe_doc>
		</position>
		<strumLine public="1">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* Currently focused strumline.</haxe_doc>
		</strumLine>
		<focusedCharacters public="1">
			<x path="Int"/>
			<haxe_doc>* Number of focused characters</haxe_doc>
		</focusedCharacters>
		<recycle public="1" set="method" line="6"><f a="position:strumLine:focusedCharacters">
	<x path="flixel.math.FlxPoint"/>
	<c path="funkin.game.StrumLine"/>
	<x path="Int"/>
	<c path="funkin.backend.scripting.events.gameplay.CamMoveEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.gameplay.CountdownEvent" params="" file="source/funkin/backend/scripting/events/gameplay/CountdownEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<swagCounter public="1">
			<x path="Int"/>
			<haxe_doc>* At which count the countdown is. Normally goes 0-1-2-3-4 unless `PlayState.instance.introLength` is changed.</haxe_doc>
		</swagCounter>
		<volume public="1">
			<x path="Float"/>
			<haxe_doc>* Volume at which the intro countdown sound will play.</haxe_doc>
		</volume>
		<soundPath public="1">
			<c path="String"/>
			<haxe_doc>* Path of the intro sound that'll be played.</haxe_doc>
		</soundPath>
		<spritePath public="1">
			<c path="String"/>
			<haxe_doc>* Path to the sprite path that'll be shown.</haxe_doc>
		</spritePath>
		<scale public="1">
			<x path="Float"/>
			<haxe_doc>* Scale of the sprite.</haxe_doc>
		</scale>
		<antialiasing public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever antialiasing is enabled or not.</haxe_doc>
		</antialiasing>
		<sprite public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Created sprite, only available in `onPostCountdown`</haxe_doc>
		</sprite>
		<spriteTween public="1">
			<c path="flixel.tweens.FlxTween"/>
			<haxe_doc>* Created tween for the sprite, only available in `onPostCountdown`</haxe_doc>
		</spriteTween>
		<sound public="1">
			<c path="flixel.sound.FlxSound"/>
			<haxe_doc>* Created sound, only available in `onPostCountdown`</haxe_doc>
		</sound>
		<recycle public="1" set="method" line="6"><f a="swagCounter:volume:soundPath:spritePath:scale:antialiasing:sprite:spriteTween:sound">
	<x path="Int"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flixel.FlxSprite"/>
	<c path="flixel.tweens.FlxTween"/>
	<c path="flixel.sound.FlxSound"/>
	<c path="funkin.backend.scripting.events.gameplay.CountdownEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.gameplay.EventGameEvent" params="" file="source/funkin/backend/scripting/events/gameplay/EventGameEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<event public="1"><t path="funkin.backend.chart.ChartEvent"/></event>
		<recycle public="1" set="method" line="5"><f a="event">
	<t path="funkin.backend.chart.ChartEvent"/>
	<c path="funkin.backend.scripting.events.gameplay.EventGameEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.gameplay.GameOverEvent" params="" file="source/funkin/backend/scripting/events/gameplay/GameOverEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X pos of where the gameover character will be.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y pos of where the gameover character will be.</haxe_doc>
		</y>
		<character public="1">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Character which died. Default to `boyfriend`.</haxe_doc>
		</character>
		<deathCharID public="1">
			<c path="String"/>
			<haxe_doc>* Character ID (name) for game over. Default to whatever is specified in the character's XML.</haxe_doc>
		</deathCharID>
		<isPlayer public="1">
			<x path="Bool"/>
			<haxe_doc>* If the character has isPlayer</haxe_doc>
		</isPlayer>
		<gameOverSong public="1">
			<c path="String"/>
			<haxe_doc>* Song for the game over screen. Default to `this.gameOverSong` (`gameOver`)</haxe_doc>
		</gameOverSong>
		<lossSFX public="1">
			<c path="String"/>
			<haxe_doc>* SFX at the beginning of the game over (Mic drop). Default to `this.lossSFX` (`gameOverSFX`)</haxe_doc>
		</lossSFX>
		<retrySFX public="1">
			<c path="String"/>
			<haxe_doc>* SFX played whenever the player retries. Defaults to `retrySFX` (`gameOverEnd`)</haxe_doc>
		</retrySFX>
		<recycle public="1" set="method" line="5"><f a="x:y:character:deathCharID:isPlayer:gameOverSong:lossSFX:retrySFX">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.game.Character"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.gameplay.GameOverEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.gameplay.RatingUpdateEvent" params="" file="source/funkin/backend/scripting/events/gameplay/RatingUpdateEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<rating public="1">
			<x path="Null"><c path="funkin.game.ComboRating"/></x>
			<haxe_doc>New combo (may be null if no ratings were found)</haxe_doc>
		</rating>
		<oldRating public="1">
			<x path="Null"><c path="funkin.game.ComboRating"/></x>
			<haxe_doc>Old combo (may be null)</haxe_doc>
		</oldRating>
		<recycle public="1" set="method" line="3"><f a="rating:oldRating">
	<x path="Null"><c path="funkin.game.ComboRating"/></x>
	<x path="Null"><c path="funkin.game.ComboRating"/></x>
	<c path="funkin.backend.scripting.events.gameplay.RatingUpdateEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.healthicon.HealthIconChangeEvent" params="" file="source/funkin/backend/scripting/events/healthicon/HealthIconChangeEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<anim public="1">
			<x path="flixel.util.typeLimit.OneOfTwo">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<haxe_doc>* Animation State</haxe_doc>
		</anim>
		<healthIcon public="1">
			<c path="funkin.game.HealthIcon"/>
			<haxe_doc>* The health icon</haxe_doc>
		</healthIcon>
		<recycle public="1" set="method" line="5"><f a="anim:healthIcon">
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<x path="Int"/>
	</x>
	<c path="funkin.game.HealthIcon"/>
	<c path="funkin.backend.scripting.events.healthicon.HealthIconChangeEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.menu.MenuChangeEvent" params="" file="source/funkin/backend/scripting/events/menu/MenuChangeEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<oldValue public="1">
			<x path="Int"/>
			<haxe_doc>* Value before the change</haxe_doc>
		</oldValue>
		<value public="1">
			<x path="Int"/>
			<haxe_doc>* Value after the change</haxe_doc>
		</value>
		<change public="1">
			<x path="Int"/>
			<haxe_doc>* Amount of change</haxe_doc>
		</change>
		<playMenuSFX public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the menu SFX should be played.</haxe_doc>
		</playMenuSFX>
		<recycle public="1" set="method" line="3">
			<f a="oldValue:value:change:?playMenuSFX" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="funkin.backend.scripting.events.menu.MenuChangeEvent"/>
			</f>
			<meta><m n=":value"><e>{ playMenuSFX : true }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.menu.freeplay.FreeplayAlphaUpdateEvent" params="" file="source/funkin/backend/scripting/events/menu/freeplay/FreeplayAlphaUpdateEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<idleAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha when nothing is playing and isn't selected</haxe_doc>
		</idleAlpha>
		<idlePlayingAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha when something is playing and isn't selected</haxe_doc>
		</idlePlayingAlpha>
		<selectedAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha when nothing is playing and selected</haxe_doc>
		</selectedAlpha>
		<selectedPlayingAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha when something is playing and selected</haxe_doc>
		</selectedPlayingAlpha>
		<lerp public="1">
			<x path="Float"/>
			<haxe_doc>* The lerp of the alpha</haxe_doc>
		</lerp>
		<recycle public="1" set="method" line="3"><f a="idleAlpha:idlePlayingAlpha:selectedAlpha:selectedPlayingAlpha:lerp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.backend.scripting.events.menu.freeplay.FreeplayAlphaUpdateEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.menu.freeplay.FreeplaySongSelectEvent" params="" file="source/funkin/backend/scripting/events/menu/freeplay/FreeplaySongSelectEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<song public="1">
			<c path="String"/>
			<haxe_doc>* Song name that is about to be played</haxe_doc>
		</song>
		<difficulty public="1">
			<c path="String"/>
			<haxe_doc>* Difficulty name</haxe_doc>
		</difficulty>
		<opponentMode public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever opponent mode is enabled or not.</haxe_doc>
		</opponentMode>
		<coopMode public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever coop mode is enabled.</haxe_doc>
		</coopMode>
		<recycle public="1" set="method" line="3"><f a="song:difficulty:opponentMode:coopMode">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="funkin.backend.scripting.events.menu.freeplay.FreeplaySongSelectEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.menu.pause.PauseCreationEvent" params="" file="source/funkin/backend/scripting/events/menu/pause/PauseCreationEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<music public="1">
			<c path="String"/>
			<haxe_doc>* Music that is going to be played</haxe_doc>
		</music>
		<options public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* All option names</haxe_doc>
		</options>
		<recycle public="1" set="method" line="6"><f a="music:options">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="funkin.backend.scripting.events.menu.pause.PauseCreationEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* CANCEL this event to prevent default behaviour!</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.menu.storymenu.WeekSelectEvent" params="" file="source/funkin/backend/scripting/events/menu/storymenu/WeekSelectEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<week public="1">
			<t path="funkin.backend.week.WeekData"/>
			<haxe_doc>* Week that is going to be selected</haxe_doc>
		</week>
		<difficulty public="1">
			<c path="String"/>
			<haxe_doc>* The difficulty that has been selected</haxe_doc>
		</difficulty>
		<weekID public="1">
			<x path="Int"/>
			<haxe_doc>* At which emplacement the week is. Goes from 0 to the number of weeks - 1.</haxe_doc>
		</weekID>
		<difficultyID public="1">
			<x path="Int"/>
			<haxe_doc>* At which emplacement the difficulty is. Goes from 0 to the number of weeks - 1.</haxe_doc>
		</difficultyID>
		<recycle public="1" set="method" line="5"><f a="week:difficulty:weekID:difficultyID">
	<t path="funkin.backend.week.WeekData"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="funkin.backend.scripting.events.menu.storymenu.WeekSelectEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.note.InputSystemEvent" params="" file="source/funkin/backend/scripting/events/note/InputSystemEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<pressed public="1">
			<c path="Array"><x path="Bool"/></c>
			<haxe_doc>* Array containing whenever a specific control is pressed or not.
	 * For example, `pressed[0]` will return whenever the left strum was pressed.</haxe_doc>
		</pressed>
		<justPressed public="1">
			<c path="Array"><x path="Bool"/></c>
			<haxe_doc>* Array containing whenever a specific control was pressed (not hold) this frame or not.
	 * For example, `justPressed[0]` will return whenever the left strum was just pressed.</haxe_doc>
		</justPressed>
		<justReleased public="1">
			<c path="Array"><x path="Bool"/></c>
			<haxe_doc>* Array containing whenever a specific control was released this frame or not.
	 * For example, `justReleased[0]` will return whenever the left strum was just released.</haxe_doc>
		</justReleased>
		<strumLine public="1">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* Strumline which input is being processed.</haxe_doc>
		</strumLine>
		<strumLineID public="1">
			<x path="Int"/>
			<haxe_doc>* ID of the Strumline.</haxe_doc>
		</strumLineID>
		<recycle public="1" set="method" line="5"><f a="pressed:justPressed:justReleased:strumLine:strumLineID">
	<c path="Array"><x path="Bool"/></c>
	<c path="Array"><x path="Bool"/></c>
	<c path="Array"><x path="Bool"/></c>
	<c path="funkin.game.StrumLine"/>
	<x path="Int"/>
	<c path="funkin.backend.scripting.events.note.InputSystemEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.note.NoteCreationEvent" params="" file="source/funkin/backend/scripting/events/note/NoteCreationEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<note public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* Note that is being created</haxe_doc>
		</note>
		<strumID public="1">
			<x path="Int"/>
			<haxe_doc>* ID of the strum (from 0 to 3)</haxe_doc>
		</strumID>
		<noteType public="1">
			<c path="String"/>
			<haxe_doc>* Note Type (ex: "My Super Cool Note", or "Mine")</haxe_doc>
		</noteType>
		<noteTypeID public="1">
			<x path="Int"/>
			<haxe_doc>* ID of the note type.</haxe_doc>
		</noteTypeID>
		<strumLineID public="1">
			<x path="Int"/>
			<haxe_doc>* ID of the player.</haxe_doc>
		</strumLineID>
		<mustHit public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever the note will need to be hit by the player</haxe_doc>
		</mustHit>
		<noteSprite public="1">
			<c path="String"/>
			<haxe_doc>* Note sprite, if you only want to replace the sprite.</haxe_doc>
		</noteSprite>
		<noteScale public="1">
			<x path="Float"/>
			<haxe_doc>* Note scale, if you only want to replace the scale.</haxe_doc>
		</noteScale>
		<animSuffix public="1">
			<c path="String"/>
			<haxe_doc>* Sing animation suffix. "-alt" for alt anim or "" for normal notes.</haxe_doc>
		</animSuffix>
		<recycle public="1" set="method" line="5"><f a="note:strumID:noteType:noteTypeID:strumLineID:mustHit:noteSprite:noteScale:animSuffix">
	<c path="funkin.game.Note"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.note.NoteCreationEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.note.NoteHitEvent" params="" file="source/funkin/backend/scripting/events/note/NoteHitEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<animCancelled public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</animCancelled>
		<strumGlowCancelled public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</strumGlowCancelled>
		<deleteNote public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</deleteNote>
		<unmuteVocals public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</unmuteVocals>
		<enableCamZooming public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</enableCamZooming>
		<autoHitLastSustain public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</autoHitLastSustain>
		<misses public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever a miss should be added.</haxe_doc>
		</misses>
		<countAsCombo public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether this hit increases combo.</haxe_doc>
		</countAsCombo>
		<countScore public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether this hit increases the score</haxe_doc>
		</countScore>
		<showRating public="1" expr="null">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Whenever ratings (Rating sprite, Digits sprites and Combo sprite) should be shown or not.
	 *
	 * NOTE: Whether it's `true` use `displayRating` and `displayCombo` (plus `minDigitDisplay` in the PlayState class) to change what's going to pop up!</haxe_doc>
		</showRating>
		<displayRating public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever the Rating sprites should be shown or not.</haxe_doc>
		</displayRating>
		<displayCombo public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever the Combo sprite should be shown or not (like old Week 7 patches).</haxe_doc>
		</displayCombo>
		<note public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* Note that has been pressed</haxe_doc>
		</note>
		<character public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Character that pressed the note.</haxe_doc>
		</character>
		<characters public="1">
			<c path="Array"><c path="funkin.game.Character"/></c>
			<haxe_doc>* Characters that pressed the note.</haxe_doc>
		</characters>
		<player public="1">
			<x path="Bool"/>
			<haxe_doc>* Whenever the Character is a player</haxe_doc>
		</player>
		<noteType public="1">
			<c path="String"/>
			<haxe_doc>* Note Type name (null if default note)</haxe_doc>
		</noteType>
		<animSuffix public="1">
			<c path="String"/>
			<haxe_doc>* Suffix of the animation. "-alt" for alt notes, "" for normal ones.</haxe_doc>
		</animSuffix>
		<ratingPrefix public="1">
			<c path="String"/>
			<haxe_doc>* Prefix of the rating sprite path. Defaults to "game/score/"</haxe_doc>
		</ratingPrefix>
		<ratingSuffix public="1">
			<c path="String"/>
			<haxe_doc>* Suffix of the rating sprite path.</haxe_doc>
		</ratingSuffix>
		<direction public="1">
			<x path="Int"/>
			<haxe_doc>* Direction of the press (0 = Left, 1 = Down, 2 = Up, 3 = Right)</haxe_doc>
		</direction>
		<score public="1">
			<x path="Int"/>
			<haxe_doc>* Score gained after note press.</haxe_doc>
		</score>
		<accuracy public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>* Accuracy gained from pressing this note. From 0 to 1. null means no accuracy is gained.</haxe_doc>
		</accuracy>
		<healthGain public="1">
			<x path="Float"/>
			<haxe_doc>* The amount of health that'll be gained from pressing that note. If called from `onPlayerMiss`, the value will be negative.</haxe_doc>
		</healthGain>
		<rating public="1" expr="&quot;sick&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"sick"</e></m></meta>
			<haxe_doc>* Rating name. Defaults to "sick", "good", "bad" and "shit". Customizable.</haxe_doc>
		</rating>
		<showSplash public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever a splash should be shown when the note is hit.</haxe_doc>
		</showSplash>
		<numScale public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
			<haxe_doc>* Scale of combo numbers.</haxe_doc>
		</numScale>
		<numAntialiasing public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever antialiasing should be enabled on combo number.</haxe_doc>
		</numAntialiasing>
		<ratingScale public="1" expr="0.7">
			<x path="Float"/>
			<meta><m n=":value"><e>0.7</e></m></meta>
			<haxe_doc>* Scale of ratings.</haxe_doc>
		</ratingScale>
		<ratingAntialiasing public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever antialiasing should be enabled on ratings.</haxe_doc>
		</ratingAntialiasing>
		<forceAnim public="1" expr="true">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the animation should be forced to play (if it's null it will be forced based on the sprite's data xml, if it has one).</haxe_doc>
		</forceAnim>
		<healthIcon public="1">
			<c path="funkin.game.HealthIcon"/>
			<haxe_doc>* The attached healthIcon used distinction for icons amongst others</haxe_doc>
		</healthIcon>
		<preventAnim public="1" set="method" line="125">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the default sing animation from being played.</haxe_doc>
		</preventAnim>
		<cancelAnim public="1" set="method" line="130">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelAnim>
		<preventDeletion public="1" set="method" line="135">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the note from being deleted.</haxe_doc>
		</preventDeletion>
		<cancelDeletion public="1" set="method" line="139">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelDeletion>
		<forceDeletion public="1" set="method" line="144">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Forces the note to be deleted.</haxe_doc>
		</forceDeletion>
		<preventVocalsUnmute public="1" set="method" line="151">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the vocals volume from being set to 1 after pressing the note.</haxe_doc>
		</preventVocalsUnmute>
		<cancelVocalsUnmute public="1" set="method" line="155">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelVocalsUnmute>
		<preventVocalsMute public="1" set="method" line="160">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the vocals volume from being muted in case its a parameter of `onPlayerMiss`</haxe_doc>
		</preventVocalsMute>
		<cancelVocalsMute public="1" set="method" line="164">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelVocalsMute>
		<preventCamZooming public="1" set="method" line="169">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the camera zoom every 4 beats from enabling.</haxe_doc>
		</preventCamZooming>
		<cancelCamZooming public="1" set="method" line="173">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelCamZooming>
		<preventLastSustainHit public="1" set="method" line="178">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the sustain tail (the last one) from being automatically hit when the sustain before it is hit.</haxe_doc>
		</preventLastSustainHit>
		<cancelLastSustainHit public="1" set="method" line="182">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelLastSustainHit>
		<preventStrumGlow public="1" set="method" line="187">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the strum from glowing after this note has been pressed.</haxe_doc>
		</preventStrumGlow>
		<cancelStrumGlow public="1" set="method" line="191">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelStrumGlow>
		<get_character get="inline" set="null" line="194"><f a=""><c path="funkin.game.Character"/></f></get_character>
		<set_character set="method" line="195"><f a="char">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_character>
		<recycle public="1" set="method" line="7">
			<f a="?misses:?countAsCombo:?countScore:?showRating:displayRating:displayCombo:note:characters:player:noteType:animSuffix:ratingPrefix:ratingSuffix:direction:score:accuracy:healthGain:?rating:?showSplash:?numScale:?numAntialiasing:?ratingScale:?ratingAntialiasing:?forceAnim:healthIcon" v="true:true:true:null::::::::::::::&quot;sick&quot;:false:0.5:true:0.7:true:true:">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="funkin.game.Note"/>
				<c path="Array"><c path="funkin.game.Character"/></c>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Null"><x path="Float"/></x>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="funkin.game.HealthIcon"/>
				<c path="funkin.backend.scripting.events.note.NoteHitEvent"/>
			</f>
			<meta><m n=":value"><e>{ forceAnim : true, ratingAntialiasing : true, ratingScale : 0.7, numAntialiasing : true, numScale : 0.5, showSplash : false, rating : "sick", showRating : null, countScore : true, countAsCombo : true, misses : true }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.note.NoteMissEvent" params="" file="source/funkin/backend/scripting/events/note/NoteMissEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<animCancelled public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</animCancelled>
		<deleteNote public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</deleteNote>
		<stunned public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</stunned>
		<resetCombo public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</resetCombo>
		<playMissSound public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</playMissSound>
		<note public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* Note that has been missed</haxe_doc>
		</note>
		<score public="1"><x path="Int"/></score>
		<misses public="1"><x path="Int"/></misses>
		<muteVocals public="1"><x path="Bool"/></muteVocals>
		<healthGain public="1">
			<x path="Float"/>
			<haxe_doc>* The amount of health that'll be gained from missing that note. If called from `onPlayerMiss`, the value will be negative.</haxe_doc>
		</healthGain>
		<missSound public="1"><c path="String"/></missSound>
		<missVolume public="1"><x path="Float"/></missVolume>
		<ghostMiss public="1"><x path="Bool"/></ghostMiss>
		<gfSad public="1"><x path="Bool"/></gfSad>
		<gfSadAnim public="1"><c path="String"/></gfSadAnim>
		<forceGfAnim public="1"><x path="Bool"/></forceGfAnim>
		<forceAnim public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>* Whenever the animation should be forced to play (if it's null it will be forced based on the sprite's data xml, if it has one).</haxe_doc>
		</forceAnim>
		<animSuffix public="1">
			<c path="String"/>
			<haxe_doc>* Suffix of the animation. "miss" for miss notes, "-alt" for alt notes, "" for normal ones.</haxe_doc>
		</animSuffix>
		<character public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Character that pressed the note.</haxe_doc>
		</character>
		<characters public="1">
			<c path="Array"><c path="funkin.game.Character"/></c>
			<haxe_doc>* Characters that pressed the note.</haxe_doc>
		</characters>
		<playerID public="1">
			<x path="Int"/>
			<haxe_doc>* Whenever the Character is a player</haxe_doc>
		</playerID>
		<noteType public="1">
			<c path="String"/>
			<haxe_doc>* Note Type name (null if default note)</haxe_doc>
		</noteType>
		<direction public="1">
			<x path="Int"/>
			<haxe_doc>* Direction of the press (0 = Left, 1 = Down, 2 = Up, 3 = Right)</haxe_doc>
		</direction>
		<accuracy public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>* Accuracy gained from pressing this note. From 0 to 1. null means no accuracy is gained.</haxe_doc>
		</accuracy>
		<preventMissSound public="1" set="method" line="68">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the miss sound from played.</haxe_doc>
		</preventMissSound>
		<cancelMissSound public="1" set="method" line="73">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelMissSound>
		<preventResetCombo public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the combo from being reset.</haxe_doc>
		</preventResetCombo>
		<cancelResetCombo public="1" set="method" line="83">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelResetCombo>
		<preventStunned public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the default sing animation from being played.</haxe_doc>
		</preventStunned>
		<cancelStunned public="1" set="method" line="93">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelStunned>
		<preventAnim public="1" set="method" line="98">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the default sing animation from being played.</haxe_doc>
		</preventAnim>
		<cancelAnim public="1" set="method" line="103">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelAnim>
		<preventDeletion public="1" set="method" line="108">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the note from being deleted.</haxe_doc>
		</preventDeletion>
		<cancelDeletion public="1" set="method" line="112">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelDeletion>
		<preventVocalsUnmute public="1" set="method" line="117">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the vocals volume from being set to 1 after pressing the note.</haxe_doc>
		</preventVocalsUnmute>
		<cancelVocalsUnmute public="1" set="method" line="121">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelVocalsUnmute>
		<preventVocalsMute public="1" set="method" line="126">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prevents the vocals volume from being muted in case its a parameter of `onPlayerMiss`</haxe_doc>
		</preventVocalsMute>
		<cancelVocalsMute public="1" set="method" line="130">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</cancelVocalsMute>
		<get_character get="inline" set="null" line="133"><f a=""><c path="funkin.game.Character"/></f></get_character>
		<set_character set="method" line="134"><f a="char">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_character>
		<recycle public="1" set="method" line="6"><f a="note:score:misses:muteVocals:healthGain:missSound:missVolume:ghostMiss:gfSad:gfSadAnim:forceGfAnim:forceAnim:animSuffix:characters:playerID:noteType:direction:accuracy">
	<c path="funkin.game.Note"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Null"><x path="Bool"/></x>
	<c path="String"/>
	<c path="Array"><c path="funkin.game.Character"/></c>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Null"><x path="Float"/></x>
	<c path="funkin.backend.scripting.events.note.NoteMissEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.note.NoteUpdateEvent" params="" file="source/funkin/backend/scripting/events/note/NoteUpdateEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<__updateHitWindow public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__updateHitWindow>
		<__autoCPUHit public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__autoCPUHit>
		<__reposNote public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__reposNote>
		<note public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* Note that is being updated</haxe_doc>
		</note>
		<elapsed public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>* Time elapsed since last frame</haxe_doc>
		</elapsed>
		<strum public="1">
			<c path="funkin.game.Strum"/>
			<haxe_doc>* Note's strum (can be changed)</haxe_doc>
		</strum>
		<cancelWindowUpdate public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancels the hit window update.</haxe_doc>
		</cancelWindowUpdate>
		<preventWindowUpdate public="1" set="method" line="31">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</preventWindowUpdate>
		<cancelAutoCPUHit public="1" set="method" line="36">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancels the automatic CPU hit.</haxe_doc>
		</cancelAutoCPUHit>
		<preventAutoCPUHit public="1" set="method" line="39">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</preventAutoCPUHit>
		<cancelPositionUpdate public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancels the note position update (note will freeze).</haxe_doc>
		</cancelPositionUpdate>
		<preventPositionUpdate public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</preventPositionUpdate>
		<recycle public="1" set="method" line="6"><f a="note:elapsed:strum">
	<c path="funkin.game.Note"/>
	<x path="Null"><x path="Float"/></x>
	<c path="funkin.game.Strum"/>
	<c path="funkin.backend.scripting.events.note.NoteUpdateEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.note.SimpleNoteEvent" params="" file="source/funkin/backend/scripting/events/note/SimpleNoteEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<note public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>Note that is affected.</haxe_doc>
		</note>
		<recycle public="1" set="method" line="5"><f a="note">
	<c path="funkin.game.Note"/>
	<c path="funkin.backend.scripting.events.note.SimpleNoteEvent"/>
</f></recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.note.StrumCreationEvent" params="" file="source/funkin/backend/scripting/events/note/StrumCreationEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<__doAnimation public="1" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__doAnimation>
		<strum public="1">
			<c path="funkin.game.Strum"/>
			<haxe_doc>* The strum that is being created</haxe_doc>
		</strum>
		<player public="1">
			<x path="Int"/>
			<haxe_doc>s
	 * Player ID</haxe_doc>
		</player>
		<strumID public="1">
			<x path="Int"/>
			<haxe_doc>* Strum ID, for the sprite.</haxe_doc>
		</strumID>
		<animPrefix public="1">
			<c path="String"/>
			<haxe_doc>* Animation prefix (`left` = `arrowLEFT`, `left press`, `left confirm`).</haxe_doc>
		</animPrefix>
		<sprite public="1" expr="&quot;game/notes/default&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"game/notes/default"</e></m></meta>
			<haxe_doc>* Sprite path, in case you only want to change the sprite.</haxe_doc>
		</sprite>
		<cancelAnimation public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancels the animation that makes the strum "land" in the strumline.</haxe_doc>
		</cancelAnimation>
		<preventAnimation public="1" set="method" line="38">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</preventAnimation>
		<recycle public="1" set="method" line="5">
			<f a="strum:player:strumID:animPrefix:?sprite" v="::::&quot;game/notes/default&quot;">
				<c path="funkin.game.Strum"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<c path="funkin.backend.scripting.events.note.StrumCreationEvent"/>
			</f>
			<meta><m n=":value"><e>{ sprite : "game/notes/default" }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.shader.ShaderProcessEvent" params="" file="source/funkin/backend/scripting/events/shader/ShaderProcessEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<source public="1"><c path="String"/></source>
		<storageType public="1"><c path="String"/></storageType>
		<recycle public="1" set="method" line="3"><f a="source:storageType">
	<c path="String"/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.shader.ShaderProcessEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.soundtray.SoundTrayShowEvent" params="" file="source/funkin/backend/scripting/events/soundtray/SoundTrayShowEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<up public="1"><x path="Bool"/></up>
		<recycle public="1" set="method" line="3"><f a="up">
	<x path="Bool"/>
	<c path="funkin.backend.scripting.events.soundtray.SoundTrayShowEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.soundtray.SoundTrayTextEvent" params="" file="source/funkin/backend/scripting/events/soundtray/SoundTrayTextEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<checkIfNull public="1"><x path="Bool"/></checkIfNull>
		<reloadDefaultTextFormat public="1"><x path="Bool"/></reloadDefaultTextFormat>
		<displayTxt public="1"><c path="String"/></displayTxt>
		<y public="1"><x path="Float"/></y>
		<recycle public="1" set="method" line="3"><f a="checkIfNull:reloadDefaultTextFormat:displayTxt:y">
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Float"/>
	<c path="funkin.backend.scripting.events.soundtray.SoundTrayTextEvent"/>
</f></recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.splash.SplashShowEvent" params="" file="source/funkin/backend/scripting/events/splash/SplashShowEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<splashName public="1">
			<c path="String"/>
			<haxe_doc>Splash name/type</haxe_doc>
		</splashName>
		<splash public="1">
			<c path="funkin.game.Splash"/>
			<haxe_doc>Splash that is shown</haxe_doc>
		</splash>
		<strum public="1">
			<c path="funkin.game.Strum"/>
			<haxe_doc>Strum that the splash is shown on</haxe_doc>
		</strum>
		<group public="1">
			<c path="funkin.game.SplashGroup"/>
			<haxe_doc>Splash group that the splash is from</haxe_doc>
		</group>
		<recycle public="1" set="method" line="7"><f a="splashName:splash:strum:group">
	<c path="String"/>
	<c path="funkin.game.Splash"/>
	<c path="funkin.game.Strum"/>
	<c path="funkin.game.SplashGroup"/>
	<c path="funkin.backend.scripting.events.splash.SplashShowEvent"/>
</f></recycle>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<abstract path="funkin.backend.scripting.events.sprite.PlayAnimContext" params="" file="source/funkin/backend/scripting/events/sprite/PlayAnimContext.hx">
		<this><c path="String"/></this>
		<haxe_doc>Contains all contexts possible for `PlayAnimEvent`.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.scripting.events.sprite._PlayAnimContext.PlayAnimContext_Impl_" params="" file="source/funkin/backend/scripting/events/sprite/PlayAnimContext.hx" private="1" module="funkin.backend.scripting.events.sprite.PlayAnimContext" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast null" line="11" static="1">
		<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
		<meta>
			<m n=":value"><e>cast null</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>No context was given for the animation.
		The character won't dance until the animation is finished</haxe_doc>
	</NONE>
	<SING public="1" get="inline" set="null" expr="cast &quot;SING&quot;" line="17" static="1">
		<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
		<meta>
			<m n=":value"><e>cast "SING"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Whenever a note is hit and a sing animation will be played.
		The character will only dance after their holdTime is reached.</haxe_doc>
	</SING>
	<DANCE public="1" get="inline" set="null" expr="cast &quot;DANCE&quot;" line="23" static="1">
		<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
		<meta>
			<m n=":value"><e>cast "DANCE"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Whenever a dance animation is played.
		The character's dancing wont be blocked.</haxe_doc>
	</DANCE>
	<MISS public="1" get="inline" set="null" expr="cast &quot;MISS&quot;" line="29" static="1">
		<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
		<meta>
			<m n=":value"><e>cast "MISS"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Whenever a note is missed and a miss animation will be played.
		Only for scripting, since it has the same effects as SING.</haxe_doc>
	</MISS>
	<LOCK public="1" get="inline" set="null" expr="cast &quot;LOCK&quot;" line="35" static="1">
		<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
		<meta>
			<m n=":value"><e>cast "LOCK"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Locks the character's animation.
		Prevents the character from dancing, even if the animation ended.</haxe_doc>
	</LOCK>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.scripting.events.sprite._PlayAnimContext.PlayAnimContext_Impl_" params="" file="source/funkin/backend/scripting/events/sprite/PlayAnimContext.hx" private="1" module="funkin.backend.scripting.events.sprite.PlayAnimContext" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast null" line="11" static="1">
			<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
			<meta>
				<m n=":value"><e>cast null</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>No context was given for the animation.
		The character won't dance until the animation is finished</haxe_doc>
		</NONE>
		<SING public="1" get="inline" set="null" expr="cast &quot;SING&quot;" line="17" static="1">
			<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
			<meta>
				<m n=":value"><e>cast "SING"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Whenever a note is hit and a sing animation will be played.
		The character will only dance after their holdTime is reached.</haxe_doc>
		</SING>
		<DANCE public="1" get="inline" set="null" expr="cast &quot;DANCE&quot;" line="23" static="1">
			<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
			<meta>
				<m n=":value"><e>cast "DANCE"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Whenever a dance animation is played.
		The character's dancing wont be blocked.</haxe_doc>
		</DANCE>
		<MISS public="1" get="inline" set="null" expr="cast &quot;MISS&quot;" line="29" static="1">
			<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
			<meta>
				<m n=":value"><e>cast "MISS"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Whenever a note is missed and a miss animation will be played.
		Only for scripting, since it has the same effects as SING.</haxe_doc>
		</MISS>
		<LOCK public="1" get="inline" set="null" expr="cast &quot;LOCK&quot;" line="35" static="1">
			<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
			<meta>
				<m n=":value"><e>cast "LOCK"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Locks the character's animation.
		Prevents the character from dancing, even if the animation ended.</haxe_doc>
		</LOCK>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.scripting.events.sprite.PlayAnimEvent" params="" file="source/funkin/backend/scripting/events/sprite/PlayAnimEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<animName public="1">
			<c path="String"/>
			<haxe_doc>Name of the animation that's going to be played.</haxe_doc>
		</animName>
		<force public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>Whenever the animation will be forced or not (if it's null it will be forced based on the sprite's data xml, if it has one).</haxe_doc>
		</force>
		<reverse public="1">
			<x path="Bool"/>
			<haxe_doc>Whenever the animation will play in reverse or not</haxe_doc>
		</reverse>
		<startingFrame public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>The frame at which the animation will start playing</haxe_doc>
		</startingFrame>
		<context public="1">
			<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
			<haxe_doc>Context of the animation</haxe_doc>
		</context>
		<recycle public="1" set="method" line="3">
			<f a="animName:force:reverse:?startingFrame:context" v=":::0:">
				<c path="String"/>
				<x path="Null"><x path="Bool"/></x>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
				<c path="funkin.backend.scripting.events.sprite.PlayAnimEvent"/>
			</f>
			<meta><m n=":value"><e>{ startingFrame : 0 }</e></m></meta>
		</recycle>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.stage.StageNodeEvent" params="" file="source/funkin/backend/scripting/events/stage/StageNodeEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<stage public="1">
			<c path="funkin.game.Stage"/>
			<haxe_doc>* The stage instance</haxe_doc>
		</stage>
		<node public="1">
			<x path="haxe.xml.Access"/>
			<haxe_doc>* The node which is currently being parsed</haxe_doc>
		</node>
		<sprite public="1">
			<d/>
			<haxe_doc>* The sprite which was parsed</haxe_doc>
		</sprite>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the node, quicker access than e.node.name</haxe_doc>
		</name>
		<recycle public="1" set="method" line="6"><f a="stage:node:sprite:name">
	<c path="funkin.game.Stage"/>
	<x path="haxe.xml.Access"/>
	<d/>
	<c path="String"/>
	<c path="funkin.backend.scripting.events.stage.StageNodeEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.scripting.events.stage.StageXMLEvent" params="" file="source/funkin/backend/scripting/events/stage/StageXMLEvent.hx" final="1">
		<extends path="funkin.backend.scripting.events.CancellableEvent"/>
		<stage public="1">
			<c path="funkin.game.Stage"/>
			<haxe_doc>* The stage instance</haxe_doc>
		</stage>
		<xml public="1">
			<x path="haxe.xml.Access"/>
			<haxe_doc>* The xml</haxe_doc>
		</xml>
		<elems public="1">
			<c path="Array"><x path="haxe.xml.Access"/></c>
			<haxe_doc>* The object which was parsed</haxe_doc>
		</elems>
		<recycle public="1" set="method" line="6"><f a="stage:xml:elems">
	<c path="funkin.game.Stage"/>
	<x path="haxe.xml.Access"/>
	<c path="Array"><x path="haxe.xml.Access"/></c>
	<c path="funkin.backend.scripting.events.stage.StageXMLEvent"/>
</f></recycle>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
			<m n=":autoBuild"><e>funkin.backend.system.macros.EventMacro.build()</e></m>
		</meta>
	</class>
	<typedef path="funkin.backend.shaders.BlendModeShader" params="" file="source/funkin/backend/shaders/BlendModeEffect.hx" module="funkin.backend.shaders.BlendModeEffect">
		<a><uBlendColor><c path="openfl.display.ShaderParameter_Float"/></uBlendColor></a>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<class path="funkin.backend.shaders.BlendModeEffect" params="" file="source/funkin/backend/shaders/BlendModeEffect.hx">
		<shader public="1" set="null"><t path="funkin.backend.shaders.BlendModeShader"/></shader>
		<color public="1" set="accessor">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":isVar"/></meta>
		</color>
		<set_color set="method" line="28"><f a="color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_color>
		<new public="1" set="method" line="21"><f a="shader:color">
	<t path="funkin.backend.shaders.BlendModeShader"/>
	<x path="flixel.util.FlxColor"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="funkin.backend.shaders.FunkinShader" params="" file="source/funkin/backend/shaders/FunkinShader.hx">
		<extends path="flixel.graphics.tile.FlxGraphicsShader"/>
		<implements path="hscript.IHScriptCustomBehaviour"/>
		<__instanceFields expr="Type.getInstanceFields(FunkinShader)" line="23" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>Type.getInstanceFields(FunkinShader)</e></m></meta>
		</__instanceFields>
		<FRAGMENT_SHADER expr="0" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FRAGMENT_SHADER>
		<VERTEX_SHADER expr="1" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</VERTEX_SHADER>
		<IMPORT_REGEX expr="~/#import\s+&lt;(.*)&gt;/" line="57" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/#import\s+&lt;(.*)&gt;/</e></m></meta>
		</IMPORT_REGEX>
		<ERROR_POS_REGEX expr="~/(\d+):(\d+): (.*)/" line="78" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/(\d+):(\d+): (.*)/</e></m></meta>
		</ERROR_POS_REGEX>
		<ERROR_REGEX expr="~/ERROR: (\d+):(\d+): (.*)/" line="79" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/ERROR: (\d+):(\d+): (.*)/</e></m></meta>
		</ERROR_REGEX>
		<ERROR_REGEX_2 expr="~/(\d+)\((\d+)\) : error ([^:]+): (.*)/" line="80" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/(\d+)\((\d+)\) : error ([^:]+): (.*)/</e></m></meta>
		</ERROR_REGEX_2>
		<onGLUpdate public="1" expr="new FlxTypedSignal&lt;Void&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a=""><x path="Void"/></f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;Void&gt;()</e></m></meta>
		</onGLUpdate>
		<onProcessGLData public="1" expr="new FlxTypedSignal&lt;String -&gt; String&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;String -&gt; String&gt;()</e></m></meta>
		</onProcessGLData>
		<glslVer public="1" expr="Flags.DEFAULT_GLSL_VERSION">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_GLSL_VERSION</e></m></meta>
		</glslVer>
		<fileName public="1" expr="&quot;FunkinShader&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"FunkinShader"</e></m></meta>
		</fileName>
		<fragFileName public="1" expr="&quot;FunkinShader&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"FunkinShader"</e></m></meta>
		</fragFileName>
		<vertFileName public="1" expr="&quot;FunkinShader&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"FunkinShader"</e></m></meta>
		</vertFileName>
		<shaderPrefix public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</shaderPrefix>
		<fragmentPrefix public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</fragmentPrefix>
		<vertexPrefix public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</vertexPrefix>
		<processImports set="method" line="60"><f a="value:type">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></processImports>
		<__createGLShader set="method" line="82" override="1">
			<f a="source:type">
				<c path="String"/>
				<x path="Int"/>
				<t path="openfl.display3D._internal.GLShader"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__createGLShader>
		<__createGLProgram set="method" line="164" override="1">
			<f a="vertexSource:fragmentSource">
				<c path="String"/>
				<c path="String"/>
				<t path="openfl.display3D._internal.GLProgram"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__createGLProgram>
		<glRawFragmentSource><c path="String"/></glRawFragmentSource>
		<glRawVertexSource><c path="String"/></glRawVertexSource>
		<set_glFragmentSource set="method" line="216" override="1">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_glFragmentSource>
		<set_glVertexSource set="method" line="231" override="1">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_glVertexSource>
		<__updateGL set="method" line="256" override="1"><f a=""><x path="Void"/></f></__updateGL>
		<__initGL set="method" line="262" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__initGL>
		<__cancelNextProcessGLData expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__cancelNextProcessGLData>
		<__processGLData set="method" line="359" override="1">
			<f a="source:storageType">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__processGLData>
		<registerParameter set="method" line="393"><f a="name:type:isUniform">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></registerParameter>
		<hget public="1" set="method" line="525"><f a="name">
	<c path="String"/>
	<d/>
</f></hget>
		<hset public="1" set="method" line="548"><f a="name:val">
	<c path="String"/>
	<d/>
	<d/>
</f></hset>
		<new public="1" set="method" line="46">
			<f a="frag:vert:?glslVer" v="::null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ glslVer : null }</e></m></meta>
			<haxe_doc>* Creates a new shader from the specified fragment and vertex source.
	 * Accepts `#pragma header`.
	 * @param frag Fragment source (pass `null` to use default)
	 * @param vert Vertex source (pass `null` to use default)
	 * @param glslVer Version of GLSL to use (defaults to 120)</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":access"><e>openfl.display3D.Context3D</e></m>
			<m n=":access"><e>openfl.display3D.Program3D</e></m>
			<m n=":access"><e>openfl.display.ShaderInput</e></m>
			<m n=":access"><e>openfl.display.ShaderParameter</e></m>
		</meta>
	</class>
	<class path="funkin.backend.shaders.CustomShader" params="" file="source/funkin/backend/shaders/CustomShader.hx">
		<extends path="funkin.backend.shaders.FunkinShader"/>
		<path public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</path>
		<new public="1" set="method" line="22">
			<f a="name:?glslVersion" v=":null">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ glslVersion : null }</e></m></meta>
			<haxe_doc>* Creates a new custom shader
	 * @param name Name of the frag and vert files.
	 * @param glslVersion GLSL version to use. Defaults to `120`.</haxe_doc>
		</new>
		<haxe_doc>* Class for custom shaders.
 *
 * To create one, create a `shaders` folder in your assets/mod folder, then add a file named `my-shader.frag` or/and `my-shader.vert`.
 *
 * Non-existent shaders will only load the default one, and throw a warning in the console.
 *
 * To access the shader's uniform variables, use `shader.variable`</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.shaders.ShaderTemplates" params="" file="source/funkin/backend/shaders/FunkinShader.hx" module="funkin.backend.shaders.FunkinShader">
		<fragHeader final="1" public="1" set="null" expr="&quot;varying float openfl_Alphav;\r\nvarying vec4 openfl_ColorMultiplierv;\r\nvarying vec4 openfl_ColorOffsetv;\r\nvarying vec2 openfl_TextureCoordv;\r\n\r\nuniform bool openfl_HasColorTransform;\r\nuniform vec2 openfl_TextureSize;\r\nuniform sampler2D bitmap;\r\n\r\nuniform bool hasTransform;\r\nuniform bool hasColorTransform;\r\n\r\nvec4 applyFlixelEffects(vec4 color) {\r\n\tif(!hasTransform) {\r\n\t\treturn color;\r\n\t}\r\n\r\n\tif(color.a == 0.0) {\r\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\r\n\t}\r\n\r\n\tif(!hasColorTransform) {\r\n\t\treturn color * openfl_Alphav;\r\n\t}\r\n\r\n\tcolor.rgb = color.rgb / color.a;\r\n\tcolor = clamp(openfl_ColorOffsetv + (color * openfl_ColorMultiplierv), 0.0, 1.0);\r\n\r\n\tif(color.a &gt; 0.0) {\r\n\t\treturn vec4(color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\r\n\t}\r\n\treturn vec4(0.0, 0.0, 0.0, 0.0);\r\n}\r\n\r\nvec4 flixel_texture2D(sampler2D bitmap, vec2 coord) {\r\n\tvec4 color = texture2D(bitmap, coord);\r\n\treturn applyFlixelEffects(color);\r\n}\r\n\r\nuniform vec4 _camSize;\r\n\r\nfloat map(float value, float min1, float max1, float min2, float max2) {\r\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r\n}\r\n\r\nvec2 getCamPos(vec2 pos) {\r\n\tvec4 size = _camSize / vec4(openfl_TextureSize, openfl_TextureSize);\r\n\treturn vec2(map(pos.x, size.x, size.x + size.z, 0.0, 1.0), map(pos.y, size.y, size.y + size.w, 0.0, 1.0));\r\n}\r\nvec2 camToOg(vec2 pos) {\r\n\tvec4 size = _camSize / vec4(openfl_TextureSize, openfl_TextureSize);\r\n\treturn vec2(map(pos.x, 0.0, 1.0, size.x, size.x + size.z), map(pos.y, 0.0, 1.0, size.y, size.y + size.w));\r\n}\r\nvec4 textureCam(sampler2D bitmap, vec2 pos) {\r\n\treturn flixel_texture2D(bitmap, camToOg(pos));\r\n}&quot;" line="604" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"varying float openfl_Alphav;\r\nvarying vec4 openfl_ColorMultiplierv;\r\nvarying vec4 openfl_ColorOffsetv;\r\nvarying vec2 openfl_TextureCoordv;\r\n\r\nuniform bool openfl_HasColorTransform;\r\nuniform vec2 openfl_TextureSize;\r\nuniform sampler2D bitmap;\r\n\r\nuniform bool hasTransform;\r\nuniform bool hasColorTransform;\r\n\r\nvec4 applyFlixelEffects(vec4 color) {\r\n\tif(!hasTransform) {\r\n\t\treturn color;\r\n\t}\r\n\r\n\tif(color.a == 0.0) {\r\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\r\n\t}\r\n\r\n\tif(!hasColorTransform) {\r\n\t\treturn color * openfl_Alphav;\r\n\t}\r\n\r\n\tcolor.rgb = color.rgb / color.a;\r\n\tcolor = clamp(openfl_ColorOffsetv + (color * openfl_ColorMultiplierv), 0.0, 1.0);\r\n\r\n\tif(color.a &gt; 0.0) {\r\n\t\treturn vec4(color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\r\n\t}\r\n\treturn vec4(0.0, 0.0, 0.0, 0.0);\r\n}\r\n\r\nvec4 flixel_texture2D(sampler2D bitmap, vec2 coord) {\r\n\tvec4 color = texture2D(bitmap, coord);\r\n\treturn applyFlixelEffects(color);\r\n}\r\n\r\nuniform vec4 _camSize;\r\n\r\nfloat map(float value, float min1, float max1, float min2, float max2) {\r\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r\n}\r\n\r\nvec2 getCamPos(vec2 pos) {\r\n\tvec4 size = _camSize / vec4(openfl_TextureSize, openfl_TextureSize);\r\n\treturn vec2(map(pos.x, size.x, size.x + size.z, 0.0, 1.0), map(pos.y, size.y, size.y + size.w, 0.0, 1.0));\r\n}\r\nvec2 camToOg(vec2 pos) {\r\n\tvec4 size = _camSize / vec4(openfl_TextureSize, openfl_TextureSize);\r\n\treturn vec2(map(pos.x, 0.0, 1.0, size.x, size.x + size.z), map(pos.y, 0.0, 1.0, size.y, size.y + size.w));\r\n}\r\nvec4 textureCam(sampler2D bitmap, vec2 pos) {\r\n\treturn flixel_texture2D(bitmap, camToOg(pos));\r\n}"</e></m></meta>
		</fragHeader>
		<fragBody final="1" public="1" set="null" expr="&quot;gl_FragColor = flixel_texture2D(bitmap, openfl_TextureCoordv);&quot;" line="661" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"gl_FragColor = flixel_texture2D(bitmap, openfl_TextureCoordv);"</e></m></meta>
		</fragBody>
		<vertHeader final="1" public="1" set="null" expr="&quot;attribute float openfl_Alpha;\r\nattribute vec4 openfl_ColorMultiplier;\r\nattribute vec4 openfl_ColorOffset;\r\nattribute vec4 openfl_Position;\r\nattribute vec2 openfl_TextureCoord;\r\n\r\nvarying float openfl_Alphav;\r\nvarying vec4 openfl_ColorMultiplierv;\r\nvarying vec4 openfl_ColorOffsetv;\r\nvarying vec2 openfl_TextureCoordv;\r\n\r\nuniform mat4 openfl_Matrix;\r\nuniform bool openfl_HasColorTransform;\r\nuniform vec2 openfl_TextureSize;\r\n\r\nattribute float alpha;\r\nattribute vec4 colorMultiplier;\r\nattribute vec4 colorOffset;\r\nuniform bool hasColorTransform;&quot;" line="662" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"attribute float openfl_Alpha;\r\nattribute vec4 openfl_ColorMultiplier;\r\nattribute vec4 openfl_ColorOffset;\r\nattribute vec4 openfl_Position;\r\nattribute vec2 openfl_TextureCoord;\r\n\r\nvarying float openfl_Alphav;\r\nvarying vec4 openfl_ColorMultiplierv;\r\nvarying vec4 openfl_ColorOffsetv;\r\nvarying vec2 openfl_TextureCoordv;\r\n\r\nuniform mat4 openfl_Matrix;\r\nuniform bool openfl_HasColorTransform;\r\nuniform vec2 openfl_TextureSize;\r\n\r\nattribute float alpha;\r\nattribute vec4 colorMultiplier;\r\nattribute vec4 colorOffset;\r\nuniform bool hasColorTransform;"</e></m></meta>
		</vertHeader>
		<vertBody final="1" public="1" set="null" expr="&quot;openfl_Alphav = openfl_Alpha;\r\nopenfl_TextureCoordv = openfl_TextureCoord;\r\n\r\nif(openfl_HasColorTransform) {\r\n\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\r\n\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\r\n}\r\n\r\nopenfl_Alphav = openfl_Alpha * alpha;\r\n\r\nif(hasColorTransform) {\r\n\topenfl_ColorOffsetv = colorOffset / 255.0;\r\n\topenfl_ColorMultiplierv = colorMultiplier;\r\n}\r\n\r\ngl_Position = openfl_Matrix * openfl_Position;&quot;" line="682" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"openfl_Alphav = openfl_Alpha;\r\nopenfl_TextureCoordv = openfl_TextureCoord;\r\n\r\nif(openfl_HasColorTransform) {\r\n\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\r\n\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\r\n}\r\n\r\nopenfl_Alphav = openfl_Alpha * alpha;\r\n\r\nif(hasColorTransform) {\r\n\topenfl_ColorOffsetv = colorOffset / 255.0;\r\n\topenfl_ColorMultiplierv = colorMultiplier;\r\n}\r\n\r\ngl_Position = openfl_Matrix * openfl_Position;"</e></m></meta>
		</vertBody>
		<vertBackCompatVarList final="1" public="1" set="null" expr="[~/attribute float alpha/, ~/attribute vec4 colorMultiplier/, ~/attribute vec4 colorOffset/, ~/uniform bool hasColorTransform/]" line="700" static="1">
			<c path="Array"><c path="EReg"/></c>
			<meta><m n=":value"><e>[~/attribute float alpha/, ~/attribute vec4 colorMultiplier/, ~/attribute vec4 colorOffset/, ~/uniform bool hasColorTransform/]</e></m></meta>
		</vertBackCompatVarList>
		<vertHeaderBackCompat final="1" public="1" set="null" expr="&quot;attribute float openfl_Alpha;\r\nattribute vec4 openfl_ColorMultiplier;\r\nattribute vec4 openfl_ColorOffset;\r\nattribute vec4 openfl_Position;\r\nattribute vec2 openfl_TextureCoord;\r\n\r\nvarying float openfl_Alphav;\r\nvarying vec4 openfl_ColorMultiplierv;\r\nvarying vec4 openfl_ColorOffsetv;\r\nvarying vec2 openfl_TextureCoordv;\r\n\r\nuniform mat4 openfl_Matrix;\r\nuniform bool openfl_HasColorTransform;\r\nuniform vec2 openfl_TextureSize;&quot;" line="707" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"attribute float openfl_Alpha;\r\nattribute vec4 openfl_ColorMultiplier;\r\nattribute vec4 openfl_ColorOffset;\r\nattribute vec4 openfl_Position;\r\nattribute vec2 openfl_TextureCoord;\r\n\r\nvarying float openfl_Alphav;\r\nvarying vec4 openfl_ColorMultiplierv;\r\nvarying vec4 openfl_ColorOffsetv;\r\nvarying vec2 openfl_TextureCoordv;\r\n\r\nuniform mat4 openfl_Matrix;\r\nuniform bool openfl_HasColorTransform;\r\nuniform vec2 openfl_TextureSize;"</e></m></meta>
		</vertHeaderBackCompat>
		<vertBodyBackCompat final="1" public="1" set="null" expr="&quot;openfl_Alphav = openfl_Alpha;\r\nopenfl_TextureCoordv = openfl_TextureCoord;\r\n\r\nif(openfl_HasColorTransform) {\r\n\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\r\n\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\r\n}\r\n\r\ngl_Position = openfl_Matrix * openfl_Position;&quot;" line="722" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"openfl_Alphav = openfl_Alpha;\r\nopenfl_TextureCoordv = openfl_TextureCoord;\r\n\r\nif(openfl_HasColorTransform) {\r\n\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\r\n\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\r\n}\r\n\r\ngl_Position = openfl_Matrix * openfl_Position;"</e></m></meta>
		</vertBodyBackCompat>
		<defaultVertexSource final="1" public="1" set="null" expr="&quot;#pragma header\r\n\r\nvoid main(void) {\r\n\t#pragma body\r\n}&quot;" line="732" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"#pragma header\r\n\r\nvoid main(void) {\r\n\t#pragma body\r\n}"</e></m></meta>
		</defaultVertexSource>
		<defaultFragmentSource final="1" public="1" set="null" expr="&quot;#pragma header\r\n\r\nvoid main(void) {\r\n\t#pragma body\r\n}&quot;" line="738" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"#pragma header\r\n\r\nvoid main(void) {\r\n\t#pragma body\r\n}"</e></m></meta>
		</defaultFragmentSource>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.shaders.ShaderTypeException" params="" file="source/funkin/backend/shaders/FunkinShader.hx" module="funkin.backend.shaders.FunkinShader">
		<extends path="haxe.Exception"/>
		<has><x path="Class"><d/></x></has>
		<want><x path="Class"><d/></x></want>
		<name><c path="String"/></name>
		<new public="1" set="method" line="750"><f a="name:has:want">
	<c path="String"/>
	<x path="Class"><d/></x>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.shaders.ShaderErrorPosition" params="" file="source/funkin/backend/shaders/FunkinShader.hx" module="funkin.backend.shaders.FunkinShader">
		<column public="1"><x path="Int"/></column>
		<line public="1"><x path="Int"/></line>
		<message public="1"><c path="String"/></message>
		<new public="1" set="method" line="763"><f a="line:column:message">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.shaders.OverlayShader" params="" file="source/funkin/backend/shaders/OverlayShader.hx">
		<extends path="flixel.graphics.tile.FlxGraphicsShader"/>
		<uBlendColor public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</uBlendColor>
		<new public="1" set="method" line="31">
			<f a=""><x path="Void"/></f>
			<meta><m n=":glFragmentSource"><e>"\r\n#pragma header\r\nuniform vec4 uBlendColor;\r\n\r\nvec3 blendLighten(base:Vec3, blend:Vec3) : Vec3 {\r\n\treturn mix(\r\n\t\t1.0 - 2.0 * (1.0 - base) * (1.0 - blend),\r\n\t\t2.0 * base * blend,\r\n\t\tstep( base, vec3(0.5) )\r\n\t);\r\n}\r\n\r\nvec4 blendLighten(vec4 base, vec4 blend, float opacity)\r\n{\r\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\r\n}\r\n\r\nvoid main()\r\n{\r\n\tvec4 base = texture2D(bitmap, openfl_TextureCoordv);\r\n\tgl_FragColor = blendLighten(base, uBlendColor, uBlendColor.a);\r\n}"</e></m></meta>
		</new>
		<meta>
			<m n=":build"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="funkin.backend.shaders.FieldInfo" params="" file="source/funkin/backend/shaders/ScriptableShader.hx" module="funkin.backend.shaders.ScriptableShader">
		<get public="1"><f a=""><d/></f></get>
		<set public="1"><f a="">
	<d/>
	<d/>
</f></set>
		<new public="1" set="method" line="9">
			<f a="get:set">
				<f a=""><d/></f>
				<f a="">
					<d/>
					<d/>
				</f>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="funkin.backend.shaders.ScriptableShader" params="" file="source/funkin/backend/shaders/ScriptableShader.hx">
		<extends path="flixel.FlxBasic"/>
		<implements path="hscript.IHScriptCustomBehaviour"/>
		<__instanceFields expr="Type.getInstanceFields(ScriptableShader)" line="16" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>Type.getInstanceFields(ScriptableShader)</e></m></meta>
		</__instanceFields>
		<shader public="1"><c path="funkin.backend.shaders.FunkinShader"/></shader>
		<script public="1"><c path="funkin.backend.scripting.Script"/></script>
		<fields expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.backend.shaders.FieldInfo"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</fields>
		<registerField set="method" line="62"><f a="name:get:set">
	<c path="String"/>
	<f a=""><d/></f>
	<f a="">
		<d/>
		<d/>
	</f>
	<x path="Void"/>
</f></registerField>
		<update public="1" set="method" line="71" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="72" override="1"><f a=""><x path="Void"/></f></draw>
		<updateGL public="1" set="method" line="73"><f a=""><x path="Void"/></f></updateGL>
		<processGLData public="1" set="method" line="74"><f a="source:storageType">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></processGLData>
		<destroy public="1" set="method" line="82" override="1"><f a=""><x path="Void"/></f></destroy>
		<hget public="1" set="method" line="93"><f a="name">
	<c path="String"/>
	<d/>
</f></hget>
		<hset public="1" set="method" line="101"><f a="name:val">
	<c path="String"/>
	<d/>
	<d/>
</f></hset>
		<new public="1" set="method" line="23"><f a="shader:?scriptName:?parentScriptPack">
	<c path="funkin.backend.shaders.FunkinShader"/>
	<c path="String"/>
	<c path="funkin.backend.scripting.ScriptPack"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":access"><e>funkin.backend.shaders.FunkinShader</e></m></meta>
	</class>
	<enum path="funkin.backend.shaders.WiggleEffectType" params="" file="source/funkin/backend/shaders/WiggleEffect.hx" module="funkin.backend.shaders.WiggleEffect">
		<DREAMY/>
		<WAVY/>
		<HEAT_WAVE_HORIZONTAL/>
		<HEAT_WAVE_VERTICAL/>
		<FLAG/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</enum>
	<class path="funkin.backend.shaders.WiggleEffect" params="" file="source/funkin/backend/shaders/WiggleEffect.hx">
		<shader public="1" set="null" expr="new WiggleShader()">
			<c path="funkin.backend.shaders.WiggleShader"/>
			<meta><m n=":value"><e>new WiggleShader()</e></m></meta>
		</shader>
		<effectType public="1" set="accessor" expr="DREAMY">
			<e path="funkin.backend.shaders.WiggleEffectType"/>
			<meta><m n=":value"><e>DREAMY</e></m></meta>
		</effectType>
		<waveSpeed public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</waveSpeed>
		<waveFrequency public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</waveFrequency>
		<waveAmplitude public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</waveAmplitude>
		<update public="1" set="method" line="31"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<set_effectType set="method" line="36"><f a="v">
	<e path="funkin.backend.shaders.WiggleEffectType"/>
	<e path="funkin.backend.shaders.WiggleEffectType"/>
</f></set_effectType>
		<set_waveSpeed set="method" line="43"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_waveSpeed>
		<set_waveFrequency set="method" line="50"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_waveFrequency>
		<set_waveAmplitude set="method" line="57"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_waveAmplitude>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="funkin.backend.shaders.WiggleShader" params="" file="source/funkin/backend/shaders/WiggleEffect.hx" module="funkin.backend.shaders.WiggleEffect">
		<extends path="flixel.graphics.tile.FlxGraphicsShader"/>
		<tx public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</tx>
		<uTime public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</uTime>
		<effectType public="1">
			<c path="openfl.display.ShaderParameter_Int"/>
			<meta><m n=":keep"/></meta>
		</effectType>
		<uSpeed public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</uSpeed>
		<uFrequency public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</uFrequency>
		<uWaveAmplitude public="1">
			<c path="openfl.display.ShaderParameter_Float"/>
			<meta><m n=":keep"/></meta>
		</uWaveAmplitude>
		<new public="1" set="method" line="133">
			<f a=""><x path="Void"/></f>
			<meta><m n=":glFragmentSource"><e>"\r\n#pragma header\r\n//uniform float tx, ty; // x,y waves phase\r\nuniform float uTime;\r\n\r\nconst int EFFECT_TYPE_DREAMY = 0;\r\nconst int EFFECT_TYPE_WAVY = 1;\r\nconst int EFFECT_TYPE_HEAT_WAVE_HORIZONTAL = 2;\r\nconst int EFFECT_TYPE_HEAT_WAVE_VERTICAL = 3;\r\nconst int EFFECT_TYPE_FLAG = 4;\r\n\r\nuniform int effectType;\r\n\r\n/**\r\n* How fast the waves move over time\r\n*/\r\nuniform float uSpeed;\r\n\r\n/**\r\n* Number of waves over time\r\n*/\r\nuniform float uFrequency;\r\n\r\n/**\r\n* How much the pixels are going to stretch over the waves\r\n*/\r\nuniform float uWaveAmplitude;\r\n\r\nvec2 sineWave(vec2 pt)\r\n{\r\n\tfloat x = 0.0;\r\n\tfloat y = 0.0;\r\n\r\n\tif (effectType == EFFECT_TYPE_DREAMY)\r\n\t{\r\n\t\tfloat offsetX = sin(pt.y * uFrequency + uTime * uSpeed) * uWaveAmplitude;\r\n\t\tpt.x += offsetX; // * (pt.y - 1.0); // &lt;- Uncomment to stop bottom part of the screen from moving\r\n\t}\r\n\telse if (effectType == EFFECT_TYPE_WAVY)\r\n\t{\r\n\t\tfloat offsetY = sin(pt.x * uFrequency + uTime * uSpeed) * uWaveAmplitude;\r\n\t\tpt.y += offsetY; // * (pt.y - 1.0); // &lt;- Uncomment to stop bottom part of the screen from moving\r\n\t}\r\n\telse if (effectType == EFFECT_TYPE_HEAT_WAVE_HORIZONTAL)\r\n\t{\r\n\t\tx = sin(pt.x * uFrequency + uTime * uSpeed) * uWaveAmplitude;\r\n\t}\r\n\telse if (effectType == EFFECT_TYPE_HEAT_WAVE_VERTICAL)\r\n\t{\r\n\t\ty = sin(pt.y * uFrequency + uTime * uSpeed) * uWaveAmplitude;\r\n\t}\r\n\telse if (effectType == EFFECT_TYPE_FLAG)\r\n\t{\r\n\t\ty = sin(pt.y * uFrequency + 10.0 * pt.x + uTime * uSpeed) * uWaveAmplitude;\r\n\t\tx = sin(pt.x * uFrequency + 5.0 * pt.y + uTime * uSpeed) * uWaveAmplitude;\r\n\t}\r\n\r\n\treturn vec2(pt.x + x, pt.y + y);\r\n}\r\n\r\nvoid main()\r\n{\r\n\tvec2 uv = sineWave(openfl_TextureCoordv);\r\n\tgl_FragColor = texture2D(bitmap, uv);\r\n}"</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.ShaderMacro.build()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.CommandLineHandler" params="" file="source/funkin/backend/system/CommandLineHandler.hx" final="1">
		<parseCommandLine public="1" set="method" line="6" static="1"><f a="cmd">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></parseCommandLine>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="funkin.backend.system.BeatType" params="" file="source/funkin/backend/system/Conductor.hx" module="funkin.backend.system.Conductor">
		<BEAT/>
		<MEASURE/>
		<STEP/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="funkin.backend.system.BPMChangeEvent" params="" file="source/funkin/backend/system/Conductor.hx" module="funkin.backend.system.Conductor">
		<songTime public="1"><x path="Float"/></songTime>
		<bpm public="1"><x path="Float"/></bpm>
		<beatsPerMeasure public="1" expr="4">
			<x path="Float"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</beatsPerMeasure>
		<stepsPerBeat public="1" expr="4">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</stepsPerBeat>
		<endSongTime public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</endSongTime>
		<endStepTime public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</endStepTime>
		<continuous public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</continuous>
		<stepTime public="1"><x path="Float"/></stepTime>
		<beatTime public="1"><x path="Float"/></beatTime>
		<measureTime public="1"><x path="Float"/></measureTime>
		<new public="1" set="method" line="16">
			<f a="songTime:bpm:?beatsPerMeasure:?stepsPerBeat:?endSongTime:?endStepTime:?continuous:stepTime:beatTime:measureTime">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Null"><x path="Float"/></x>
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="Float"/></x>
				<x path="Null"><x path="Float"/></x>
				<x path="Null"><x path="Bool"/></x>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="funkin.backend.system.Conductor" params="" file="source/funkin/backend/system/Conductor.hx" final="1">
		<getBeats public="1" set="method" line="34" static="1">
			<f a="?every:interval:?offset" v="::0">
				<e path="funkin.backend.system.BeatType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</getBeats>
		<onMeasureHit public="1" expr="new FlxTypedSignal()" line="47" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
			<haxe_doc>* FlxSignals</haxe_doc>
		</onMeasureHit>
		<onBeatHit public="1" expr="new FlxTypedSignal()" line="48" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
		</onBeatHit>
		<onStepHit public="1" expr="new FlxTypedSignal()" line="49" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
		</onStepHit>
		<onBPMChange public="1" expr="new FlxTypedSignal()" line="50" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
		</onBPMChange>
		<onTimeSignatureChange public="1" expr="new FlxTypedSignal()" line="51" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
		</onTimeSignatureChange>
		<songPosition public="1" get="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>* Current position of the song, in milliseconds.</haxe_doc>
		</songPosition>
		<get_songPosition set="method" line="57" static="1"><f a=""><x path="Float"/></f></get_songPosition>
		<songOffset public="1" expr="0" line="69" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Offset of the song</haxe_doc>
		</songOffset>
		<curChangeIndex public="1" expr="0" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current bpmChangeMap index</haxe_doc>
		</curChangeIndex>
		<curChange public="1" get="accessor" set="null" static="1">
			<c path="funkin.backend.system.BPMChangeEvent"/>
			<haxe_doc>* Current bpmChangeMap</haxe_doc>
		</curChange>
		<dummyChange expr="{ bpm : 100, beatsPerMeasure : 4, stepsPerBeat : 4, songTime : 0, stepTime : 0, beatTime : 0, measureTime : 0 }" line="80" static="1">
			<c path="funkin.backend.system.BPMChangeEvent"/>
			<meta><m n=":value"><e>{ bpm : 100, beatsPerMeasure : 4, stepsPerBeat : 4, songTime : 0, stepTime : 0, beatTime : 0, measureTime : 0 }</e></m></meta>
		</dummyChange>
		<get_curChange set="method" line="82" static="1"><f a=""><c path="funkin.backend.system.BPMChangeEvent"/></f></get_curChange>
		<bpm public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Current BPM</haxe_doc>
		</bpm>
		<get_bpm set="method" line="89" static="1"><f a=""><x path="Float"/></f></get_bpm>
		<startingBPM public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Starting BPM</haxe_doc>
		</startingBPM>
		<get_startingBPM set="method" line="96" static="1"><f a=""><x path="Float"/></f></get_startingBPM>
		<crochet public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Current Crochet (time per beat), in milliseconds.
	 * It should be crotchet but ehhh, now it's there for backward compatibility.</haxe_doc>
		</crochet>
		<get_crochet set="method" line="103" static="1"><f a=""><x path="Float"/></f></get_crochet>
		<stepCrochet public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Current StepCrochet (time per step), in milliseconds.</haxe_doc>
		</stepCrochet>
		<get_stepCrochet set="method" line="109" static="1"><f a=""><x path="Float"/></f></get_stepCrochet>
		<beatsPerMeasure public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Number of beats per mesure (top number in time signature). Defaults to 4.</haxe_doc>
		</beatsPerMeasure>
		<get_beatsPerMeasure set="method" line="116" static="1"><f a=""><x path="Float"/></f></get_beatsPerMeasure>
		<stepsPerBeat public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>* Number of steps per beat. Defaults to 4.
	 * Not a divisor number for time signature, it does the complete opposite.
	 * It's because CNE Conductor is based in sixteenth note instead of beat.</haxe_doc>
		</stepsPerBeat>
		<get_stepsPerBeat set="method" line="125" static="1"><f a=""><x path="Int"/></f></get_stepsPerBeat>
		<denominator public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* How much value notes to divide for beat (bottom or divisor number in time signature).
	 * Only for a convinient way to access divisor instead of multiply by steps per beat.</haxe_doc>
		</denominator>
		<get_denominator set="method" line="132" static="1"><f a=""><x path="Float"/></f></get_denominator>
		<lastStepChange public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Last step from BPM Change</haxe_doc>
		</lastStepChange>
		<get_lastStepChange set="method" line="138" static="1"><f a=""><x path="Float"/></f></get_lastStepChange>
		<lastBeatChange public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Last beat from BPM Change</haxe_doc>
		</lastBeatChange>
		<get_lastBeatChange set="method" line="144" static="1"><f a=""><x path="Float"/></f></get_lastBeatChange>
		<lastMeasureChange public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Last measure from BPM Change</haxe_doc>
		</lastMeasureChange>
		<get_lastMeasureChange set="method" line="150" static="1"><f a=""><x path="Float"/></f></get_lastMeasureChange>
		<curStep public="1" expr="0" line="155" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current step</haxe_doc>
		</curStep>
		<curBeat public="1" expr="0" line="160" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current beat</haxe_doc>
		</curBeat>
		<curMeasure public="1" expr="0" line="165" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current measure</haxe_doc>
		</curMeasure>
		<curStepFloat public="1" expr="0" line="170" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current step, as a `Float` (ex: 4.94, instead of 4)</haxe_doc>
		</curStepFloat>
		<curBeatFloat public="1" expr="0" line="175" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current beat, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curBeatFloat>
		<curMeasureFloat public="1" expr="0" line="180" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current measure, as a `Float` (ex: 1.24, instead of 1)</haxe_doc>
		</curMeasureFloat>
		<lastSongPos public="1" expr="0" line="183" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</lastSongPos>
		<offset public="1" expr="0" line="184" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</offset>
		<bpmChangeMap public="1" static="1">
			<c path="Array"><c path="funkin.backend.system.BPMChangeEvent"/></c>
			<haxe_doc>* Array of all BPM changes that have been mapped.</haxe_doc>
		</bpmChangeMap>
		<invalidEvents public="1" expr="[]" line="194" static="1">
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array of all events that have been rejected by the Conductor.</haxe_doc>
		</invalidEvents>
		<validEventNames expr="[&quot;BPM Change&quot;, &quot;Time Signature Change&quot;, &quot;Continuous BPM Change&quot;]" line="196" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["BPM Change", "Time Signature Change", "Continuous BPM Change"]</e></m></meta>
		</validEventNames>
		<reset public="1" set="method" line="200" static="1"><f a=""><x path="Void"/></f></reset>
		<changeBPM public="1" set="method" line="207" static="1">
			<f a="?bpm:?beatsPerMeasure:?stepsPerBeat" v="100:4:4">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stepsPerBeat : 4, beatsPerMeasure : 4, bpm : 100 }</e></m></meta>
		</changeBPM>
		<setupSong public="1" set="method" line="209" static="1"><f a="SONG">
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></setupSong>
		<mapBPMChange set="method" line="214" static="1"><f a="curChange:time:bpm">
	<c path="funkin.backend.system.BPMChangeEvent"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.backend.system.BPMChangeEvent"/>
</f></mapBPMChange>
		<mapBPMChanges public="1" set="method" line="237" static="1">
			<f a="song">
				<t path="funkin.backend.chart.ChartData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Maps BPM changes from a song.
	 * @param song Song to map BPM changes from.</haxe_doc>
		</mapBPMChanges>
		<mapEvent set="method" line="259" static="1"><f a="e:curChange">
	<t path="funkin.backend.chart.ChartEvent"/>
	<c path="funkin.backend.system.BPMChangeEvent"/>
	<c path="funkin.backend.system.BPMChangeEvent"/>
</f></mapEvent>
		<mapCharterBPMChanges public="1" set="method" line="298" static="1"><f a="song">
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></mapCharterBPMChanges>
		<elapsed static="1"><x path="Float"/></elapsed>
		<init public="1" set="method" line="351" static="1"><f a=""><x path="Void"/></f></init>
		<__updateSongPos set="method" line="357" static="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></__updateSongPos>
		<onStateSwitch set="method" line="364" static="1"><f a="newState">
	<c path="flixel.FlxState"/>
	<x path="Void"/>
</f></onStateSwitch>
		<__lastChange static="1"><c path="funkin.backend.system.BPMChangeEvent"/></__lastChange>
		<__updateStep static="1"><x path="Bool"/></__updateStep>
		<__updateBeat static="1"><x path="Bool"/></__updateBeat>
		<__updateMeasure static="1"><x path="Bool"/></__updateMeasure>
		<update set="method" line="373" static="1"><f a=""><x path="Void"/></f></update>
		<getTimeInChangeIndex public="1" set="method" line="444" static="1">
			<f a="time:?index" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
		</getTimeInChangeIndex>
		<getStepsInChangeIndex public="1" set="method" line="456" static="1">
			<f a="stepTime:?index" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
		</getStepsInChangeIndex>
		<getBeatsInChangeIndex public="1" set="method" line="468" static="1">
			<f a="beatTime:?index" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
		</getBeatsInChangeIndex>
		<getMeasuresInChangeIndex public="1" set="method" line="480" static="1">
			<f a="measureTime:?index" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
		</getMeasuresInChangeIndex>
		<getTimeWithIndexInBPM public="1" set="method" line="492" static="1"><f a="time:index">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getTimeWithIndexInBPM>
		<getStepsWithIndexInBPM public="1" set="method" line="504" static="1"><f a="stepTime:index">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getStepsWithIndexInBPM>
		<getTimeInBPM public="1" set="method" line="516" static="1"><f a="time">
	<x path="Float"/>
	<x path="Float"/>
</f></getTimeInBPM>
		<getTimeWithBPMInSteps public="1" set="method" line="521" static="1"><f a="time:index:bpm">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getTimeWithBPMInSteps>
		<getTimeInBeats public="1" set="method" line="536" static="1">
			<f a="time:?from" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</getTimeInBeats>
		<getTimeInSteps public="1" set="method" line="546" static="1">
			<f a="time:?from" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</getTimeInSteps>
		<getStepForTime public="1" get="inline" set="null" line="553" static="1">
			<f a="time">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":haxe.warning"><e>"-WDeprecated"</e></m>
			</meta>
		</getStepForTime>
		<getStepsWithBPMInTime public="1" set="method" line="555" static="1"><f a="stepTime:index:bpm">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getStepsWithBPMInTime>
		<getMeasuresInTime public="1" set="method" line="571" static="1">
			<f a="measureTime:?from" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</getMeasuresInTime>
		<getBeatsInTime public="1" set="method" line="582" static="1">
			<f a="beatTime:?from" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</getBeatsInTime>
		<getStepsInTime public="1" set="method" line="593" static="1">
			<f a="stepTime:?from" v=":0">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ from : 0 }</e></m></meta>
		</getStepsInTime>
		<getTimeForStep public="1" get="inline" set="null" line="600" static="1">
			<f a="steps">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":haxe.warning"><e>"-WDeprecated"</e></m>
			</meta>
		</getTimeForStep>
		<getMeasureLength public="1" get="inline" set="null" line="603" static="1"><f a=""><x path="Float"/></f></getMeasureLength>
		<getMeasuresLength public="1" get="inline" set="null" line="605" static="1"><f a=""><x path="Float"/></f></getMeasuresLength>
		<new public="1" set="method" line="198">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="funkin.backend.system.Control" params="" file="source/funkin/backend/system/Controls.hx" module="funkin.backend.system.Controls">
		<UP/>
		<LEFT/>
		<RIGHT/>
		<DOWN/>
		<NOTE_UP/>
		<NOTE_LEFT/>
		<NOTE_RIGHT/>
		<NOTE_DOWN/>
		<RESET/>
		<ACCEPT/>
		<BACK/>
		<PAUSE/>
		<SWITCHMOD/>
		<DEV_ACCESS/>
		<DEV_CONSOLE/>
		<DEV_RELOAD/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="funkin.backend.system.KeyboardScheme" params="" file="source/funkin/backend/system/Controls.hx" module="funkin.backend.system.Controls">
		<Solo/>
		<Duo a="first"><x path="Bool"/></Duo>
		<None/>
		<Custom/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="funkin.backend.system.Controls" params="" file="source/funkin/backend/system/Controls.hx">
		<extends path="flixel.input.actions.FlxActionSet"/>
		<addKeys public="1" get="inline" set="null" line="249" static="1"><f a="action:keys:state">
	<c path="flixel.input.actions.FlxActionDigital"/>
	<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
	<x path="flixel.input.FlxInputState"/>
	<x path="Void"/>
</f></addKeys>
		<removeKeys public="1" set="method" line="255" static="1"><f a="action:keys">
	<c path="flixel.input.actions.FlxActionDigital"/>
	<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
	<x path="Void"/>
</f></removeKeys>
		<addButtons public="1" get="inline" set="null" line="332" static="1"><f a="action:buttons:state:id">
	<c path="flixel.input.actions.FlxActionDigital"/>
	<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
	<x path="flixel.input.FlxInputState"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addButtons>
		<removeButtons public="1" set="method" line="338" static="1"><f a="action:gamepadID:buttons">
	<c path="flixel.input.actions.FlxActionDigital"/>
	<x path="Int"/>
	<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
	<x path="Void"/>
</f></removeButtons>
		<isGamepad public="1" get="inline" set="null" line="349" static="1"><f a="input:deviceID">
	<c path="flixel.input.actions.FlxActionInput"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></isGamepad>
		<UP public="1" get="accessor" set="accessor"><x path="Bool"/></UP>
		<UP_P public="1" get="accessor" set="accessor"><x path="Bool"/></UP_P>
		<UP_R public="1" get="accessor" set="accessor"><x path="Bool"/></UP_R>
		<LEFT public="1" get="accessor" set="accessor"><x path="Bool"/></LEFT>
		<LEFT_P public="1" get="accessor" set="accessor"><x path="Bool"/></LEFT_P>
		<LEFT_R public="1" get="accessor" set="accessor"><x path="Bool"/></LEFT_R>
		<RIGHT public="1" get="accessor" set="accessor"><x path="Bool"/></RIGHT>
		<RIGHT_P public="1" get="accessor" set="accessor"><x path="Bool"/></RIGHT_P>
		<RIGHT_R public="1" get="accessor" set="accessor"><x path="Bool"/></RIGHT_R>
		<DOWN public="1" get="accessor" set="accessor"><x path="Bool"/></DOWN>
		<DOWN_P public="1" get="accessor" set="accessor"><x path="Bool"/></DOWN_P>
		<DOWN_R public="1" get="accessor" set="accessor"><x path="Bool"/></DOWN_R>
		<NOTE_UP public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_UP>
		<NOTE_UP_P public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_UP_P>
		<NOTE_UP_R public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_UP_R>
		<NOTE_LEFT public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_LEFT>
		<NOTE_LEFT_P public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_LEFT_P>
		<NOTE_LEFT_R public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_LEFT_R>
		<NOTE_RIGHT public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_RIGHT>
		<NOTE_RIGHT_P public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_RIGHT_P>
		<NOTE_RIGHT_R public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_RIGHT_R>
		<NOTE_DOWN public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_DOWN>
		<NOTE_DOWN_P public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_DOWN_P>
		<NOTE_DOWN_R public="1" get="accessor" set="accessor"><x path="Bool"/></NOTE_DOWN_R>
		<ACCEPT public="1" get="accessor" set="accessor"><x path="Bool"/></ACCEPT>
		<ACCEPT_HOLD public="1" get="accessor" set="accessor"><x path="Bool"/></ACCEPT_HOLD>
		<ACCEPT_R public="1" get="accessor" set="accessor"><x path="Bool"/></ACCEPT_R>
		<BACK public="1" get="accessor" set="accessor"><x path="Bool"/></BACK>
		<BACK_HOLD public="1" get="accessor" set="accessor"><x path="Bool"/></BACK_HOLD>
		<BACK_R public="1" get="accessor" set="accessor"><x path="Bool"/></BACK_R>
		<PAUSE public="1" get="accessor" set="accessor"><x path="Bool"/></PAUSE>
		<PAUSE_HOLD public="1" get="accessor" set="accessor"><x path="Bool"/></PAUSE_HOLD>
		<PAUSE_R public="1" get="accessor" set="accessor"><x path="Bool"/></PAUSE_R>
		<RESET public="1" get="accessor" set="accessor"><x path="Bool"/></RESET>
		<RESET_HOLD public="1" get="accessor" set="accessor"><x path="Bool"/></RESET_HOLD>
		<RESET_R public="1" get="accessor" set="accessor"><x path="Bool"/></RESET_R>
		<SWITCHMOD public="1" get="accessor" set="accessor"><x path="Bool"/></SWITCHMOD>
		<SWITCHMOD_HOLD public="1" get="accessor" set="accessor"><x path="Bool"/></SWITCHMOD_HOLD>
		<SWITCHMOD_R public="1" get="accessor" set="accessor"><x path="Bool"/></SWITCHMOD_R>
		<DEV_ACCESS public="1" get="accessor" set="accessor"><x path="Bool"/></DEV_ACCESS>
		<DEV_ACCESS_HOLD public="1" get="accessor" set="accessor"><x path="Bool"/></DEV_ACCESS_HOLD>
		<DEV_ACCESS_R public="1" get="accessor" set="accessor"><x path="Bool"/></DEV_ACCESS_R>
		<DEV_CONSOLE public="1" get="accessor" set="accessor"><x path="Bool"/></DEV_CONSOLE>
		<DEV_CONSOLE_HOLD public="1" get="accessor" set="accessor"><x path="Bool"/></DEV_CONSOLE_HOLD>
		<DEV_CONSOLE_R public="1" get="accessor" set="accessor"><x path="Bool"/></DEV_CONSOLE_R>
		<DEV_RELOAD public="1" get="accessor" set="accessor"><x path="Bool"/></DEV_RELOAD>
		<DEV_RELOAD_HOLD public="1" get="accessor" set="accessor"><x path="Bool"/></DEV_RELOAD_HOLD>
		<DEV_RELOAD_R public="1" get="accessor" set="accessor"><x path="Bool"/></DEV_RELOAD_R>
		<byName expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.input.actions.FlxActionDigital"/>
			</t>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":allow"><e>funkin.backend.utils.ControlsUtil</e></m>
			</meta>
		</byName>
		<gamepadsAdded public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</gamepadsAdded>
		<keyboardScheme public="1" expr="None">
			<e path="funkin.backend.system.KeyboardScheme"/>
			<meta><m n=":value"><e>None</e></m></meta>
		</keyboardScheme>
		<getActionFromControl public="1" set="method" line="194"><f a="control">
	<e path="funkin.backend.system.Control"/>
	<c path="flixel.input.actions.FlxAction"/>
</f></getActionFromControl>
		<getKeyName public="1" set="method" line="197">
			<f a="control:?idx" v=":0">
				<e path="funkin.backend.system.Control"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ idx : 0 }</e></m></meta>
		</getKeyName>
		<replaceBindingKeyboard public="1" set="method" line="209"><f a="control:?toAdd:?toRemove">
	<e path="funkin.backend.system.Control"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></replaceBindingKeyboard>
		<replaceBindingGamepad public="1" set="method" line="220"><f a="control:deviceID:?toAdd:?toRemove">
	<e path="funkin.backend.system.Control"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></replaceBindingGamepad>
		<bindKeys public="1" get="inline" set="null" line="235">
			<f a="control:keys">
				<e path="funkin.backend.system.Control"/>
				<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets all actions that pertain to the binder to trigger when the supplied keys are used.
	 * If binder is a literal you can inline this</haxe_doc>
		</bindKeys>
		<unbindKeys public="1" get="inline" set="null" line="244">
			<f a="control:keys">
				<e path="funkin.backend.system.Control"/>
				<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets all actions that pertain to the binder to trigger when the supplied keys are used.
	 * If binder is a literal you can inline this</haxe_doc>
		</unbindKeys>
		<setKeyboardScheme public="1" set="method" line="266">
			<f a="scheme:?reset" v=":true">
				<e path="funkin.backend.system.KeyboardScheme"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reset : true }</e></m></meta>
		</setKeyboardScheme>
		<removeKeyboard set="method" line="276"><f a=""><x path="Void"/></f></removeKeyboard>
		<addGamepad public="1" set="method" line="290"><f a="id:buttonMap">
	<x path="Int"/>
	<t path="Map">
		<e path="funkin.backend.system.Control"/>
		<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
	</t>
	<x path="Void"/>
</f></addGamepad>
		<removeGamepad public="1" set="method" line="298">
			<f a="?deviceID" v="FlxInputDeviceID.ALL">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ deviceID : FlxInputDeviceID.ALL }</e></m></meta>
		</removeGamepad>
		<bindButtons public="1" get="inline" set="null" line="318">
			<f a="control:id:buttons">
				<e path="funkin.backend.system.Control"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets all actions that pertain to the binder to trigger when the supplied keys are used.
	 * If binder is a literal you can inline this</haxe_doc>
		</bindButtons>
		<unbindButtons public="1" get="inline" set="null" line="327">
			<f a="control:gamepadID:buttons">
				<e path="funkin.backend.system.Control"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets all actions that pertain to the binder to trigger when the supplied keys are used.
	 * If binder is a literal you can inline this</haxe_doc>
		</unbindButtons>
		<getJustPressed public="1" get="inline" set="null" line="354">
			<f a="name">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":nullSafety"><e>Off</e></m></meta>
		</getJustPressed>
		<getJustReleased public="1" get="inline" set="null" line="358">
			<f a="name">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":nullSafety"><e>Off</e></m></meta>
		</getJustReleased>
		<getPressed public="1" get="inline" set="null" line="362">
			<f a="name">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":nullSafety"><e>Off</e></m></meta>
		</getPressed>
		<_up expr="new FlxActionDigital(&quot;_up&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_up")</e></m></meta>
		</_up>
		<get_UP get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_UP>
		<set_UP get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_UP>
		<_upP expr="new FlxActionDigital(&quot;_upP&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_upP")</e></m></meta>
		</_upP>
		<get_UP_P get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_UP_P>
		<set_UP_P get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_UP_P>
		<_upR expr="new FlxActionDigital(&quot;_upR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_upR")</e></m></meta>
		</_upR>
		<get_UP_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_UP_R>
		<set_UP_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_UP_R>
		<_left expr="new FlxActionDigital(&quot;_left&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_left")</e></m></meta>
		</_left>
		<get_LEFT get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_LEFT>
		<set_LEFT get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_LEFT>
		<_leftP expr="new FlxActionDigital(&quot;_leftP&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_leftP")</e></m></meta>
		</_leftP>
		<get_LEFT_P get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_LEFT_P>
		<set_LEFT_P get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_LEFT_P>
		<_leftR expr="new FlxActionDigital(&quot;_leftR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_leftR")</e></m></meta>
		</_leftR>
		<get_LEFT_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_LEFT_R>
		<set_LEFT_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_LEFT_R>
		<_right expr="new FlxActionDigital(&quot;_right&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_right")</e></m></meta>
		</_right>
		<get_RIGHT get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_RIGHT>
		<set_RIGHT get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RIGHT>
		<_rightP expr="new FlxActionDigital(&quot;_rightP&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_rightP")</e></m></meta>
		</_rightP>
		<get_RIGHT_P get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_RIGHT_P>
		<set_RIGHT_P get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RIGHT_P>
		<_rightR expr="new FlxActionDigital(&quot;_rightR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_rightR")</e></m></meta>
		</_rightR>
		<get_RIGHT_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_RIGHT_R>
		<set_RIGHT_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RIGHT_R>
		<_down expr="new FlxActionDigital(&quot;_down&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_down")</e></m></meta>
		</_down>
		<get_DOWN get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_DOWN>
		<set_DOWN get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DOWN>
		<_downP expr="new FlxActionDigital(&quot;_downP&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_downP")</e></m></meta>
		</_downP>
		<get_DOWN_P get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_DOWN_P>
		<set_DOWN_P get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DOWN_P>
		<_downR expr="new FlxActionDigital(&quot;_downR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_downR")</e></m></meta>
		</_downR>
		<get_DOWN_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_DOWN_R>
		<set_DOWN_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DOWN_R>
		<_noteUp expr="new FlxActionDigital(&quot;_noteUp&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteUp")</e></m></meta>
		</_noteUp>
		<get_NOTE_UP get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_UP>
		<set_NOTE_UP get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_UP>
		<_noteUpP expr="new FlxActionDigital(&quot;_noteUpP&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteUpP")</e></m></meta>
		</_noteUpP>
		<get_NOTE_UP_P get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_UP_P>
		<set_NOTE_UP_P get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_UP_P>
		<_noteUpR expr="new FlxActionDigital(&quot;_noteUpR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteUpR")</e></m></meta>
		</_noteUpR>
		<get_NOTE_UP_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_UP_R>
		<set_NOTE_UP_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_UP_R>
		<_noteLeft expr="new FlxActionDigital(&quot;_noteLeft&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteLeft")</e></m></meta>
		</_noteLeft>
		<get_NOTE_LEFT get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_LEFT>
		<set_NOTE_LEFT get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_LEFT>
		<_noteLeftP expr="new FlxActionDigital(&quot;_noteLeftP&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteLeftP")</e></m></meta>
		</_noteLeftP>
		<get_NOTE_LEFT_P get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_LEFT_P>
		<set_NOTE_LEFT_P get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_LEFT_P>
		<_noteLeftR expr="new FlxActionDigital(&quot;_noteLeftR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteLeftR")</e></m></meta>
		</_noteLeftR>
		<get_NOTE_LEFT_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_LEFT_R>
		<set_NOTE_LEFT_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_LEFT_R>
		<_noteRight expr="new FlxActionDigital(&quot;_noteRight&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteRight")</e></m></meta>
		</_noteRight>
		<get_NOTE_RIGHT get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_RIGHT>
		<set_NOTE_RIGHT get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_RIGHT>
		<_noteRightP expr="new FlxActionDigital(&quot;_noteRightP&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteRightP")</e></m></meta>
		</_noteRightP>
		<get_NOTE_RIGHT_P get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_RIGHT_P>
		<set_NOTE_RIGHT_P get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_RIGHT_P>
		<_noteRightR expr="new FlxActionDigital(&quot;_noteRightR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteRightR")</e></m></meta>
		</_noteRightR>
		<get_NOTE_RIGHT_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_RIGHT_R>
		<set_NOTE_RIGHT_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_RIGHT_R>
		<_noteDown expr="new FlxActionDigital(&quot;_noteDown&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteDown")</e></m></meta>
		</_noteDown>
		<get_NOTE_DOWN get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_DOWN>
		<set_NOTE_DOWN get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_DOWN>
		<_noteDownP expr="new FlxActionDigital(&quot;_noteDownP&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteDownP")</e></m></meta>
		</_noteDownP>
		<get_NOTE_DOWN_P get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_DOWN_P>
		<set_NOTE_DOWN_P get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_DOWN_P>
		<_noteDownR expr="new FlxActionDigital(&quot;_noteDownR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_noteDownR")</e></m></meta>
		</_noteDownR>
		<get_NOTE_DOWN_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_NOTE_DOWN_R>
		<set_NOTE_DOWN_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_NOTE_DOWN_R>
		<_accept expr="new FlxActionDigital(&quot;_accept&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_accept")</e></m></meta>
		</_accept>
		<get_ACCEPT get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_ACCEPT>
		<set_ACCEPT get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ACCEPT>
		<_acceptHOLD expr="new FlxActionDigital(&quot;_acceptHOLD&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_acceptHOLD")</e></m></meta>
		</_acceptHOLD>
		<get_ACCEPT_HOLD get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_ACCEPT_HOLD>
		<set_ACCEPT_HOLD get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ACCEPT_HOLD>
		<_acceptR expr="new FlxActionDigital(&quot;_acceptR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_acceptR")</e></m></meta>
		</_acceptR>
		<get_ACCEPT_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_ACCEPT_R>
		<set_ACCEPT_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ACCEPT_R>
		<_back expr="new FlxActionDigital(&quot;_back&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_back")</e></m></meta>
		</_back>
		<get_BACK get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_BACK>
		<set_BACK get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_BACK>
		<_backHOLD expr="new FlxActionDigital(&quot;_backHOLD&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_backHOLD")</e></m></meta>
		</_backHOLD>
		<get_BACK_HOLD get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_BACK_HOLD>
		<set_BACK_HOLD get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_BACK_HOLD>
		<_backR expr="new FlxActionDigital(&quot;_backR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_backR")</e></m></meta>
		</_backR>
		<get_BACK_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_BACK_R>
		<set_BACK_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_BACK_R>
		<_pause expr="new FlxActionDigital(&quot;_pause&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_pause")</e></m></meta>
		</_pause>
		<get_PAUSE get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_PAUSE>
		<set_PAUSE get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_PAUSE>
		<_pauseHOLD expr="new FlxActionDigital(&quot;_pauseHOLD&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_pauseHOLD")</e></m></meta>
		</_pauseHOLD>
		<get_PAUSE_HOLD get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_PAUSE_HOLD>
		<set_PAUSE_HOLD get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_PAUSE_HOLD>
		<_pauseR expr="new FlxActionDigital(&quot;_pauseR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_pauseR")</e></m></meta>
		</_pauseR>
		<get_PAUSE_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_PAUSE_R>
		<set_PAUSE_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_PAUSE_R>
		<_reset expr="new FlxActionDigital(&quot;_reset&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_reset")</e></m></meta>
		</_reset>
		<get_RESET get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_RESET>
		<set_RESET get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RESET>
		<_resetHOLD expr="new FlxActionDigital(&quot;_resetHOLD&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_resetHOLD")</e></m></meta>
		</_resetHOLD>
		<get_RESET_HOLD get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_RESET_HOLD>
		<set_RESET_HOLD get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RESET_HOLD>
		<_resetR expr="new FlxActionDigital(&quot;_resetR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_resetR")</e></m></meta>
		</_resetR>
		<get_RESET_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_RESET_R>
		<set_RESET_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_RESET_R>
		<_switchmod expr="new FlxActionDigital(&quot;_switchmod&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_switchmod")</e></m></meta>
		</_switchmod>
		<get_SWITCHMOD get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_SWITCHMOD>
		<set_SWITCHMOD get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_SWITCHMOD>
		<_switchmodHOLD expr="new FlxActionDigital(&quot;_switchmodHOLD&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_switchmodHOLD")</e></m></meta>
		</_switchmodHOLD>
		<get_SWITCHMOD_HOLD get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_SWITCHMOD_HOLD>
		<set_SWITCHMOD_HOLD get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_SWITCHMOD_HOLD>
		<_switchmodR expr="new FlxActionDigital(&quot;_switchmodR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_switchmodR")</e></m></meta>
		</_switchmodR>
		<get_SWITCHMOD_R get="inline" set="null" line="344"><f a=""><x path="Bool"/></f></get_SWITCHMOD_R>
		<set_SWITCHMOD_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_SWITCHMOD_R>
		<_devAccess expr="new FlxActionDigital(&quot;_devAccess&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_devAccess")</e></m></meta>
		</_devAccess>
		<get_DEV_ACCESS get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></get_DEV_ACCESS>
		<set_DEV_ACCESS get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DEV_ACCESS>
		<_devAccessHOLD expr="new FlxActionDigital(&quot;_devAccessHOLD&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_devAccessHOLD")</e></m></meta>
		</_devAccessHOLD>
		<get_DEV_ACCESS_HOLD get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></get_DEV_ACCESS_HOLD>
		<set_DEV_ACCESS_HOLD get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DEV_ACCESS_HOLD>
		<_devAccessR expr="new FlxActionDigital(&quot;_devAccessR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_devAccessR")</e></m></meta>
		</_devAccessR>
		<get_DEV_ACCESS_R get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></get_DEV_ACCESS_R>
		<set_DEV_ACCESS_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DEV_ACCESS_R>
		<_devConsole expr="new FlxActionDigital(&quot;_devConsole&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_devConsole")</e></m></meta>
		</_devConsole>
		<get_DEV_CONSOLE get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></get_DEV_CONSOLE>
		<set_DEV_CONSOLE get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DEV_CONSOLE>
		<_devConsoleHOLD expr="new FlxActionDigital(&quot;_devConsoleHOLD&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_devConsoleHOLD")</e></m></meta>
		</_devConsoleHOLD>
		<get_DEV_CONSOLE_HOLD get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></get_DEV_CONSOLE_HOLD>
		<set_DEV_CONSOLE_HOLD get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DEV_CONSOLE_HOLD>
		<_devConsoleR expr="new FlxActionDigital(&quot;_devConsoleR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_devConsoleR")</e></m></meta>
		</_devConsoleR>
		<get_DEV_CONSOLE_R get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></get_DEV_CONSOLE_R>
		<set_DEV_CONSOLE_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DEV_CONSOLE_R>
		<_devReload expr="new FlxActionDigital(&quot;_devReload&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_devReload")</e></m></meta>
		</_devReload>
		<get_DEV_RELOAD get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></get_DEV_RELOAD>
		<set_DEV_RELOAD get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DEV_RELOAD>
		<_devReloadHOLD expr="new FlxActionDigital(&quot;_devReloadHOLD&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_devReloadHOLD")</e></m></meta>
		</_devReloadHOLD>
		<get_DEV_RELOAD_HOLD get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></get_DEV_RELOAD_HOLD>
		<set_DEV_RELOAD_HOLD get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DEV_RELOAD_HOLD>
		<_devReloadR expr="new FlxActionDigital(&quot;_devReloadR&quot;)">
			<c path="flixel.input.actions.FlxActionDigital"/>
			<meta><m n=":value"><e>new FlxActionDigital("_devReloadR")</e></m></meta>
		</_devReloadR>
		<get_DEV_RELOAD_R get="inline" set="null" line="343"><f a=""><x path="Bool"/></f></get_DEV_RELOAD_R>
		<set_DEV_RELOAD_R get="inline" set="null" line="362"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_DEV_RELOAD_R>
		<addDefaultGamepad public="1" set="method" line="208"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></addDefaultGamepad>
		<macro_addKeysToActions public="1" get="inline" set="null" line="74"><f a=""><x path="Void"/></f></macro_addKeysToActions>
		<macro_bindControls set="method" line="94"><f a="keyScheme">
	<e path="funkin.backend.system.KeyboardScheme"/>
	<x path="Void"/>
</f></macro_bindControls>
		<macro_forEachBound set="method" line="50"><f a="control:func">
	<e path="funkin.backend.system.Control"/>
	<f a=":">
		<c path="flixel.input.actions.FlxActionDigital"/>
		<x path="flixel.input.FlxInputState"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></macro_forEachBound>
		<macro_getActionFromControl set="method" line="178"><f a="control">
	<e path="funkin.backend.system.Control"/>
	<c path="flixel.input.actions.FlxActionDigital"/>
</f></macro_getActionFromControl>
		<new public="1" set="method" line="182">
			<f a="name:?scheme" v=":None">
				<c path="String"/>
				<e path="funkin.backend.system.KeyboardScheme"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scheme : None }</e></m></meta>
		</new>
		<haxe_doc>* A list of actions that a player would invoke via some input device.
 * Uses FlxActions to funnel various inputs to a single action.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noCustomClass"/>
			<m n=":nullSafety"/>
			<m n=":build"><e>funkin.backend.system.macros.ControlsMacro.build()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.FakeCamera" params="" file="source/funkin/backend/system/FakeCamera.hx">
		<extends path="flixel.FlxCamera"/>
		<instance final="1" public="1" set="null" expr="new FakeCamera()" line="16" static="1">
			<c path="funkin.backend.system.FakeCamera"/>
			<meta><m n=":value"><e>new FakeCamera()</e></m></meta>
		</instance>
		<startTrianglesBatch public="1" set="method" line="24" override="1">
			<f a="graphic:?smoothing:?isColored:?blend:?hasColorOffsets:?shader" v=":false:false:::">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<t path="flixel.system.FlxShader"/>
				<x path="Null"><c path="flixel.graphics.tile.FlxDrawTrianglesItem"/></x>
			</f>
			<meta><m n=":value"><e>{ isColored : false, smoothing : false }</e></m></meta>
		</startTrianglesBatch>
		<startQuadBatch public="1" set="method" line="25" override="1">
			<f a="graphic:colored:?hasColorOffsets:?blend:?smooth:?shader" v="::false::false:">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<t path="flixel.system.FlxShader"/>
				<x path="Null"><c path="flixel.graphics.tile.FlxDrawQuadsItem"/></x>
			</f>
			<meta><m n=":value"><e>{ smooth : false, hasColorOffsets : false }</e></m></meta>
		</startQuadBatch>
		<clearDrawStack set="method" line="26" override="1"><f a=""><x path="Void"/></f></clearDrawStack>
		<render set="method" line="27" override="1"><f a=""><x path="Void"/></f></render>
		<drawPixels public="1" set="method" line="29" override="1">
			<f a="?frame:?pixels:matrix:?transform:?blend:?smoothing:?shader" v=":::::false:">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="openfl.display.BitmapData"/>
				<c path="flixel.math.FlxMatrix"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<t path="flixel.system.FlxShader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</drawPixels>
		<copyPixels public="1" set="method" line="30" override="1">
			<f a="?frame:?pixels:?sourceRect:destPoint:?transform:?blend:?smoothing:?shader" v="::::::false:">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Point"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<t path="flixel.system.FlxShader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</copyPixels>
		<drawTriangles public="1" set="method" line="31" override="1">
			<f a="graphic:vertices:indices:uvtData:?colors:?position:?blend:?repeat:?smoothing:?transform:?shader" v=":::::::false:false::">
				<c path="flixel.graphics.FlxGraphic"/>
				<t path="flixel.graphics.tile.DrawData"><x path="Float"/></t>
				<t path="flixel.graphics.tile.DrawData"><x path="Int"/></t>
				<t path="flixel.graphics.tile.DrawData"><x path="Float"/></t>
				<t path="flixel.graphics.tile.DrawData"><x path="Int"/></t>
				<x path="flixel.math.FlxPoint"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="openfl.geom.ColorTransform"/>
				<t path="flixel.system.FlxShader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false, repeat : false }</e></m></meta>
		</drawTriangles>
		<update public="1" set="method" line="33" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<setScale public="1" set="method" line="37" override="1"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setScale>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.FakeCallCamera" params="" file="source/funkin/backend/system/FakeCamera.hx" module="funkin.backend.system.FakeCamera">
		<extends path="funkin.backend.system.FakeCamera"/>
		<instance final="1" public="1" set="null" expr="new FakeCallCamera()" line="41" static="1">
			<c path="funkin.backend.system.FakeCallCamera"/>
			<meta><m n=":value"><e>new FakeCallCamera()</e></m></meta>
		</instance>
		<ignoreDraws public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</ignoreDraws>
		<onDraw public="1" set="dynamic" line="44">
			<f a="?frame:?pixels:matrix:?transform:?blend:?smoothing:?shader" v=":::::false:">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="openfl.display.BitmapData"/>
				<c path="flixel.math.FlxMatrix"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<t path="flixel.system.FlxShader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</onDraw>
		<drawPixels public="1" set="method" line="47" override="1">
			<f a="?frame:?pixels:matrix:?transform:?blend:?smoothing:?shader" v=":::::false:">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="openfl.display.BitmapData"/>
				<c path="flixel.math.FlxMatrix"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<t path="flixel.system.FlxShader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</drawPixels>
		<new public="1" set="method" line="40"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.FunkinGame" params="" file="source/funkin/backend/system/FunkinGame.hx">
		<extends path="flixel.FlxGame"/>
		<skipNextTickUpdate expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skipNextTickUpdate>
		<switchState public="1" set="method" line="7" override="1"><f a=""><x path="Void"/></f></switchState>
		<onEnterFrame public="1" set="method" line="15" override="1"><f a="t">
	<c path="openfl.events.Event"/>
	<x path="Void"/>
</f></onEnterFrame>
		<new public="1" set="method" line="5"><f a="?gameWidth:?gameHeight:?initialState:?updateFramerate:?drawFramerate:?skipSplash:?startFullscreen">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Class"><c path="flixel.FlxState"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.FunkinRatioScaleMode" params="" file="source/funkin/backend/system/FunkinRatioScaleMode.hx">
		<extends path="flixel.system.scaleModes.RatioScaleMode"/>
		<width public="1" get="accessor" set="accessor" expr="null">
			<x path="Null"><x path="Int"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":isVar"/>
			</meta>
		</width>
		<height public="1" get="accessor" set="accessor" expr="null">
			<x path="Null"><x path="Int"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":isVar"/>
			</meta>
		</height>
		<updateGameSize public="1" set="method" line="10" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateGameSize>
		<resetSize public="1" set="method" line="45"><f a=""><x path="Void"/></f></resetSize>
		<get_width get="inline" set="null" line="50"><f a=""><x path="Null"><x path="Int"/></x></f></get_width>
		<get_height get="inline" set="null" line="52"><f a=""><x path="Null"><x path="Int"/></x></f></get_height>
		<set_width get="inline" set="null" line="53"><f a="v">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_width>
		<set_height get="inline" set="null" line="59"><f a="v">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_height>
		<new public="1" set="method" line="5"><f a="?fillScreen">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.GraphicCacheSprite" params="" file="source/funkin/backend/system/GraphicCacheSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<cachedGraphics public="1" expr="[]">
			<c path="Array"><c path="flixel.graphics.FlxGraphic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array containing all of the graphics cached by this sprite.</haxe_doc>
		</cachedGraphics>
		<nonRenderedCachedGraphics public="1" expr="[]">
			<c path="Array"><c path="flixel.graphics.FlxGraphic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array containing all of the non rendered (not sent to GPU) cached graphics.</haxe_doc>
		</nonRenderedCachedGraphics>
		<cache public="1" set="method" line="27">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Caches a graphic at specified path.
	 * @param path Path to the graphic.</haxe_doc>
		</cache>
		<cacheGraphic public="1" set="method" line="35">
			<f a="graphic">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Caches a graphic.
	 * @param graphic The FlxGraphic</haxe_doc>
		</cacheGraphic>
		<destroy public="1" set="method" line="45" override="1"><f a=""><x path="Void"/></f></destroy>
		<draw public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Dummy FlxSprite that allows you to cache FlxGraphics, and immediately send them to GPU memory.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.Logs" params="" file="source/funkin/backend/system/Logs.hx" final="1">
		<__showing expr="false" line="10" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__showing>
		<nativeTrace public="1" expr="Log.trace" line="12" static="1">
			<f a="v:?infos">
				<d/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>Log.trace</e></m></meta>
		</nativeTrace>
		<init public="1" set="method" line="13" static="1"><f a=""><x path="Void"/></f></init>
		<prepareColoredTrace public="1" set="method" line="77" static="1">
			<f a="text:?level" v=":INFO">
				<c path="Array"><t path="funkin.backend.system.LogText"/></c>
				<x path="funkin.backend.system.Level"/>
				<c path="Array"><t path="funkin.backend.system.LogText"/></c>
			</f>
			<meta><m n=":value"><e>{ level : INFO }</e></m></meta>
		</prepareColoredTrace>
		<logText public="1" set="method" line="100" static="1">
			<f a="text:?color" v=":LIGHTGRAY">
				<c path="String"/>
				<x path="funkin.backend.utils.ConsoleColor"/>
				<t path="funkin.backend.system.LogText"/>
			</f>
			<meta><m n=":value"><e>{ color : LIGHTGRAY }</e></m></meta>
		</logText>
		<__showInConsole public="1" set="method" line="107" static="1"><f a="text">
	<c path="Array"><t path="funkin.backend.system.LogText"/></c>
	<x path="Void"/>
</f></__showInConsole>
		<traceColored public="1" get="inline" set="null" line="135" static="1">
			<f a="text:?level" v=":INFO">
				<c path="Array"><t path="funkin.backend.system.LogText"/></c>
				<x path="funkin.backend.system.Level"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ level : INFO }</e></m></meta>
		</traceColored>
		<trace public="1" set="method" line="137" static="1">
			<f a="text:?level:?color:?prefix" v=":INFO:LIGHTGRAY:">
				<c path="String"/>
				<x path="funkin.backend.system.Level"/>
				<x path="funkin.backend.utils.ConsoleColor"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : LIGHTGRAY, level : INFO }</e></m></meta>
		</trace>
		<getPrefix public="1" get="inline" set="null" line="144" static="1"><f a="prefix">
	<c path="String"/>
	<t path="funkin.backend.system.LogText"/>
</f></getPrefix>
		<infos public="1" get="inline" set="null" line="147" static="1">
			<f a="text:?color:?prefix" v=":LIGHTGRAY:">
				<c path="String"/>
				<x path="funkin.backend.utils.ConsoleColor"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : LIGHTGRAY }</e></m></meta>
		</infos>
		<verbose public="1" get="inline" set="null" line="150" static="1">
			<f a="text:?color:?prefix" v=":LIGHTGRAY:">
				<c path="String"/>
				<x path="funkin.backend.utils.ConsoleColor"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : LIGHTGRAY }</e></m></meta>
		</verbose>
		<warn public="1" get="inline" set="null" line="153" static="1">
			<f a="text:?color:?prefix" v=":YELLOW:">
				<c path="String"/>
				<x path="funkin.backend.utils.ConsoleColor"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : YELLOW }</e></m></meta>
		</warn>
		<error public="1" get="inline" set="null" line="156" static="1">
			<f a="text:?color:?prefix" v=":RED:">
				<c path="String"/>
				<x path="funkin.backend.utils.ConsoleColor"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : RED }</e></m></meta>
		</error>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.system.Level" params="" file="source/funkin/backend/system/Logs.hx" module="funkin.backend.system.Logs">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.system._Logs.Level_Impl_" params="" file="source/funkin/backend/system/Logs.hx" private="1" module="funkin.backend.system.Logs" extern="1" final="1">
	<INFO public="1" get="inline" set="null" expr="cast 0" line="160" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INFO>
	<WARNING public="1" get="inline" set="null" expr="cast 1" line="161" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WARNING>
	<ERROR public="1" get="inline" set="null" expr="cast 2" line="162" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ERROR>
	<TRACE public="1" get="inline" set="null" expr="cast 3" line="163" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TRACE>
	<VERBOSE public="1" get="inline" set="null" expr="cast 4" line="164" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VERBOSE>
	<SUCCESS public="1" get="inline" set="null" expr="cast 5" line="165" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SUCCESS>
	<FAILURE public="1" get="inline" set="null" expr="cast 6" line="166" static="1">
		<x path="funkin.backend.system.Level"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</FAILURE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.system._Logs.Level_Impl_" params="" file="source/funkin/backend/system/Logs.hx" private="1" module="funkin.backend.system.Logs" extern="1" final="1">
		<INFO public="1" get="inline" set="null" expr="cast 0" line="160" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INFO>
		<WARNING public="1" get="inline" set="null" expr="cast 1" line="161" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WARNING>
		<ERROR public="1" get="inline" set="null" expr="cast 2" line="162" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ERROR>
		<TRACE public="1" get="inline" set="null" expr="cast 3" line="163" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TRACE>
		<VERBOSE public="1" get="inline" set="null" expr="cast 4" line="164" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VERBOSE>
		<SUCCESS public="1" get="inline" set="null" expr="cast 5" line="165" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SUCCESS>
		<FAILURE public="1" get="inline" set="null" expr="cast 6" line="166" static="1">
			<x path="funkin.backend.system.Level"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</FAILURE>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="funkin.backend.system.LogText" params="" file="source/funkin/backend/system/Logs.hx" module="funkin.backend.system.Logs"><a>
	<text><c path="String"/></text>
	<color><x path="funkin.backend.utils.ConsoleColor"/></color>
</a></typedef>
	<typedef path="funkin.backend.system.AddonInfo" params="" file="source/funkin/backend/system/MainState.hx" module="funkin.backend.system.MainState">
		<a>
			<path><c path="String"/></path>
			<name><c path="String"/></name>
		</a>
		<meta><m n="dox"><e>hide</e></m></meta>
	</typedef>
	<class path="funkin.backend.system.MainState" params="" file="source/funkin/backend/system/MainState.hx">
		<extends path="flixel.FlxState"/>
		<initiated public="1" expr="false" line="26" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</initiated>
		<create public="1" set="method" line="27" override="1"><f a=""><x path="Void"/></f></create>
		<new public="1" set="method" line="25"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Simple state used for loading the game</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.OptimizedBitmapData" params="" file="source/funkin/backend/system/OptimizedBitmapData.hx">
		<extends path="openfl.display.BitmapData"/>
		<__fromImage set="method" line="11" override="1">
			<f a="image">
				<c path="lime.graphics.Image"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__fromImage>
		<getSurface public="1" set="method" line="50" override="1">
			<f a=""><x path="lime.graphics.cairo.CairoImageSurface"/></f>
			<meta>
				<m n="SuppressWarnings"><e>"checkstyle:Dynamic"</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</getSurface>
		<new public="1" set="method" line="8"><f a="width:height:?transparent:?fillColor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.embedBitmap()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.RotatingSpriteGroup" params="" file="source/funkin/backend/system/RotatingSpriteGroup.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<recycleLoop public="1" set="method" line="6">
			<f a="?ObjectClass:?ObjectFactory:?Force:?Revive" v="::false:true">
				<x path="Class"><c path="flixel.FlxSprite"/></x>
				<f a=""><c path="flixel.FlxSprite"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ Revive : true, Force : false }</e></m></meta>
		</recycleLoop>
		<new public="1" set="method" line="5"><f a="?X:?Y:?MaxSize">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.framerate.FramerateCategory" params="" file="source/funkin/backend/system/framerate/FramerateCategory.hx">
		<extends path="openfl.display.Sprite"/>
		<title public="1"><c path="openfl.text.TextField"/></title>
		<text public="1"><c path="openfl.text.TextField"/></text>
		<bgSprite public="1"><c path="openfl.display.Bitmap"/></bgSprite>
		<_text expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</_text>
		<reload public="1" set="method" line="43"><f a=""><x path="Void"/></f></reload>
		<__enterFrame public="1" set="method" line="45" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="16">
			<f a="title:?text" v=":&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ text : "" }</e></m></meta>
		</new>
		<meta>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.AssetTreeInfo" params="" file="source/funkin/backend/system/framerate/AssetTreeInfo.hx">
		<extends path="funkin.backend.system.framerate.FramerateCategory"/>
		<__enterFrame public="1" set="method" line="15" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.CodenameBuildField" params="" file="source/funkin/backend/system/framerate/CodenameBuildField.hx">
		<extends path="openfl.text.TextField"/>
		<reload public="1" set="method" line="15"><f a=""><x path="Void"/></f></reload>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.framerate.ConductorInfo" params="" file="source/funkin/backend/system/framerate/ConductorInfo.hx">
		<extends path="funkin.backend.system.framerate.FramerateCategory"/>
		<__enterFrame public="1" set="method" line="8" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="4"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.FlixelInfo" params="" file="source/funkin/backend/system/framerate/FlixelInfo.hx">
		<extends path="funkin.backend.system.framerate.FramerateCategory"/>
		<__enterFrame public="1" set="method" line="10" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.Framerate" params="" file="source/funkin/backend/system/framerate/Framerate.hx">
		<extends path="openfl.display.Sprite"/>
		<instance public="1" static="1"><c path="funkin.backend.system.framerate.Framerate"/></instance>
		<isLoaded public="1" expr="false" line="14" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isLoaded>
		<textFormat public="1" static="1"><c path="openfl.text.TextFormat"/></textFormat>
		<fpsCounter public="1" static="1"><c path="funkin.backend.system.framerate.FramerateCounter"/></fpsCounter>
		<memoryCounter public="1" static="1"><c path="funkin.backend.system.framerate.MemoryCounter"/></memoryCounter>
		<codenameBuildField public="1" static="1"><c path="funkin.backend.system.framerate.CodenameBuildField"/></codenameBuildField>
		<fontName public="1" expr="&quot;${Sys.getEnv(\&quot;windir\&quot;)}\\Fonts\\consola.ttf&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"${Sys.getEnv(\"windir\")}\\Fonts\\consola.ttf"</e></m></meta>
		</fontName>
		<debugMode public="1" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* 0: FPS INVISIBLE
	 * 1: FPS VISIBLE
	 * 2: FPS &amp; DEBUG INFO VISIBLE</haxe_doc>
		</debugMode>
		<offset public="1" expr="new FlxPoint()" line="31" static="1">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</offset>
		<__bitmap public="1" get="accessor" set="null" expr="null" line="37" static="1">
			<c path="openfl.display.BitmapData"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":isVar"/>
			</meta>
		</__bitmap>
		<get___bitmap set="method" line="39" static="1"><f a=""><c path="openfl.display.BitmapData"/></f></get___bitmap>
		<bgSprite public="1"><c path="openfl.display.Bitmap"/></bgSprite>
		<categories public="1" expr="[]">
			<c path="Array"><c path="funkin.backend.system.framerate.FramerateCategory"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</categories>
		<reload public="1" set="method" line="85"><f a=""><x path="Void"/></f></reload>
		<__addCategory set="method" line="95"><f a="category">
	<c path="funkin.backend.system.framerate.FramerateCategory"/>
	<x path="Void"/>
</f></__addCategory>
		<__lastAddedSprite expr="null">
			<c path="openfl.display.DisplayObject"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</__lastAddedSprite>
		<__addToList set="method" line="100"><f a="spr">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></__addToList>
		<debugAlpha expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</debugAlpha>
		<__enterFrame public="1" set="method" line="110" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.FramerateCounter" params="" file="source/funkin/backend/system/framerate/FramerateCounter.hx">
		<extends path="openfl.display.Sprite"/>
		<fpsNum public="1"><c path="openfl.text.TextField"/></fpsNum>
		<fpsLabel public="1"><c path="openfl.text.TextField"/></fpsLabel>
		<lastFPS public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastFPS>
		<reload public="1" set="method" line="30"><f a=""><x path="Void"/></f></reload>
		<__enterFrame public="1" set="method" line="32" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.MemoryCounter" params="" file="source/funkin/backend/system/framerate/MemoryCounter.hx">
		<extends path="openfl.display.Sprite"/>
		<memoryText public="1"><c path="openfl.text.TextField"/></memoryText>
		<memoryPeakText public="1"><c path="openfl.text.TextField"/></memoryPeakText>
		<memory public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</memory>
		<memoryPeak public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</memoryPeak>
		<reload public="1" set="method" line="33"><f a=""><x path="Void"/></f></reload>
		<__enterFrame public="1" set="method" line="35" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.framerate.SystemInfo" params="" file="source/funkin/backend/system/framerate/SystemInfo.hx">
		<extends path="funkin.backend.system.framerate.FramerateCategory"/>
		<osInfo public="1" expr="&quot;Unknown&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</osInfo>
		<gpuName public="1" expr="&quot;Unknown&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</gpuName>
		<vRAM public="1" expr="&quot;Unknown&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</vRAM>
		<cpuName public="1" expr="&quot;Unknown&quot;" line="17" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</cpuName>
		<totalMem public="1" expr="&quot;Unknown&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</totalMem>
		<memType public="1" expr="&quot;Unknown&quot;" line="19" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</memType>
		<gpuMaxSize public="1" expr="&quot;Unknown&quot;" line="20" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Unknown"</e></m></meta>
		</gpuMaxSize>
		<__formattedSysText expr="&quot;&quot;" line="22" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</__formattedSysText>
		<init public="1" set="method" line="24" static="1"><f a=""><x path="Void"/></f></init>
		<formatSysInfo set="method" line="140" static="1"><f a=""><x path="Void"/></f></formatSysInfo>
		<__enterFrame public="1" set="method" line="162" override="1"><f a="t">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<new public="1" set="method" line="158"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.github.GitHub" params="" file="source/funkin/backend/system/github/GitHub.hx">
		<getReleases public="1" set="method" line="23" static="1">
			<f a="user:repository:?onError">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="haxe.Exception"/>
					<x path="Void"/>
				</f>
				<c path="Array"><t path="funkin.backend.system.github.GitHubRelease"/></c>
			</f>
			<haxe_doc>* Gets all the releases from a specific GitHub repository using the GitHub API.
	 * @param user The user/organization that owns the repository
	 * @param repository The repository name
	 * @param onError Error Callback
	 * @return Releases</haxe_doc>
		</getReleases>
		<getContributors public="1" set="method" line="46" static="1">
			<f a="user:repository:?onError">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="haxe.Exception"/>
					<x path="Void"/>
				</f>
				<c path="Array"><t path="funkin.backend.system.github.GitHubContributor"/></c>
			</f>
			<haxe_doc>* Gets the contributors list from a specific GitHub repository using the GitHub API.
	 * @param user The user/organization that owns the repository
	 * @param repository The repository name
	 * @param onError Error Callback
	 * @return Contributors List</haxe_doc>
		</getContributors>
		<getOrganization public="1" set="method" line="68" static="1">
			<f a="org:?onError">
				<c path="String"/>
				<f a="">
					<c path="haxe.Exception"/>
					<x path="Void"/>
				</f>
				<t path="funkin.backend.system.github.GitHubOrganization"/>
			</f>
			<haxe_doc>* Gets a specific GitHub organization using the GitHub API.
	 * @param org The organization to get
	 * @param onError Error Callback
	 * @return Organization</haxe_doc>
		</getOrganization>
		<getOrganizationMembers public="1" set="method" line="91" static="1">
			<f a="org:?onError">
				<c path="String"/>
				<f a="">
					<c path="haxe.Exception"/>
					<x path="Void"/>
				</f>
				<c path="Array"><t path="funkin.backend.system.github.GitHubContributor"/></c>
			</f>
			<haxe_doc>* Gets the members list from a specific GitHub organization using the GitHub API.
	 * NOTE: Members use Contributors' structure!
	 * @param org The organization to get the members from
	 * @param onError Error Callback
	 * @return Members List</haxe_doc>
		</getOrganizationMembers>
		<getUser public="1" set="method" line="114" static="1">
			<f a="user:?onError">
				<c path="String"/>
				<f a="">
					<c path="haxe.Exception"/>
					<x path="Void"/>
				</f>
				<t path="funkin.backend.system.github.GitHubUser"/>
			</f>
			<haxe_doc>* Gets a specific GitHub user/organization using the GitHub API.
	 * NOTE: If organization, it will be returned with the structure of a normal user; use `getOrganization` if you specifically want an organization!
	 * @param user The user/organization to get
	 * @param onError Error Callback
	 * @return User/Organization</haxe_doc>
		</getUser>
		<filterReleases public="1" get="inline" set="null" line="140" static="1">
			<f a="releases:?keepPrereleases:?keepDrafts" v=":true:false">
				<c path="Array"><t path="funkin.backend.system.github.GitHubRelease"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><t path="funkin.backend.system.github.GitHubRelease"/></c>
			</f>
			<meta><m n=":value"><e>{ keepDrafts : false, keepPrereleases : true }</e></m></meta>
			<haxe_doc>* Filters all releases gotten by `getReleases`
	 * @param releases Releases
	 * @param keepPrereleases Whenever to keep Pre-Releases.
	 * @param keepDrafts Whenever to keep Drafts.
	 * @return Filtered releases.</haxe_doc>
		</filterReleases>
		<__parseGitHubException set="method" line="142" static="1"><f a="obj">
	<d/>
	<c path="funkin.backend.system.github.GitHubException"/>
</f></__parseGitHubException>
		<haxe_doc>* Set of functions to interact with GitHub.
 * Requires the `GITHUB_API` macro to be defined.
 * This has no authentication, so it's limited to unauthenticated requests, and rate limits.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.system.github.GitHubAsset" params="" file="source/funkin/backend/system/github/GitHubAsset.hx"><a>
	<url><c path="String"/></url>
	<uploader><t path="funkin.backend.system.github.GitHubUser"/></uploader>
	<updated_at><c path="String"/></updated_at>
	<state><c path="String"/></state>
	<size><x path="UInt"/></size>
	<node_id><c path="String"/></node_id>
	<name><c path="String"/></name>
	<label><c path="String"/></label>
	<id><x path="Int"/></id>
	<download_count><x path="Int"/></download_count>
	<created_at><c path="String"/></created_at>
	<content_type><c path="String"/></content_type>
	<browser_download_url><c path="String"/></browser_download_url>
</a></typedef>
	<typedef path="funkin.backend.system.github.GitHubContributor" params="" file="source/funkin/backend/system/github/GitHubContributor.hx"><a>
	<url><c path="String"/></url>
	<type><c path="String"/></type>
	<subscriptions_url><c path="String"/></subscriptions_url>
	<starred_url><c path="String"/></starred_url>
	<site_admin><x path="Bool"/></site_admin>
	<repos_url><c path="String"/></repos_url>
	<received_events_url><c path="String"/></received_events_url>
	<organizations_url><c path="String"/></organizations_url>
	<node_id><c path="String"/></node_id>
	<login><c path="String"/></login>
	<id><x path="Int"/></id>
	<html_url><c path="String"/></html_url>
	<gravatar_id><c path="String"/></gravatar_id>
	<gists_url><c path="String"/></gists_url>
	<following_url><c path="String"/></following_url>
	<followers_url><c path="String"/></followers_url>
	<events_url><c path="String"/></events_url>
	<contributions><x path="Int"/></contributions>
	<avatar_url><c path="String"/></avatar_url>
</a></typedef>
	<typedef path="funkin.backend.system.github.CreditsGitHubContributor" params="" file="source/funkin/backend/system/github/GitHubContributor.hx" module="funkin.backend.system.github.GitHubContributor"><a>
	<login><c path="String"/></login>
	<id>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</id>
	<html_url><c path="String"/></html_url>
	<contributions>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</contributions>
	<avatar_url><c path="String"/></avatar_url>
</a></typedef>
	<class path="funkin.backend.system.github.GitHubException" params="" file="source/funkin/backend/system/github/GitHubException.hx">
		<extends path="haxe.Exception"/>
		<apiMessage public="1"><c path="String"/></apiMessage>
		<documentationUrl public="1"><c path="String"/></documentationUrl>
		<new public="1" set="method" line="10"><f a="apiMessage:documentationUrl">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.system.github.GitHubOrganization" params="" file="source/funkin/backend/system/github/GitHubOrganization.hx"><a>
	<url><c path="String"/></url>
	<updated_at><c path="String"/></updated_at>
	<type><x path="funkin.backend.system.github.GitHubUserType"/></type>
	<twitter_username><c path="String"/></twitter_username>
	<repos_url><c path="String"/></repos_url>
	<public_repos><x path="Int"/></public_repos>
	<public_members_url><c path="String"/></public_members_url>
	<public_gists><x path="Int"/></public_gists>
	<node_id><c path="String"/></node_id>
	<name><c path="String"/></name>
	<members_url><c path="String"/></members_url>
	<login><c path="String"/></login>
	<location><c path="String"/></location>
	<issues_url><c path="String"/></issues_url>
	<is_verified><x path="Bool"/></is_verified>
	<id><x path="Int"/></id>
	<html_url><c path="String"/></html_url>
	<hooks_url><c path="String"/></hooks_url>
	<has_repository_projects><x path="Bool"/></has_repository_projects>
	<has_organization_projects><x path="Bool"/></has_organization_projects>
	<following><x path="Int"/></following>
	<followers><x path="Int"/></followers>
	<events_url><c path="String"/></events_url>
	<email><c path="String"/></email>
	<description><c path="String"/></description>
	<created_at><c path="String"/></created_at>
	<company><c path="String"/></company>
	<blog><c path="String"/></blog>
	<avatar_url><c path="String"/></avatar_url>
	<archived_at><c path="String"/></archived_at>
</a></typedef>
	<typedef path="funkin.backend.system.github.GitHubReactions" params="" file="source/funkin/backend/system/github/GitHubReactions.hx"><a>
	<url><c path="String"/></url>
	<total_count><x path="Int"/></total_count>
	<rocket><x path="Int"/></rocket>
	<laugh><x path="Int"/></laugh>
	<hooray><x path="Int"/></hooray>
	<heart><x path="Int"/></heart>
	<eyes><x path="Int"/></eyes>
	<confused><x path="Int"/></confused>
</a></typedef>
	<typedef path="funkin.backend.system.github.GitHubRelease" params="" file="source/funkin/backend/system/github/GitHubRelease.hx"><a>
	<zipball_url><c path="String"/></zipball_url>
	<url>
		<c path="String"/>
		<haxe_doc>* Url of the release (GitHub API)</haxe_doc>
	</url>
	<upload_url>
		<c path="String"/>
		<haxe_doc>* Template URL for asset download link.</haxe_doc>
	</upload_url>
	<target_commitish><c path="String"/></target_commitish>
	<tarball_url><c path="String"/></tarball_url>
	<tag_name><c path="String"/></tag_name>
	<reactions><t path="funkin.backend.system.github.GitHubReactions"/></reactions>
	<published_at><c path="String"/></published_at>
	<prerelease><x path="Bool"/></prerelease>
	<node_id><c path="String"/></node_id>
	<name><c path="String"/></name>
	<id>
		<x path="Int"/>
		<haxe_doc>* ID of the release.</haxe_doc>
	</id>
	<html_url>
		<c path="String"/>
		<haxe_doc>* Link to the release on the GitHub website.</haxe_doc>
	</html_url>
	<draft><x path="Bool"/></draft>
	<created_at><c path="String"/></created_at>
	<body>
		<c path="String"/>
		<haxe_doc>* Body of the GitHub request (Markdown)</haxe_doc>
	</body>
	<author>
		<t path="funkin.backend.system.github.GitHubUser"/>
		<haxe_doc>* Author of the release</haxe_doc>
	</author>
	<assets_url>
		<c path="String"/>
		<haxe_doc>* Url for the assets JSON. Also accessible via `GitHubRelease.assets`</haxe_doc>
	</assets_url>
	<assets><c path="Array"><t path="funkin.backend.system.github.GitHubAsset"/></c></assets>
</a></typedef>
	<typedef path="funkin.backend.system.github.GitHubUser" params="" file="source/funkin/backend/system/github/GitHubUser.hx"><a>
	<url>
		<c path="String"/>
		<haxe_doc>* URL to the user on GitHub's servers.</haxe_doc>
	</url>
	<updated_at>
		<c path="String"/>
		<haxe_doc>* Date of last account update.</haxe_doc>
	</updated_at>
	<type>
		<x path="funkin.backend.system.github.GitHubUserType"/>
		<haxe_doc>* Type of the user.</haxe_doc>
	</type>
	<twitter_username>
		<c path="String"/>
		<haxe_doc>* Twitter username of the user. Can be null.</haxe_doc>
	</twitter_username>
	<starred_url>
		<c path="String"/>
		<haxe_doc>* URL on GitHub's API to access this user's starred repositories.</haxe_doc>
	</starred_url>
	<site_admin>
		<x path="Bool"/>
		<haxe_doc>* Whenever the user is a GitHub administrator.</haxe_doc>
	</site_admin>
	<public_repos>
		<x path="Int"/>
		<haxe_doc>* Number of public repos this user own.</haxe_doc>
	</public_repos>
	<public_gists>
		<x path="Int"/>
		<haxe_doc>* Number of public gists this user own.</haxe_doc>
	</public_gists>
	<node_id>
		<c path="String"/>
		<haxe_doc>* ID of the current node on the GitHub database.</haxe_doc>
	</node_id>
	<name>
		<c path="String"/>
		<haxe_doc>* Name of the user.</haxe_doc>
	</name>
	<login>
		<c path="String"/>
		<haxe_doc>* Username of the user.</haxe_doc>
	</login>
	<location><c path="String"/></location>
	<id>
		<x path="Int"/>
		<haxe_doc>* ID of the user.</haxe_doc>
	</id>
	<html_url>
		<c path="String"/>
		<haxe_doc>* URL to the user on GitHub's website.</haxe_doc>
	</html_url>
	<hireable><x path="Null"><x path="Bool"/></x></hireable>
	<gravatar_id>
		<c path="String"/>
		<haxe_doc>* Unknown</haxe_doc>
	</gravatar_id>
	<gists_url>
		<c path="String"/>
		<haxe_doc>* URL on GitHub's API to access this user's gists.</haxe_doc>
	</gists_url>
	<following_url>
		<c path="String"/>
		<haxe_doc>* URL on GitHub's API to access the accounts this user is following.</haxe_doc>
	</following_url>
	<following>
		<x path="Int"/>
		<haxe_doc>* Number of accounts this user follows.</haxe_doc>
	</following>
	<followers_url>
		<c path="String"/>
		<haxe_doc>* URL on GitHub's API to access this user's followers.</haxe_doc>
	</followers_url>
	<followers>
		<x path="Int"/>
		<haxe_doc>* Number of followers this user have</haxe_doc>
	</followers>
	<email><c path="String"/></email>
	<created_at>
		<c path="String"/>
		<haxe_doc>* Date of creation of the account</haxe_doc>
	</created_at>
	<company>
		<c path="String"/>
		<haxe_doc>* The company this user belongs to. Can be `null`.</haxe_doc>
	</company>
	<blog><c path="String"/></blog>
	<bio><c path="String"/></bio>
	<avatar_url>
		<c path="String"/>
		<haxe_doc>* Link to the avatar (profile picture).</haxe_doc>
	</avatar_url>
</a></typedef>
	<abstract path="funkin.backend.system.github.GitHubUserType" params="" file="source/funkin/backend/system/github/GitHubUser.hx" module="funkin.backend.system.github.GitHubUser">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.system.github._GitHubUser.GitHubUserType_Impl_" params="" file="source/funkin/backend/system/github/GitHubUser.hx" private="1" module="funkin.backend.system.github.GitHubUser" extern="1" final="1">
	<USER public="1" get="inline" set="null" expr="cast &quot;User&quot;" line="128" static="1">
		<x path="funkin.backend.system.github.GitHubUserType"/>
		<meta>
			<m n=":value"><e>cast "User"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</USER>
	<ORGANIZATION public="1" get="inline" set="null" expr="cast &quot;Organization&quot;" line="129" static="1">
		<x path="funkin.backend.system.github.GitHubUserType"/>
		<meta>
			<m n=":value"><e>cast "Organization"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ORGANIZATION>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.system.github._GitHubUser.GitHubUserType_Impl_" params="" file="source/funkin/backend/system/github/GitHubUser.hx" private="1" module="funkin.backend.system.github.GitHubUser" extern="1" final="1">
		<USER public="1" get="inline" set="null" expr="cast &quot;User&quot;" line="128" static="1">
			<x path="funkin.backend.system.github.GitHubUserType"/>
			<meta>
				<m n=":value"><e>cast "User"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</USER>
		<ORGANIZATION public="1" get="inline" set="null" expr="cast &quot;Organization&quot;" line="129" static="1">
			<x path="funkin.backend.system.github.GitHubUserType"/>
			<meta>
				<m n=":value"><e>cast "Organization"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ORGANIZATION>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.system.macros.DefinesMacro" params="" file="source/funkin/backend/system/macros/DefinesMacro.hx">
		<defines public="1" get="accessor" set="null" static="1">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<haxe_doc>* Returns the defined values</haxe_doc>
		</defines>
		<get_defines get="inline" set="null" line="17" static="1"><f a=""><t path="Map">
	<c path="String"/>
	<d/>
</t></f></get_defines>
		<__getDefines set="method" static="1"><f a=""><d/></f></__getDefines>
	</class>
	<class path="funkin.backend.system.macros.GitCommitMacro" params="" file="source/funkin/backend/system/macros/GitCommitMacro.hx">
		<commitNumber public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>* Returns the current commit number</haxe_doc>
		</commitNumber>
		<commitHash public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* Returns the current commit hash</haxe_doc>
		</commitHash>
		<commitHashLong public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* Returns the current commit hash in long format</haxe_doc>
		</commitHashLong>
		<commitMessage public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* Returns the current commit message</haxe_doc>
		</commitMessage>
		<commitAuthor public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* Returns the current commit author</haxe_doc>
		</commitAuthor>
		<commitDate public="1" get="accessor" set="null" static="1">
			<c path="Date"/>
			<haxe_doc>* Returns the current commit date + time</haxe_doc>
		</commitDate>
		<currentBranch public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* Returns the current branch name</haxe_doc>
		</currentBranch>
		<hasUncommittedChanges public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* Returns if there are uncommitted changes</haxe_doc>
		</hasUncommittedChanges>
		<get_commitNumber get="inline" set="null" line="44" static="1"><f a=""><x path="Int"/></f></get_commitNumber>
		<get_commitHash get="inline" set="null" line="47" static="1"><f a=""><c path="String"/></f></get_commitHash>
		<get_commitHashLong get="inline" set="null" line="49" static="1"><f a=""><c path="String"/></f></get_commitHashLong>
		<get_commitMessage get="inline" set="null" line="52" static="1"><f a=""><c path="String"/></f></get_commitMessage>
		<get_commitAuthor get="inline" set="null" line="54" static="1"><f a=""><c path="String"/></f></get_commitAuthor>
		<get_commitDate get="inline" set="null" line="56" static="1"><f a=""><c path="Date"/></f></get_commitDate>
		<get_currentBranch get="inline" set="null" line="59" static="1"><f a=""><c path="String"/></f></get_currentBranch>
		<get_hasUncommittedChanges get="inline" set="null" line="61" static="1"><f a=""><x path="Bool"/></f></get_hasUncommittedChanges>
		<__getCommitHash set="method" static="1"><f a=""><d/></f></__getCommitHash>
		<__getCommitNumber set="method" static="1"><f a=""><d/></f></__getCommitNumber>
		<__getCommitHashLong set="method" static="1"><f a=""><d/></f></__getCommitHashLong>
		<__getCommitMessage set="method" static="1"><f a=""><d/></f></__getCommitMessage>
		<__getCommitAuthor set="method" static="1"><f a=""><d/></f></__getCommitAuthor>
		<__getCommitDate set="method" static="1"><f a=""><d/></f></__getCommitDate>
		<__getCurrentBranch set="method" static="1"><f a=""><d/></f></__getCurrentBranch>
		<__getHasUncommittedChanges set="method" static="1"><f a=""><d/></f></__getHasUncommittedChanges>
	</class>
	<class path="funkin.backend.system.macros.Utils" params="" file="source/funkin/backend/system/macros/Utils.hx">
		<generateReflectionLike public="1" set="method" static="1"><f a="totalArguments:funcName:argsName">
	<d/>
	<d/>
	<d/>
	<d/>
</f></generateReflectionLike>
		<safeSet public="1" set="method" static="1"><f a="variable:value">
	<d/>
	<d/>
	<d/>
</f></safeSet>
		<safeSetWrapper public="1" set="method" static="1"><f a="variable:value:wrapper">
	<d/>
	<d/>
	<d/>
	<d/>
</f></safeSetWrapper>
		<safeReflection public="1" set="method" static="1"><f a="variable:value:field">
	<d/>
	<d/>
	<d/>
	<d/>
</f></safeReflection>
	</class>
	<class path="funkin.backend.system.modules.ALSoftConfig" params="" file="source/funkin/backend/system/modules/ALSoftConfig.hx"><meta><m n=":keepInit"/></meta></class>
	<class path="funkin.backend.system.modules.AudioSwitchFix" params="" file="source/funkin/backend/system/modules/AudioSwitchFix.hx">
		<onAudioDisconnected public="1" set="method" line="17" static="1"><f a=""><x path="Void"/></f></onAudioDisconnected>
		<timer static="1"><c path="haxe.Timer"/></timer>
		<onRun set="method" line="64" static="1"><f a=""><x path="Void"/></f></onRun>
		<init public="1" set="method" line="65" static="1"><f a=""><x path="Void"/></f></init>
		<haxe_doc>* if you are stealing this keep this comment at least please lol
 *
 * hi gray itsa me yoshicrafter29 i fixed it hehe</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="funkin.backend.system.modules.CrashHandler" params="" file="source/funkin/backend/system/modules/CrashHandler.hx" final="1">
		<init public="1" set="method" line="11" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</init>
		<onUncaughtError public="1" set="method" line="20" static="1"><f a="e">
	<c path="openfl.events.UncaughtErrorEvent"/>
	<x path="Void"/>
</f></onUncaughtError>
		<onError set="method" line="62" static="1"><f a="message">
	<d/>
	<x path="Void"/>
</f></onError>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.modules.FunkinCache" params="" file="source/funkin/backend/system/modules/FunkinCache.hx">
		<extends path="openfl.utils.AssetCache"/>
		<instance public="1" static="1"><c path="funkin.backend.system.modules.FunkinCache"/></instance>
		<init public="1" set="method" line="35" static="1"><f a=""><x path="Void"/></f></init>
		<bitmapData2 public="1">
			<t path="Map">
				<c path="String"/>
				<c path="openfl.display.BitmapData"/>
			</t>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>Internal</haxe_doc>
		</bitmapData2>
		<font2 public="1">
			<t path="Map">
				<c path="String"/>
				<c path="openfl.text.Font"/>
			</t>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>Internal</haxe_doc>
		</font2>
		<sound2 public="1">
			<t path="Map">
				<c path="String"/>
				<c path="openfl.media.Sound"/>
			</t>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>Internal</haxe_doc>
		</sound2>
		<moveToSecondLayer public="1" set="method" line="47"><f a=""><x path="Void"/></f></moveToSecondLayer>
		<clearSecondLayer public="1" set="method" line="56"><f a=""><x path="Void"/></f></clearSecondLayer>
		<getBitmapData public="1" set="method" line="80" override="1">
			<f a="id">
				<c path="String"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<haxe_doc>Retrieves a cached BitmapData.

		@param	id	The ID of the cached BitmapData
		@return	The cached BitmapData instance</haxe_doc>
		</getBitmapData>
		<getFont public="1" set="method" line="99" override="1">
			<f a="id">
				<c path="String"/>
				<c path="openfl.text.Font"/>
			</f>
			<haxe_doc>Retrieves a cached Font.

		@param	id	The ID of the cached Font
		@return	The cached Font instance</haxe_doc>
		</getFont>
		<getSound public="1" set="method" line="118" override="1">
			<f a="id">
				<c path="String"/>
				<c path="openfl.media.Sound"/>
			</f>
			<haxe_doc>Retrieves a cached Sound.

		@param	id	The ID of the cached Sound
		@return	The cached Sound instance</haxe_doc>
		</getSound>
		<hasBitmapData public="1" set="method" line="137" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a BitmapData asset is cached.

		@param	id	The ID of a BitmapData asset
		@return	Whether the object has been cached</haxe_doc>
		</hasBitmapData>
		<hasFont public="1" set="method" line="148" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a Font asset is cached.

		@param	id	The ID of a Font asset
		@return	Whether the object has been cached</haxe_doc>
		</hasFont>
		<hasSound public="1" set="method" line="159" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a Sound asset is cached.

		@param	id	The ID of a Sound asset
		@return	Whether the object has been cached</haxe_doc>
		</hasSound>
		<removeBitmapData public="1" set="method" line="169" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a BitmapData from the cache.

		@param	id	The ID of a BitmapData asset
		@return	`true` if the asset was removed, `false` if it was not in the cache</haxe_doc>
		</removeBitmapData>
		<removeFont public="1" set="method" line="183" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a Font from the cache.

		@param	id	The ID of a Font asset
		@return	`true` if the asset was removed, `false` if it was not in the cache</haxe_doc>
		</removeFont>
		<removeSound public="1" set="method" line="197" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a Sound from the cache.

		@param	id	The ID of a Sound asset
		@return	`true` if the asset was removed, `false` if it was not in the cache</haxe_doc>
		</removeSound>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.system.net.Socket" params="" file="source/funkin/backend/system/net/Socket.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<socket public="1"><t path="sys.net._Socket.SysSocket"/></socket>
		<read public="1" set="method" line="19"><f a=""><c path="String"/></f></read>
		<write public="1" set="method" line="28"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></write>
		<host public="1" set="method" line="38">
			<f a="host:port:?nbConnections" v="::1">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nbConnections : 1 }</e></m></meta>
		</host>
		<hostAndWait public="1" set="method" line="44"><f a="h:port">
	<c path="sys.net.Host"/>
	<x path="Int"/>
	<c path="funkin.backend.system.net.Socket"/>
</f></hostAndWait>
		<acceptConnection public="1" set="method" line="49"><f a=""><c path="funkin.backend.system.net.Socket"/></f></acceptConnection>
		<connect public="1" set="method" line="56"><f a="host:port">
	<c path="sys.net.Host"/>
	<x path="Int"/>
	<x path="Void"/>
</f></connect>
		<destroy public="1" set="method" line="60"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="11"><f a="?socket">
	<t path="sys.net._Socket.SysSocket"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="funkin.backend.utils.AudioAnalyzerCallback" params="" file="source/funkin/backend/utils/AudioAnalyzer.hx" module="funkin.backend.utils.AudioAnalyzer"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></typedef>
	<class path="funkin.backend.utils.AudioAnalyzer" params="" file="source/funkin/backend/utils/AudioAnalyzer.hx" final="1">
		<getByte public="1" set="method" line="34" static="1">
			<f a="buffer:position:wordSize">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get bytes from an audio buffer with specified position and wordSize
	 * @param buffer The audio buffer to get byte from.
	 * @param position The specified position to get the byte from the audio buffer.
	 * @param wordSize How many bytes to get with to one byte (Usually it's bitsPerSample / 8 or bitsPerSample &gt;&gt; 3).
	 * @return Byte from the audio buffer with specified position.</haxe_doc>
		</getByte>
		<getLevelsFromFrequencies public="1" set="method" line="58" static="1">
			<f a="frequencies:sampleRate:barCount:?levels:?ratio:?minDb:?maxDb:?minFreq:?maxFreq" v="::::0.0:-63.0:-10.0:20.0:22000.0">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ maxFreq : 22000.0, minFreq : 20.0, maxDb : -10.0, minDb : -63.0, ratio : 0.0 }</e></m></meta>
			<haxe_doc>* Gets levels from the frequencies with specified sample rate.
	 * @param frequencies Frequencies input.
	 * @param sampleRate Sample Rate input.
	 * @param barCount How much bars to get.
	 * @param levels The output for getting the values, to avoid memory leaks (Optional).
	 * @param ratio How much ratio for smoothen the values from the previous levels values (Optional, use CoolUtil.getFPSRatio(1 - ratio) to simulate web AnalyserNode.smoothingTimeConstant, 0.35 of smoothingTime works most of the time).
	 * @param minDb The minimum decibels to cap (Optional, default -63.0, -120 is pure silence).
	 * @param maxDb The maximum decibels to cap (Optional, default -10.0, Above 0 is not recommended).
	 * @param minFreq The minimum frequency to cap (Optional, default 20.0, Below 8.0 is not recommended).
	 * @param maxFreq The maximum frequency to cap (Optional, default 22000.0, Above 23000.0 is not recommended).
	 * @return Output of levels/bars that ranges from 0 to 1.</haxe_doc>
		</getLevelsFromFrequencies>
		<__reverseIndices expr="[]" line="93" static="1">
			<c path="Array"><c path="Array"><x path="Int"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__reverseIndices>
		<__windows expr="[]" line="94" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__windows>
		<__twiddleReals expr="[]" line="95" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__twiddleReals>
		<__twiddleImags expr="[]" line="96" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__twiddleImags>
		<__freqReals expr="[]" line="97" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__freqReals>
		<__freqImags expr="[]" line="98" static="1">
			<c path="Array"><c path="Array"><x path="Float"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__freqImags>
		<__mutex expr="new Mutex()" line="100" static="1">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new Mutex()</e></m></meta>
		</__mutex>
		<__freqCalculating expr="0" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__freqCalculating>
		<getFrequenciesFromSamples public="1" set="method" line="112" static="1">
			<f a="samples:?fftN:?useWindowing:?frequencies" v=":2048:false:">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ useWindowing : false, fftN : 2048 }</e></m></meta>
			<haxe_doc>* Gets frequencies from the samples.
	 * @param samples The samples (can be from AudioAnalyzer.getSamples).
	 * @param fftN How much samples for the fft to get, Has to be power of two, or it won't work.
	 * @param useWindowing Should fft related stuff use blackman windowing? (Web AnalyzerNode windowing), Most of the time it's not worth it.
	 * @param frequencies The output for getting the frequencies, to avoid memory leaks (Optional).
	 * @return Output of frequencies.</haxe_doc>
		</getFrequenciesFromSamples>
		<__bitReverse set="method" line="215" static="1"><f a="x:log">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></__bitReverse>
		<sound public="1">
			<c path="flixel.sound.FlxSound"/>
			<haxe_doc>* The current sound to analyze.</haxe_doc>
		</sound>
		<fftN public="1">
			<x path="Int"/>
			<haxe_doc>* How much samples for the fft to get.
	 * Usually for getting the levels or frequencies of the sound.
	 * 
	 * Has to be power of two, or it won't work.</haxe_doc>
		</fftN>
		<useWindowingFFT public="1">
			<x path="Bool"/>
			<haxe_doc>* Should fft related stuff use blackman windowing? (Web AnalyzerNode windowing).
	 * Most of the time looks bad with this.</haxe_doc>
		</useWindowingFFT>
		<buffer public="1" set="null">
			<c path="lime.media.AudioBuffer"/>
			<haxe_doc>* The current buffer from sound.</haxe_doc>
		</buffer>
		<byteSize public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The current byteSize from buffer.
	 * Example the byteSize of 16 BitsPerSample is 32768 (1 &lt;&lt; 16-1)</haxe_doc>
		</byteSize>
		<__toBits><x path="Float"/></__toBits>
		<__wordSize><x path="Int"/></__wordSize>
		<__sampleSize><x path="Int"/></__sampleSize>
		<__vorbis><c path="lime.media.vorbis.VorbisFile"/></__vorbis>
		<__buffer><x path="lime.utils.ArrayBuffer"/></__buffer>
		<__bufferSize><x path="Int"/></__bufferSize>
		<__bufferLastSize><x path="Int"/></__bufferLastSize>
		<__bufferTime><x path="Float"/></__bufferTime>
		<__bufferLastTime><x path="Float"/></__bufferLastTime>
		<__min expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__min>
		<__max expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__max>
		<__minByte><x path="Int"/></__minByte>
		<__maxByte><x path="Int"/></__maxByte>
		<__sampleIndex><x path="Int"/></__sampleIndex>
		<__sampleChannel><x path="Int"/></__sampleChannel>
		<__sampleToValue><x path="Float"/></__sampleToValue>
		<__sampleOutputMerge><x path="Bool"/></__sampleOutputMerge>
		<__sampleOutputLength><x path="Int"/></__sampleOutputLength>
		<__sampleOutput><c path="Array"><x path="Float"/></c></__sampleOutput>
		<__freqSamples><c path="Array"><x path="Float"/></c></__freqSamples>
		<__frequencies><c path="Array"><x path="Float"/></c></__frequencies>
		<__check set="method" line="299"><f a=""><x path="Void"/></f></__check>
		<getLevels public="1" set="method" line="328">
			<f a="startPos:?volume:barCount:?levels:?ratio:?minDb:?maxDb:?minFreq:?maxFreq">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Gets levels from an attached FlxSound from startPos, basically a minimized of frequencies.
	 * @param startPos Start Position to get from sound in milliseconds.
	 * @param volume How much volume multiplier will it affect the output. (Optional, default 1.0).
	 * @param barCount How much bars to get.
	 * @param levels The output for getting the values, to avoid memory leaks (Optional).
	 * @param ratio How much ratio for smoothen the values from the previous levels values (Optional, use CoolUtil.getFPSRatio(1 - ratio) to simulate web AnalyserNode.smoothingTimeConstant, 0.35 of smoothingTime works most of the time).
	 * @param minDb The minimum decibels to cap (Optional, default -63.0, -120 is pure silence).
	 * @param maxDb The maximum decibels to cap (Optional, default -10.0, Above 0 is not recommended).
	 * @param minFreq The minimum frequency to cap (Optional, default 20.0, Below 8.0 is not recommended).
	 * @param maxFreq The maximum frequency to cap (Optional, default 22000.0, Above 23000.0 is not recommended).
	 * @return Output of levels/bars that ranges from 0 to 1.</haxe_doc>
		</getLevels>
		<getFrequencies public="1" set="method" line="338">
			<f a="startPos:?volume:?frequencies">
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Gets frequencies from an attached FlxSound from startPos.
	 * @param startPos Start Position to get from sound in milliseconds.
	 * @param volume How much volume multiplier will it affect the output. (Optional, default 1.0).
	 * @param frequencies The output for getting the frequencies, to avoid memory leaks (Optional).
	 * @return Output of frequencies.</haxe_doc>
		</getFrequencies>
		<analyze public="1" set="method" line="348">
			<f a="startPos:endPos:?outOrOutMin:?outMax">
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<haxe_doc>* Analyzes an attached FlxSound from startPos to endPos in milliseconds to get the amplitudes.
	 * @param startPos Start Position to get from sound in milliseconds.
	 * @param endPos End Position to get from sound in milliseconds.
	 * @param outOrOutMin The output minimum value from the analyzer, indices is in channels (0 to -0.5 -&gt; 0 to 0.5) (Optional, if outMax doesn't get passed in, it will be [min, max] with all channels combined instead).
	 * @param outMax The output maximum value from the analyzer, indices is in channels (Optional).
	 * @return Output of amplitude from given position.</haxe_doc>
		</analyze>
		<__analyzeCallback set="method" line="375"><f a="b:c">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__analyzeCallback>
		<__analyzeCallbackSimple set="method" line="378"><f a="b:c">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__analyzeCallbackSimple>
		<getSamples public="1" set="method" line="391">
			<f a="startPos:length:?mono:?channel:?volume:?output:?outputMerge" v="::true:-1:1.0::false">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ outputMerge : false, volume : 1.0, channel : -1, mono : true }</e></m></meta>
			<haxe_doc>* Gets samples from startPos with given length of samples.
	 * @param startPos Start Position to get from sound in milliseconds.
	 * @param length Length of Samples.
	 * @param mono Merge all of the byte channels of samples in one channel instead (Optional).
	 * @param channel What channels to get from? (-1 == All Channels, Optional, this will be ignored if mono is enabled).
	 * @param volume How much volume multiplier will it affect the output. (Optional, default 1.0).
	 * @param output An Output that gets passed into this function, usually for to avoid memory leaks (Optional).
	 * @param outputMerge Merge with previous values (Optional, default false).
	 * @return Output of samples.</haxe_doc>
		</getSamples>
		<__getSamplesCallbackMono set="method" line="405"><f a="b:c">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__getSamplesCallbackMono>
		<__getSamplesCallbackChannel set="method" line="418"><f a="b:c">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__getSamplesCallbackChannel>
		<__getSamplesCallback set="method" line="426"><f a="b:c">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__getSamplesCallback>
		<read public="1" set="method" line="438">
			<f a="startPos:endPos:callback">
				<x path="Float"/>
				<x path="Float"/>
				<t path="funkin.backend.utils.AudioAnalyzerCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Read an attached FlxSound from startPos to endPos in milliseconds with a callback.
	 * @param startPos Start Position to get from sound in milliseconds.
	 * @param endPos End Position to get from sound in milliseconds.
	 * @param callback Int-&gt;Int-&gt;Void Byte-&gt;Channels-&gt;Void Callback to get the byte of a sample.</haxe_doc>
		</read>
		<__read get="inline" set="null" line="443"><f a="startPos:endPos:callback">
	<x path="Float"/>
	<x path="Float"/>
	<t path="funkin.backend.utils.AudioAnalyzerCallback"/>
	<x path="Void"/>
</f></__read>
		<__readData get="inline" set="null" line="453"><f a="startPos:endPos:callback">
	<x path="Float"/>
	<x path="Float"/>
	<t path="funkin.backend.utils.AudioAnalyzerCallback"/>
	<x path="Void"/>
</f></__readData>
		<__canReadStream get="inline" set="null" line="467"><f a=""><x path="Bool"/></f></__canReadStream>
		<__readStream get="inline" set="null" line="469"><f a="startPos:endPos:callback">
	<x path="Float"/>
	<x path="Float"/>
	<t path="funkin.backend.utils.AudioAnalyzerCallback"/>
	<x path="Float"/>
</f></__readStream>
		<__prepareDecoder get="inline" set="null" line="505"><f a=""><x path="Bool"/></f></__prepareDecoder>
		<__readDecoder get="inline" set="null" line="515"><f a="startPos:endPos:callback">
	<x path="Float"/>
	<x path="Float"/>
	<t path="funkin.backend.utils.AudioAnalyzerCallback"/>
	<x path="Void"/>
</f></__readDecoder>
		<new public="1" set="method" line="292">
			<f a="sound:?fftN:?useWindowingFFT" v=":2048:false">
				<c path="flixel.sound.FlxSound"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWindowingFFT : false, fftN : 2048 }</e></m></meta>
			<haxe_doc>* Creates an analyzer for specified FlxSound
	 * @param sound An FlxSound to analyze.
	 * @param fftN How much samples for fft to get (Optional, default 2048, 4096 is recommended for highest quality).
	 * @param useWindowingFFT Should fft related stuff use blackman windowing? (Web AnalyzerNode windowing).</haxe_doc>
		</new>
		<haxe_doc>* An utility that analyze FlxSounds,
 * can be used to make waveform or real-time audio visualizer.
 * 
 * FlxSound.amplitude does work in CNE so if any case if your only checking for peak of current
 * time, use that instead.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.BitmapUtil" params="" file="source/funkin/backend/utils/BitmapUtil.hx" final="1">
		<getMostPresentColor public="1" set="method" line="14" static="1">
			<f a="bmap">
				<c path="openfl.display.BitmapData"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<haxe_doc>* Returns the most present color in a Bitmap.
	 * @param bmap Bitmap
	 * @return FlxColor Color that is the most present.</haxe_doc>
		</getMostPresentColor>
		<getMostPresentSaturatedColor public="1" set="method" line="45" static="1">
			<f a="bmap">
				<c path="openfl.display.BitmapData"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<haxe_doc>* Returns the most present saturated color in a Bitmap.
	 * @param bmap Bitmap
	 * @return FlxColor Color that is the most present.</haxe_doc>
		</getMostPresentSaturatedColor>
		<crop public="1" set="method" line="76" static="1">
			<f a="bitmap">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<haxe_doc>* Returns a new bitmap without any empty transperent space on the edges
	 * @param bitmap The bitmap to be cropped</haxe_doc>
		</crop>
		<bounds public="1" set="method" line="89" static="1">
			<f a="bitmap:?limit" v=":null">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ limit : null }</e></m></meta>
			<haxe_doc>* Get bounds of non empty pixels in the bitmap
	 * @param bitmap
	 * @return</haxe_doc>
		</bounds>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.ControlsUtil" params="" file="source/funkin/backend/utils/ControlsUtil.hx">
		<storedCustomControls expr="[]" line="16" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</storedCustomControls>
		<initCustomControl public="1" set="method" line="18" static="1"><f a="controls:name">
	<c path="funkin.backend.system.Controls"/>
	<c path="String"/>
	<x path="Void"/>
</f></initCustomControl>
		<addKeysToCustomControl public="1" set="method" line="27" static="1"><f a="controls:name:keys">
	<c path="funkin.backend.system.Controls"/>
	<c path="String"/>
	<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
	<x path="Void"/>
</f></addKeysToCustomControl>
		<removeKeysFromCustomControl public="1" set="method" line="40" static="1"><f a="controls:name:keys">
	<c path="funkin.backend.system.Controls"/>
	<c path="String"/>
	<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
	<x path="Void"/>
</f></removeKeysFromCustomControl>
		<resetCustomControls public="1" set="method" line="53" static="1"><f a=""><x path="Void"/></f></resetCustomControls>
		<removeCustomControls get="inline" set="null" line="60" static="1"><f a="controls">
	<c path="funkin.backend.system.Controls"/>
	<x path="Void"/>
</f></removeCustomControls>
		<checkControl get="inline" set="null" line="78" static="1"><f a="controls:name">
	<c path="funkin.backend.system.Controls"/>
	<c path="String"/>
	<x path="Bool"/>
</f></checkControl>
		<getControl public="1" get="inline" set="null" line="84" static="1"><f a="controls:name">
	<c path="funkin.backend.system.Controls"/>
	<c path="String"/>
	<c path="flixel.input.actions.FlxActionDigital"/>
</f></getControl>
		<getJustPressed public="1" get="inline" set="null" line="88" static="1"><f a="controls:name">
	<c path="funkin.backend.system.Controls"/>
	<c path="String"/>
	<x path="Bool"/>
</f></getJustPressed>
		<getJustReleased public="1" get="inline" set="null" line="91" static="1"><f a="controls:name">
	<c path="funkin.backend.system.Controls"/>
	<c path="String"/>
	<x path="Bool"/>
</f></getJustReleased>
		<getPressed public="1" get="inline" set="null" line="94" static="1"><f a="controls:name">
	<c path="funkin.backend.system.Controls"/>
	<c path="String"/>
	<x path="Bool"/>
</f></getPressed>
		<loadCustomControls public="1" set="method" line="98" static="1"><f a=""><x path="Void"/></f></loadCustomControls>
		<parseControlsXml get="inline" set="null" line="116" static="1"><f a="xml">
	<x path="haxe.xml.Access"/>
	<x path="Void"/>
</f></parseControlsXml>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.CoolUtil" params="" file="source/funkin/backend/utils/CoolUtil.hx" final="1">
		<getLastExceptionStack public="1" set="method" line="63" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Gets the last exception stack. Useful for debugging.</haxe_doc>
		</getLastExceptionStack>
		<isNotNull public="1" get="inline" set="null" line="72" static="1"><f a="v">
	<x path="Null"><d/></x>
	<x path="Bool"/>
</f></isNotNull>
		<getDefault public="1" params="T" get="inline" set="null" line="82" static="1"><f a="v:defaultValue">
	<x path="Null"><c path="getDefault.T"/></x>
	<c path="getDefault.T"/>
	<c path="getDefault.T"/>
</f></getDefault>
		<getDefaultFloat public="1" get="inline" set="null" line="92" static="1">
			<f a="v:defaultValue">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* For use when using Std.parseFloat, if not using that then use `getDefault`.
	 * @param v The value
	 * @param defaultValue The default value
	 * @return The return value</haxe_doc>
		</getDefaultFloat>
		<positiveModulo public="1" get="inline" set="null" line="103" static="1">
			<f a="dividend:divisor">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Applies the % operator, but without any negatives.
	 *
	 * @param dividend The intial value. The left side of the equation.
	 * @param divisor What to modulo by. The right side of the equation.
	 * @return A positive reminder of `dividend / divisor`.</haxe_doc>
		</positiveModulo>
		<positiveModuloInt public="1" get="inline" set="null" line="114" static="1">
			<f a="dividend:divisor">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Applies the % operator, but without any negatives. But it's an int.
	 *
	 * @param dividend The intial value. The left side of the equation.
	 * @param divisor What to modulo by. The right side of the equation.
	 * @return A positive reminder of `dividend / divisor`.</haxe_doc>
		</positiveModuloInt>
		<parseJson public="1" set="method" line="122" static="1">
			<f a="assetPath">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>* Shortcut to parse JSON from an Asset path
	 * @param assetPath Path to the JSON asset.</haxe_doc>
		</parseJson>
		<deleteFolder public="1" set="method" line="130" static="1">
			<f a="delete">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Deletes a folder recursively
	 * @param delete Path to the folder.</haxe_doc>
		</deleteFolder>
		<safeSaveFile public="1" set="method" line="151" static="1">
			<f a="path:content:?showErrorBox" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<c path="String"/>
					<c path="haxe.io.Bytes"/>
				</x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ showErrorBox : true }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Safe saves a file (even adding eventual missing folders) and shows a warning box instead of making the program crash
	 * @param path Path to save the file at.
	 * @param content Content of the file to save (as String or Bytes).</haxe_doc>
		</safeSaveFile>
		<safeGetAttributes public="1" get="inline" set="null" line="172" static="1">
			<f a="path:?useAbsolute" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="funkin.backend.utils.FileAttributeWrapper"/>
			</f>
			<meta>
				<m n=":value"><e>{ useAbsolute : true }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Gets file attributes from a file or a folder adding eventual missing folders in the path
	 * (WARNING: Only works on `windows` for now. On other platforms the attributes' value it's always going to be `0` -thanks to the wrapper you can also use `isNothing` for checking- but still creates eventual missing folders if the platforms allows it to).
	 * @param path Path to the file or folder
	 * @param useAbsolute If it should use the absolute path (By default it's `true` but if it's `false` you can use files outside from this program's directory for example)
	 * @return The attributes through the `FileAttributeWrapper`</haxe_doc>
		</safeGetAttributes>
		<safeSetAttributes public="1" get="inline" set="null" line="192" static="1">
			<f a="path:attrib:?useAbsolute" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfThree">
					<x path="funkin.backend.utils.FileAttribute"/>
					<c path="funkin.backend.utils.FileAttributeWrapper"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ useAbsolute : true }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Sets file attributes to a file or a folder adding eventual missing folders in the path
	 * (WARNING: Only works on `windows` for now. On other platforms the return code it's always going to be `0` but still creates eventual missing folders if the platforms allows it to).
	 * @param path Path to the file or folder
	 * @param attrib The attribute(s) to set (WARNING: There are some non settable attributes, such as the `COMPRESSED` one)
	 * @param useAbsolute If it should use the absolute path (By default it's `true` but if it's `false` you can use files outside from this program's directory for example)
	 * @return The result code: `0` means that it failed setting</haxe_doc>
		</safeSetAttributes>
		<safeAddAttributes public="1" get="inline" set="null" line="213" static="1">
			<f a="path:attrib:?useAbsolute" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<x path="funkin.backend.utils.FileAttribute"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ useAbsolute : true }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Adds one (or more) file attributes to a file or a folder adding eventual missing folders in the path
	 * (WARNING: Only works on `windows` for now. On other platforms the return code it's always going to be `0` but still creates eventual missing folders if the platforms allows it to).
	 * @param path Path to the file or folder
	 * @param attrib The attribute(s) to add (WARNING: There are some non settable attributes, such as the `COMPRESSED` one)
	 * @param useAbsolute If it should use the absolute path (By default it's `true` but if it's `false` you can use files outside from this program's directory for example)
	 * @return The result code: `0` means that it failed setting</haxe_doc>
		</safeAddAttributes>
		<safeRemoveAttributes public="1" get="inline" set="null" line="233" static="1">
			<f a="path:attrib:?useAbsolute" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<x path="funkin.backend.utils.FileAttribute"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ useAbsolute : true }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Removes one (or more) file attributes to a file or a folder adding eventual missing folders in the path
	 * (WARNING: Only works on `windows` for now. On other platforms the return code it's always going to be `0` but still creates eventual missing folders if the platforms allows it to).
	 * @param path Path to the file or folder
	 * @param attrib The attribute(s) to remove (WARNING: There are some non settable attributes, such as the `COMPRESSED` one)
	 * @param useAbsolute If it should use the absolute path (By default it's `true` but if it's `false` you can use files outside from this program's directory for example)
	 * @return The result code: `0` means that it failed setting</haxe_doc>
		</safeRemoveAttributes>
		<addMissingFolders public="1" set="method" line="253" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Creates eventual missing folders to the specified `path`
	 *
	 * WARNING: eventual files in `path` will be considered as folders! Just to make possible folders be named as `songs.json` for example
	 *
	 * @param path Path to check.
	 * @return The initial Path.</haxe_doc>
		</addMissingFolders>
		<parseJsonString public="1" get="inline" set="null" line="273" static="1">
			<f a="str">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>* Shortcut to parse a JSON string
	 * @param str Path to the JSON string
	 * @return Parsed JSON</haxe_doc>
		</parseJsonString>
		<isNaN public="1" get="inline" set="null" line="279" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Whenever a value is NaN or not.
	 * @param v Value</haxe_doc>
		</isNaN>
		<first public="1" params="T" get="inline" set="null" line="288" static="1">
			<f a="array">
				<c path="Array"><c path="first.T"/></c>
				<c path="first.T"/>
			</f>
			<haxe_doc>* Returns the first element of an Array
	 * @param array Array
	 * @return T Last element</haxe_doc>
		</first>
		<last public="1" params="T" get="inline" set="null" line="297" static="1">
			<f a="array">
				<c path="Array"><c path="last.T"/></c>
				<c path="last.T"/>
			</f>
			<haxe_doc>* Returns the last element of an Array
	 * @param array Array
	 * @return T Last element</haxe_doc>
		</last>
		<setFieldDefault public="1" params="T" set="method" line="308" static="1">
			<f a="v:name:defaultValue">
				<d/>
				<c path="String"/>
				<c path="setFieldDefault.T"/>
				<c path="setFieldDefault.T"/>
			</f>
			<haxe_doc>* Sets a field's default value, and returns it. In case it already exists, returns the existing one.
	 * @param v Dynamic to set the default value to
	 * @param name Name of the value
	 * @param defaultValue Default value
	 * @return T New/old value.</haxe_doc>
		</setFieldDefault>
		<addZeros public="1" get="inline" set="null" line="323" static="1">
			<f a="str:num">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Add several zeros at the beginning of a string, so that `2` becomes `02`.
	 * @param str String to add zeros
	 * @param num The length required</haxe_doc>
		</addZeros>
		<addEndZeros public="1" get="inline" set="null" line="333" static="1">
			<f a="str:num">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Add several zeros at the end of a string, so that `2` becomes `20`, useful for ms.
	 * @param str String to add zeros
	 * @param num The length required</haxe_doc>
		</addEndZeros>
		<sizeLabels expr="[&quot;B&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;]" line="338" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["B", "KB", "MB", "GB", "TB"]</e></m></meta>
		</sizeLabels>
		<getSizeString public="1" set="method" line="345" static="1">
			<f a="size">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns a string representation of a size, following this format: `1.02 GB`, `134.00 MB`
	 * @param size Size to convert to string
	 * @return String Result string representation</haxe_doc>
		</getSizeString>
		<getSizeString64 public="1" set="method" line="361" static="1">
			<f a="size">
				<x path="cpp.Float64"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns a string representation of a size, following this format: `1.02 GB`, `134.00 MB`, using Float64 on cpp targets
	 * @param size Size to convert to string
	 * @return String Result string representation</haxe_doc>
		</getSizeString64>
		<removeIP public="1" get="inline" set="null" line="378" static="1">
			<f a="msg">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Replaces in a string any kind of IP with `[Your IP]` making the string safer to trace.
	 * @param msg String to check and edit
	 * @return String Result without any kind of IP</haxe_doc>
		</removeIP>
		<fpsLerp public="1" get="inline" set="null" line="389" static="1">
			<f a="v1:v2:ratio">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Alternative linear interpolation function for each frame use, without worrying about framerate changes.
	 * @param v1 Begin value
	 * @param v2 End value
	 * @param ratio Ratio
	 * @return Float Final value</haxe_doc>
		</fpsLerp>
		<lerpColor public="1" get="inline" set="null" line="399" static="1">
			<f a="color1:color2:ratio:?fpsSensitive" v=":::false">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta>
				<m n=":value"><e>{ fpsSensitive : false }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Lerps from color1 into color2 (Shortcut to `FlxColor.interpolate`)
	 * @param color1 Color 1
	 * @param color2 Color 2
	 * @param ratio Ratio
	 * @param fpsSensitive Whenever the ratio should be fps sensitive (adapted when game is running at 120 instead of 60)</haxe_doc>
		</lerpColor>
		<getFPSRatio public="1" get="inline" set="null" line="412" static="1">
			<f a="ratio:?delta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Modifies a lerp ratio based on current FPS to keep a stable speed on higher framerate.
	 * @param ratio Ratio
	 * @param delta Delta/Elapsed for the fps-modified ratio (Optional)
	 * @return FPS-Modified Ratio</haxe_doc>
		</getFPSRatio>
		<getColorFromDynamic public="1" set="method" line="419" static="1">
			<f a="c">
				<d/>
				<x path="Null"><x path="flixel.util.FlxColor"/></x>
			</f>
			<haxe_doc>* Tries to get a color from a `Dynamic` variable.
	 * @param c `Dynamic` color.
	 * @return The result color, or `null` if invalid.</haxe_doc>
		</getColorFromDynamic>
		<playMenuSong public="1" set="method" line="455" static="1">
			<f a="?fadeIn" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ fadeIn : false }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Plays the main menu theme.
	 * @param fadeIn</haxe_doc>
		</playMenuSong>
		<preloadCharacter public="1" set="method" line="469" static="1">
			<f a="name:?spriteName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Preloads a character.
	 * @param name Character name
	 * @param spriteName (Optional) sprite name.</haxe_doc>
		</preloadCharacter>
		<playMusic public="1" set="method" line="486" static="1">
			<f a="path:?Persist:?Volume:?Looped:?DefaultBPM:?Group" v=":false:1:true:102:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="flixel.sound.FlxSoundGroup"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ DefaultBPM : 102, Looped : true, Volume : 1, Persist : false }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Plays music, while resetting the Conductor, and taking info from INI in count.
	 * @param path Path to the music
	 * @param Persist Whenever the music should persist while switching states
	 * @param DefaultBPM Default BPM of the music (102)
	 * @param Volume Volume of the music (1)
	 * @param Looped Whenever the music loops (true)
	 * @param Group A group that this music belongs to (default)</haxe_doc>
		</playMusic>
		<playMenuSFX public="1" get="inline" set="null" line="523" static="1">
			<f a="?menuSFX:?volume" v="SCROLL:1">
				<x path="funkin.backend.utils.CoolSfx"/>
				<x path="Float"/>
				<c path="flixel.sound.FlxSound"/>
			</f>
			<meta>
				<m n=":value"><e>{ volume : 1, menuSFX : SCROLL }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Plays a specified Menu SFX.
	 * @param menuSFX Menu SFX to play
	 * @param volume At which volume it should play</haxe_doc>
		</playMenuSFX>
		<coolTextFile public="1" set="method" line="546" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Allows you to split a text file from a path, into a "cool text file", AKA a list. Allows for comments. For example,
	 * `# comment`
	 * `test1`
	 * ` `
	 * `test2`
	 * will return `["test1", "test2"]`
	 * @param path
	 * @return Array&lt;String&gt;</haxe_doc>
		</coolTextFile>
		<numberArray public="1" get="inline" set="null" line="558" static="1">
			<f a="max:?min" v=":0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ min : 0 }</e></m>
				<m n=":noUsing"/>
			</meta>
			<haxe_doc>* Returns an array of number from min to max. Equivalent of `[for (i in min...max) i]`.
	 * @param max Max value
	 * @param min Minimal value (0)
	 * @return Array&lt;Int&gt; Final array</haxe_doc>
		</numberArray>
		<numberArrayOld public="1" get="inline" set="null" line="575" static="1">
			<f a="max:?min" v=":0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta>
				<m n=":value"><e>{ min : 0 }</e></m>
				<m n=":noUsing"/>
			</meta>
		</numberArrayOld>
		<switchAnimFrames public="1" set="method" line="584" static="1">
			<f a="anim1:anim2">
				<c path="flixel.animation.FlxAnimation"/>
				<c path="flixel.animation.FlxAnimation"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Switches frames from 2 FlxAnimations.
	 * @param anim1 First animation
	 * @param anim2 Second animation</haxe_doc>
		</switchAnimFrames>
		<setUnstretchedGraphicSize public="1" get="inline" set="null" line="599" static="1">
			<f a="sprite:width:height:?fill:?maxScale" v=":::true:0">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maxScale : 0, fill : true }</e></m></meta>
			<haxe_doc>* Allows you to set a graphic size (ex: 150x150), with proper hitbox without a stretched sprite.
	 * @param sprite Sprite to apply the new graphic size to
	 * @param width Width
	 * @param height Height
	 * @param fill Whenever the sprite should fill instead of shrinking (true)
	 * @param maxScale Maximum scale (0 / none)</haxe_doc>
		</setUnstretchedGraphicSize>
		<setGraphicSizeFloat public="1" set="method" line="608" static="1">
			<f a="sprite:?Width:?Height" v=":0:0">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Height : 0, Width : 0 }</e></m></meta>
		</setGraphicSizeFloat>
		<keyToString public="1" get="inline" set="null" line="627" static="1">
			<f a="key">
				<x path="Null"><x path="flixel.input.keyboard.FlxKey"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns a simple string representation of a FlxKey. Used in Controls options.
	 * @param key Key
	 * @return Simple representation</haxe_doc>
		</keyToString>
		<cameraCenter public="1" get="inline" set="null" line="670" static="1">
			<f a="obj:cam:?axes" v="::XY">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxCamera"/>
				<x path="flixel.util.FlxAxes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ axes : XY }</e></m></meta>
			<haxe_doc>* Centers an object in a camera's field, basically `screenCenter()` but `camera.width` and `camera.height` are used instead of `FlxG.width` and `FlxG.height`.
	 * @param obj Sprite to center
	 * @param cam Camera
	 * @param axes Axes (XY)</haxe_doc>
		</cameraCenter>
		<setSpriteSize public="1" get="inline" set="null" line="688" static="1">
			<f a="sprite:width:height">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Equivalent of `setGraphicSize`, except that it can accept floats and automatically updates the hitbox.
	 * @param sprite Sprite to set the size of
	 * @param width Width
	 * @param height Height</haxe_doc>
		</setSpriteSize>
		<getAtt public="1" get="inline" set="null" line="699" static="1">
			<f a="xml:name">
				<x path="haxe.xml.Access"/>
				<c path="String"/>
				<x path="Null"><x path="Null"><c path="String"/></x></x>
			</f>
			<haxe_doc>* Gets an XML attribute from an `Access` abstract, without throwing an exception if invalid.
	 * Example: `xml.getAtt("test").getDefault("Hello, World!");`
	 * @param xml XML to get the attribute from
	 * @param name Name of the attribute</haxe_doc>
		</getAtt>
		<autoSetFormat public="1" set="method" line="719" static="1">
			<f a="text:formats">
				<c path="flixel.text.FlxText"/>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
				<c path="flixel.text.FlxText"/>
			</f>
			<haxe_doc>* Sets automatically all the compatible formats to a text.
	 *
	 * WARNING: These are dependant from the font, so if the font doesn't support for example the `bold` format it won't work!
	 * @param text Text to set the format for
	 * @param formats Array of the formats (to get the formats from a node, you can use `XMLUtil.getTextFormats(node)`)</haxe_doc>
		</autoSetFormat>
		<loadAnimatedGraphic public="1" set="method" line="758" static="1">
			<f a="spr:path:?fps" v="::24.0">
				<c path="flixel.FlxSprite"/>
				<c path="String"/>
				<x path="Float"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ fps : 24.0 }</e></m></meta>
			<haxe_doc>* Loads an animated graphic, and automatically animates it.
	 * @param spr Sprite to load the graphic for
	 * @param path Path to the graphic</haxe_doc>
		</loadAnimatedGraphic>
		<copyColorTransform public="1" get="inline" set="null" line="774" static="1">
			<f a="color1:color2">
				<c path="openfl.geom.ColorTransform"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Copies a color transform from color1 to color2
	 * @param color1 Color transform to copy to
	 * @param color2 Color transform to copy from</haxe_doc>
		</copyColorTransform>
		<resetSprite public="1" set="method" line="791" static="1">
			<f a="spr:x:y">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resets an FlxSprite
	 * @param spr Sprite to reset
	 * @param x New X position
	 * @param y New Y position</haxe_doc>
		</resetSprite>
		<getMacroAbstractClass public="1" get="inline" set="null" line="807" static="1">
			<f a="className">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Gets the macro class created by hscript-improved for an abstract / enum</haxe_doc>
		</getMacroAbstractClass>
		<indexOfFromLast public="1" params="T" get="inline" set="null" line="817" static="1">
			<f a="array:element">
				<c path="Array"><c path="indexOfFromLast.T"/></c>
				<c path="indexOfFromLast.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Basically indexOf, but starts from the end.
	 * @param array Array to scan
	 * @param element Element
	 * @return Index, or -1 if unsuccessful.</haxe_doc>
		</indexOfFromLast>
		<clear public="1" params="T" get="inline" set="null" line="833" static="1">
			<f a="array">
				<c path="Array"><c path="clear.T"/></c>
				<c path="Array"><c path="clear.T"/></c>
			</f>
			<haxe_doc>* Clears the content of an array</haxe_doc>
		</clear>
		<pushGroup public="1" params="T" get="inline" set="null" line="846" static="1">
			<f a="array:args">
				<c path="Array"><c path="pushGroup.T"/></c>
				<x path="haxe.Rest"><c path="pushGroup.T"/></x>
				<c path="Array"><c path="pushGroup.T"/></c>
			</f>
			<haxe_doc>* Push an entire group into an array.
	 * @param array Array to push the group into
	 * @param ...args Group entries
	 * @return Array&lt;T&gt;</haxe_doc>
		</pushGroup>
		<openURL public="1" get="inline" set="null" line="856" static="1">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Opens an URL in the browser.
	 * @param url</haxe_doc>
		</openURL>
		<browsePath public="1" get="inline" set="null" line="871" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Browse a path in the operating system's explorer
	 * @param path</haxe_doc>
		</browsePath>
		<timeToStr public="1" get="inline" set="null" line="889" static="1">
			<f a="time">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Converts a timestamp to a readable format such as `01:22` (`mm:ss`)</haxe_doc>
		</timeToStr>
		<replay public="1" get="inline" set="null" line="895" static="1">
			<f a="sound">
				<c path="flixel.sound.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops a sound, set its time to 0 then play it again.
	 * @param sound Sound to replay.</haxe_doc>
		</replay>
		<maxInt public="1" get="inline" set="null" line="904" static="1">
			<f a="p1:p2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Equivalent of `Math.max`, except doesn't require a Int -&gt; Float -&gt; Int conversion.
	 * @param p1
	 * @param p2
	 * @return return p1 &lt; p2 ? p2 : p1</haxe_doc>
		</maxInt>
		<minInt public="1" get="inline" set="null" line="913" static="1">
			<f a="p1:p2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Equivalent of `Math.min`, except doesn't require a Int -&gt; Float -&gt; Int conversion.
	 * @param p1
	 * @param p2
	 * @return return p1 &gt; p2 ? p2 : p1</haxe_doc>
		</minInt>
		<floorInt public="1" get="inline" set="null" line="919" static="1">
			<f a="e">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Equivalent of `Math.floor`, except doesn't require a Int -&gt; Float -&gt; Int conversion.
	 * @param e Value to get the floor of.</haxe_doc>
		</floorInt>
		<quantize public="1" get="inline" set="null" line="935" static="1">
			<f a="Value:Quant">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Quantizes a value to a certain amount.
	 * Example: `quantize(2.5543, 1)` will return `2.0`
	 * Example: `quantize(2.5543, 10)` will return `2.5`
	 * Example: `quantize(2.5543, 100)` will return `2.55`
	 *
	 * @param Value Value to quantize
	 * @param Quant Quantization amount</haxe_doc>
		</quantize>
		<setMusic public="1" get="inline" set="null" line="945" static="1">
			<f a="frontEnd:music">
				<c path="flixel.system.frontEnds.SoundFrontEnd"/>
				<c path="flixel.sound.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets a SoundFrontEnd's music to a FlxSound.
	 * Example: `FlxG.sound.setMusic(music);`
	 * @param frontEnd SoundFrontEnd to set the music of
	 * @param music Music</haxe_doc>
		</setMusic>
		<flxeaseFromString public="1" get="inline" set="null" line="959" static="1">
			<f a="mainEase:?suffix">
				<c path="String"/>
				<c path="String"/>
				<x path="Null"><t path="flixel.tweens.EaseFunction"/></x>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Gets the FlxEase from a string.
	 * @param mainEase Main ease
	 * @param suffix Suffix (Ignored if `mainEase` is `linear`)</haxe_doc>
		</flxeaseFromString>
		<getFilename public="1" get="inline" set="null" line="966" static="1">
			<f a="file">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</getFilename>
		<getClosestAngle public="1" set="method" line="971" static="1">
			<f a="angle:targetAngle">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</getClosestAngle>
		<worldToScreenPosition public="1" set="method" line="986" static="1">
			<f a="object:?camera:?result">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxCamera"/>
				<x path="flixel.math.FlxPoint"/>
				<x path="Null"><x path="flixel.math.FlxPoint"/></x>
			</f>
			<haxe_doc>* Returns the screen position of an object, while taking the camera zoom into account.
	 *
	 * @param	object	Any `FlxObject`
	 * @param   camera  The desired "screen" coordinate space. If `null`, `FlxG.camera` is used.
	 * @param   result  Optional arg for the returning point
	 * @return  The screen position of the object.</haxe_doc>
		</worldToScreenPosition>
		<pointToScreenPosition public="1" set="method" line="1006" static="1">
			<f a="object:?camera:?result">
				<x path="flixel.math.FlxPoint"/>
				<c path="flixel.FlxCamera"/>
				<x path="flixel.math.FlxPoint"/>
				<x path="Null"><x path="flixel.math.FlxPoint"/></x>
			</f>
			<haxe_doc>* Returns the screen position of an point, while taking the camera zoom into account.
	 *
	 * @param	object	Any `FlxObject`
	 * @param   camera  The desired "screen" coordinate space. If `null`, `FlxG.camera` is used.
	 * @param   result  Optional arg for the returning point
	 * @return  The screen position of the object.</haxe_doc>
		</pointToScreenPosition>
		<sortAlphabetically public="1" set="method" line="1025" static="1">
			<f a="array:?lowercase" v=":false">
				<c path="Array"><c path="String"/></c>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ lowercase : false }</e></m></meta>
			<haxe_doc>* Sorts an array alphabetically.
	 * @param array Array to sort
	 * @param lowercase Whenever the array should be sorted in lowercase</haxe_doc>
		</sortAlphabetically>
		<pushOnce public="1" params="T" get="inline" set="null" line="1043" static="1">
			<f a="array:element">
				<c path="Array"><c path="pushOnce.T"/></c>
				<c path="pushOnce.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pushes an element to an array, but only if it doesn't already exist.
	 * @param array Array to push to
	 * @param element Element to push</haxe_doc>
		</pushOnce>
		<repeat public="1" get="inline" set="null" line="1064" static="1"><f a="str:times">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></repeat>
		<bound public="1" get="inline" set="null" line="1071" static="1">
			<f a="Value:Min:Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</bound>
		<boundInt public="1" get="inline" set="null" line="1082" static="1">
			<f a="Value:Min:Max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</boundInt>
		<boolToInt public="1" get="inline" set="null" line="1093" static="1">
			<f a="b">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</boolToInt>
		<parseNumberRange public="1" set="method" line="1106" static="1">
			<f a="input">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Converts a string of "1..3,5,7..9,8..5" into an array of numbers like [1,2,3,5,7,8,9,8,7,6,5]
	 * @param input String to parse
	 * @return Array of numbers</haxe_doc>
		</parseNumberRange>
		<formatNumberRange public="1" set="method" line="1147" static="1">
			<f a="numbers:?separator" v=":&quot;,&quot;">
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ separator : "," }</e></m></meta>
			<haxe_doc>* Converts an array of numbers into a string of ranges.
	 * Example: [1,2,3,5,7,8,9,8,7,6,5] -&gt; "1..3,5,7..9,8..5"
	 * @param numbers Array of numbers
	 * @param separator Separator between ranges
	 * @return String representing the ranges</haxe_doc>
		</formatNumberRange>
		<deepFlatten public="1" set="method" line="1193" static="1">
			<f a="arr:?result">
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>* Deep flattens an array.
	 * Example: `deepFlatten([1, [2, 3], 4])` will return `[1, 2, 3, 4]`
	 * @param arr Array to flatten
	 * @param result Result array</haxe_doc>
		</deepFlatten>
		<getLuminance public="1" set="method" line="1211" static="1">
			<f a="color">
				<x path="flixel.util.FlxColor"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Gets the luminance of the given color
	 * @param color Color to use
	 * @return Number between 0 and 1</haxe_doc>
		</getLuminance>
		<imageHasFrameData public="1" set="method" line="1220" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* ! REQUIRES FULL PATH!!!
	 * @param path 
	 * @return Bool</haxe_doc>
		</imageHasFrameData>
		<loadFramesFromData public="1" set="method" line="1229" static="1">
			<f a="data:?ext" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
			</f>
			<meta><m n=":value"><e>{ ext : null }</e></m></meta>
		</loadFramesFromData>
		<removeBOM public="1" set="method" line="1252" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></removeBOM>
		<getAnimsListFromFrames public="1" set="method" line="1256" static="1">
			<f a="frames:?ext" v=":null">
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ ext : null }</e></m></meta>
		</getAnimsListFromFrames>
		<getAnimsListFromAtlas public="1" set="method" line="1269" static="1"><f a="atlas">
	<x path="flxanimate.data.AnimAtlas"/>
	<c path="Array"><c path="String"/></c>
</f></getAnimsListFromAtlas>
		<getAnimsListFromSprite public="1" set="method" line="1281" static="1"><f a="spr">
	<c path="funkin.backend.FunkinSprite"/>
	<c path="Array"><c path="String"/></c>
</f></getAnimsListFromSprite>
		<deepEqual public="1" params="T" set="method" line="1290" static="1"><f a="a:b">
	<c path="deepEqual.T"/>
	<c path="deepEqual.T"/>
	<x path="Bool"/>
</f></deepEqual>
		<isNull get="inline" set="null" line="1371" static="1"><f a="a">
	<d/>
	<x path="Bool"/>
</f></isNull>
		<isFunction get="inline" set="null" line="1375" static="1"><f a="a">
	<d/>
	<x path="Bool"/>
</f></isFunction>
		<isMapEmpty public="1" params="K:V" get="inline" set="null" line="1379" static="1"><f a="map">
	<t path="Map">
		<c path="isMapEmpty.K"/>
		<c path="isMapEmpty.V"/>
	</t>
	<x path="Bool"/>
</f></isMapEmpty>
		<parsePropertyString public="1" get="inline" set="null" line="1383" static="1"><f a="fieldPath">
	<c path="String"/>
	<c path="Array"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<x path="Int"/>
</x></c>
</f></parsePropertyString>
		<stringifyFieldsPath public="1" set="method" line="1387" static="1"><f a="fields">
	<c path="Array"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<x path="Int"/>
</x></c>
	<c path="String"/>
</f></stringifyFieldsPath>
		<parseProperty public="1" set="method" line="1403" static="1"><f a="target:fields">
	<d/>
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<c path="Array"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<x path="Int"/>
</x></c>
	</x>
	<d/>
</f></parseProperty>
		<cloneProperty public="1" set="method" line="1427" static="1"><f a="toTarget:fields:fromTarget">
	<d/>
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<c path="Array"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<x path="Int"/>
</x></c>
	</x>
	<d/>
	<d/>
</f></cloneProperty>
		<haxe_doc>* Various utilities, that have no specific Util class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.game.PlayState</e></m>
		</meta>
	</class>
	<class path="funkin.backend.utils.PropertyInfo" params="" file="source/funkin/backend/utils/CoolUtil.hx" module="funkin.backend.utils.CoolUtil">
		<object public="1"><d/></object>
		<field public="1"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<x path="Int"/>
</x></field>
		<typeOfField public="1"><e path="ValueType"/></typeOfField>
		<isCustom public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isCustom>
		<custom public="1"><c path="hscript.IHScriptCustomBehaviour"/></custom>
		<getValue public="1" set="method" line="1464"><f a=""><d/></f></getValue>
		<setValue public="1" set="method" line="1483"><f a="value">
	<d/>
	<x path="Void"/>
</f></setValue>
		<new public="1" set="method" line="1449"><f a="object:field">
	<d/>
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<x path="Int"/>
	</x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.utils.CoolSfx" params="" file="source/funkin/backend/utils/CoolUtil.hx" module="funkin.backend.utils.CoolUtil">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<haxe_doc>* SFXs to play using `CoolUtil.playMenuSFX`.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._CoolUtil.CoolSfx_Impl_" params="" file="source/funkin/backend/utils/CoolUtil.hx" private="1" module="funkin.backend.utils.CoolUtil" extern="1" final="1">
	<SCROLL public="1" get="inline" set="null" expr="cast 0" line="1506" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCROLL>
	<CONFIRM public="1" get="inline" set="null" expr="cast 1" line="1507" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CONFIRM>
	<CANCEL public="1" get="inline" set="null" expr="cast 2" line="1508" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CANCEL>
	<CHECKED public="1" get="inline" set="null" expr="cast 3" line="1509" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CHECKED>
	<UNCHECKED public="1" get="inline" set="null" expr="cast 4" line="1510" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UNCHECKED>
	<WARNING public="1" get="inline" set="null" expr="cast 5" line="1511" static="1">
		<x path="funkin.backend.utils.CoolSfx"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WARNING>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._CoolUtil.CoolSfx_Impl_" params="" file="source/funkin/backend/utils/CoolUtil.hx" private="1" module="funkin.backend.utils.CoolUtil" extern="1" final="1">
		<SCROLL public="1" get="inline" set="null" expr="cast 0" line="1506" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCROLL>
		<CONFIRM public="1" get="inline" set="null" expr="cast 1" line="1507" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CONFIRM>
		<CANCEL public="1" get="inline" set="null" expr="cast 2" line="1508" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CANCEL>
		<CHECKED public="1" get="inline" set="null" expr="cast 3" line="1509" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CHECKED>
		<UNCHECKED public="1" get="inline" set="null" expr="cast 4" line="1510" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UNCHECKED>
		<WARNING public="1" get="inline" set="null" expr="cast 5" line="1511" static="1">
			<x path="funkin.backend.utils.CoolSfx"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WARNING>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.utils.DiscordUtil" params="" file="source/funkin/backend/utils/DiscordUtil.hx" final="1">
		<currentID public="1" set="accessor" expr="null" line="22" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</currentID>
		<discordThread public="1" expr="null" line="23" static="1">
			<x path="sys.thread.Thread"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</discordThread>
		<ready public="1" expr="false" line="24" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</ready>
		<initialized public="1" expr="false" line="25" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</initialized>
		<stopThread expr="false" line="26" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stopThread>
		<user public="1" expr="null" line="28" static="1">
			<c path="funkin.backend.utils.DUser"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</user>
		<lastPresence public="1" expr="null" line="29" static="1">
			<t path="funkin.backend.utils.DPresence"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastPresence>
		<config public="1" expr="null" line="30" static="1">
			<t path="funkin.backend.utils.DiscordJson"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</config>
		<script public="1" static="1"><c path="funkin.backend.scripting.Script"/></script>
		<REPLY_NO public="1" expr="Discord.REPLY_NO" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Discord.REPLY_NO</e></m></meta>
		</REPLY_NO>
		<REPLY_YES public="1" expr="Discord.REPLY_YES" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Discord.REPLY_YES</e></m></meta>
		</REPLY_YES>
		<REPLY_IGNORE public="1" expr="Discord.REPLY_IGNORE" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Discord.REPLY_IGNORE</e></m></meta>
		</REPLY_IGNORE>
		<PARTY_PRIVATE public="1" expr="Discord.PARTY_PRIVATE" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Discord.PARTY_PRIVATE</e></m></meta>
		</PARTY_PRIVATE>
		<PARTY_PUBLIC public="1" expr="Discord.PARTY_PUBLIC" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>Discord.PARTY_PUBLIC</e></m></meta>
		</PARTY_PUBLIC>
		<init public="1" set="method" line="44" static="1"><f a=""><x path="Void"/></f></init>
		<reloadJsonData public="1" set="method" line="74" static="1"><f a=""><x path="Void"/></f></reloadJsonData>
		<event public="1" params="T" set="method" line="101" static="1"><f a="name:event">
	<c path="String"/>
	<c path="event.T"/>
	<c path="event.T"/>
</f></event>
		<call public="1" set="method" line="108" static="1"><f a="name:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></call>
		<loadScript public="1" set="method" line="114" static="1"><f a=""><x path="Void"/></f></loadScript>
		<changePresence public="1" set="method" line="140" static="1"><f a="details:state:?smallImageKey">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></changePresence>
		<changeSongPresence public="1" set="method" line="151" static="1"><f a="details:state:audio:?smallImageKey">
	<c path="String"/>
	<c path="String"/>
	<c path="flixel.sound.FlxSound"/>
	<c path="String"/>
	<x path="Void"/>
</f></changeSongPresence>
		<changePresenceSince public="1" set="method" line="173" static="1"><f a="details:state:?smallImageKey:?time">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></changePresenceSince>
		<fixString public="1" set="method" line="189" static="1">
			<f a="str">
				<c path="String"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</fixString>
		<toString public="1" set="method" line="194" static="1">
			<f a="str">
				<x path="cpp.ConstCharStar"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
		<changePresenceAdvanced public="1" set="method" line="200" static="1"><f a="data">
	<t path="funkin.backend.utils.DPresence"/>
	<x path="Void"/>
</f></changePresenceAdvanced>
		<clearPresence public="1" set="method" line="255" static="1"><f a=""><x path="Void"/></f></clearPresence>
		<set_currentID set="method" line="262" static="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></set_currentID>
		<shutdown public="1" set="method" line="287" static="1"><f a=""><x path="Void"/></f></shutdown>
		<respond public="1" set="method" line="299" static="1"><f a="userId:reply">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></respond>
		<onReady set="method" line="308" static="1"><f a="request">
	<c path="cpp.RawConstPointer"><c path="hxdiscord_rpc.DiscordUser"/></c>
	<x path="Void"/>
</f></onReady>
		<onDisconnected set="method" line="324" static="1"><f a="errorCode:message">
	<x path="Int"/>
	<x path="cpp.ConstCharStar"/>
	<x path="Void"/>
</f></onDisconnected>
		<onError set="method" line="338" static="1"><f a="errorCode:message">
	<x path="Int"/>
	<x path="cpp.ConstCharStar"/>
	<x path="Void"/>
</f></onError>
		<onJoin set="method" line="350" static="1"><f a="joinSecret">
	<x path="cpp.ConstCharStar"/>
	<x path="Void"/>
</f></onJoin>
		<onSpectate set="method" line="357" static="1"><f a="spectateSecret">
	<x path="cpp.ConstCharStar"/>
	<x path="Void"/>
</f></onSpectate>
		<onJoinReq set="method" line="367" static="1"><f a="request">
	<c path="cpp.RawConstPointer"><c path="hxdiscord_rpc.DiscordUser"/></c>
	<x path="Void"/>
</f></onJoinReq>
		<anyResponse public="1" expr="new FlxTypedSignal&lt;String&gt;()" line="377" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;String&gt;()</e></m></meta>
		</anyResponse>
		<onAnyResponse set="method" line="380" static="1"><f a="data">
	<x path="cpp.ConstCharStar"/>
	<x path="Void"/>
</f></onAnyResponse>
		<getUUID set="method" line="386" static="1"><f a=""><c path="String"/></f></getUUID>
		<sendCustomCommand public="1" set="method" line="394" static="1"><f a="data">
	<d/>
	<x path="Void"/>
</f></sendCustomCommand>
		<setDebugMode public="1" set="method" line="403" static="1"><f a="mode">
	<x path="Bool"/>
	<x path="Void"/>
</f></setDebugMode>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.utils.DiscordJson" params="" file="source/funkin/backend/utils/DiscordUtil.hx" module="funkin.backend.utils.DiscordUtil"><a>
	<logoText>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</logoText>
	<logoKey>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</logoKey>
	<clientID>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</clientID>
</a></typedef>
	<class path="funkin.backend.utils.DUser" params="" file="source/funkin/backend/utils/DiscordUtil.hx" module="funkin.backend.utils.DiscordUtil" final="1">
		<initRaw public="1" set="method" line="471" static="1"><f a="req">
	<c path="cpp.RawConstPointer"><c path="hxdiscord_rpc.DiscordUser"/></c>
	<c path="funkin.backend.utils.DUser"/>
</f></initRaw>
		<init public="1" set="method" line="476" static="1"><f a="userData">
	<t path="cpp.Star"><c path="hxdiscord_rpc.DiscordUser"/></t>
	<c path="funkin.backend.utils.DUser"/>
</f></init>
		<handle public="1">
			<c path="String"/>
			<haxe_doc>* The username + discriminator if they have it</haxe_doc>
		</handle>
		<userId public="1">
			<c path="String"/>
			<haxe_doc>* The user id, aka 860561967383445535</haxe_doc>
		</userId>
		<username public="1">
			<c path="String"/>
			<haxe_doc>* The user's username</haxe_doc>
		</username>
		<discriminator public="1">
			<x path="Int"/>
			<haxe_doc>* The #number from before discord changed to usernames only, if the user has changed to a username them its just a 0</haxe_doc>
		</discriminator>
		<avatar public="1">
			<c path="String"/>
			<haxe_doc>* The user's avatar filename</haxe_doc>
		</avatar>
		<globalName public="1">
			<c path="String"/>
			<haxe_doc>* The user's display name</haxe_doc>
		</globalName>
		<bot public="1">
			<x path="Bool"/>
			<haxe_doc>* If the user is a bot or not</haxe_doc>
		</bot>
		<flags public="1">
			<x path="Int"/>
			<haxe_doc>* Idk check discord docs</haxe_doc>
		</flags>
		<premiumType public="1">
			<x path="funkin.backend.utils.NitroType"/>
			<haxe_doc>* If the user has nitro</haxe_doc>
		</premiumType>
		<getAvatar public="1" set="method" line="499">
			<f a="?size" v="256">
				<x path="Int"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ size : 256 }</e></m></meta>
			<haxe_doc>* Calling this function gets the BitmapData of the user</haxe_doc>
		</getAvatar>
		<new set="method" line="466"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noCustomClass"/>
		</meta>
	</class>
	<abstract path="funkin.backend.utils.NitroType" params="" file="source/funkin/backend/utils/DiscordUtil.hx" module="funkin.backend.utils.DiscordUtil">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._DiscordUtil.NitroType_Impl_" params="" file="source/funkin/backend/utils/DiscordUtil.hx" private="1" module="funkin.backend.utils.DiscordUtil" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="504" static="1">
		<x path="funkin.backend.utils.NitroType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<NITRO_CLASSIC public="1" get="inline" set="null" expr="cast 1" line="505" static="1">
		<x path="funkin.backend.utils.NitroType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NITRO_CLASSIC>
	<NITRO public="1" get="inline" set="null" expr="cast 2" line="506" static="1">
		<x path="funkin.backend.utils.NitroType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NITRO>
	<NITRO_BASIC public="1" get="inline" set="null" expr="cast 3" line="507" static="1">
		<x path="funkin.backend.utils.NitroType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NITRO_BASIC>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._DiscordUtil.NitroType_Impl_" params="" file="source/funkin/backend/utils/DiscordUtil.hx" private="1" module="funkin.backend.utils.DiscordUtil" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="504" static="1">
			<x path="funkin.backend.utils.NitroType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<NITRO_CLASSIC public="1" get="inline" set="null" expr="cast 1" line="505" static="1">
			<x path="funkin.backend.utils.NitroType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NITRO_CLASSIC>
		<NITRO public="1" get="inline" set="null" expr="cast 2" line="506" static="1">
			<x path="funkin.backend.utils.NitroType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NITRO>
		<NITRO_BASIC public="1" get="inline" set="null" expr="cast 3" line="507" static="1">
			<x path="funkin.backend.utils.NitroType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NITRO_BASIC>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="funkin.backend.utils.DPresence" params="" file="source/funkin/backend/utils/DiscordUtil.hx" module="funkin.backend.utils.DiscordUtil"><a>
	<streamUrl>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</streamUrl>
	<state>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</state>
	<startTimestamp>
		<x path="Null"><x path="flixel.util.typeLimit.OneOfTwo">
	<x path="Int"/>
	<x path="haxe.Int64"/>
</x></x>
		<meta><m n=":optional"/></meta>
	</startTimestamp>
	<spectateSecret>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</spectateSecret>
	<smallImageText>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</smallImageText>
	<smallImageKey>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</smallImageKey>
	<partySize>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</partySize>
	<partyPrivacy>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</partyPrivacy>
	<partyMax>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</partyMax>
	<partyId>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</partyId>
	<matchSecret>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</matchSecret>
	<largeImageText>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</largeImageText>
	<largeImageKey>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</largeImageKey>
	<joinSecret>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</joinSecret>
	<instance>
		<x path="Null"><x path="flixel.util.typeLimit.OneOfTwo">
	<x path="Int"/>
	<x path="cpp.Int8"/>
</x></x>
		<meta><m n=":optional"/></meta>
	</instance>
	<endTimestamp>
		<x path="Null"><x path="flixel.util.typeLimit.OneOfTwo">
	<x path="Int"/>
	<x path="haxe.Int64"/>
</x></x>
		<meta><m n=":optional"/></meta>
	</endTimestamp>
	<details>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</details>
	<button2Url>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</button2Url>
	<button2Label>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</button2Label>
	<button1Url>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</button1Url>
	<button1Label>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</button1Label>
	<activityType>
		<x path="Null"><x path="hxdiscord_rpc.ActivityType"/></x>
		<meta><m n=":optional"/></meta>
	</activityType>
</a></typedef>
	<typedef path="funkin.backend.utils.DEvents" params="" file="source/funkin/backend/utils/DiscordUtil.hx" module="funkin.backend.utils.DiscordUtil"><a>
	<spectateGame>
		<x path="Null"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</spectateGame>
	<ready>
		<x path="Null"><f a="">
	<c path="funkin.backend.utils.DUser"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</ready>
	<joinRequest>
		<x path="Null"><f a="">
	<c path="funkin.backend.utils.DUser"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</joinRequest>
	<joinGame>
		<x path="Null"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</joinGame>
	<errored>
		<x path="Null"><f a="errorCode:message">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</errored>
	<disconnected>
		<x path="Null"><f a="errorCode:message">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</disconnected>
</a></typedef>
	<class path="funkin.backend.utils.DrawUtil" params="" file="source/funkin/backend/utils/DrawUtil.hx" final="1">
		<line public="1" expr="null" line="9" static="1">
			<c path="flixel.FlxSprite"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</line>
		<dot public="1" expr="null" line="10" static="1">
			<c path="flixel.FlxSprite"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</dot>
		<square public="1" expr="null" line="11" static="1">
			<c path="flixel.FlxSprite"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</square>
		<drawSquare public="1" get="inline" set="null" line="13" static="1">
			<f a="x:y:?scale" v="::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1 }</e></m></meta>
		</drawSquare>
		<drawDot public="1" get="inline" set="null" line="26" static="1">
			<f a="x:y:?scale" v="::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1 }</e></m></meta>
		</drawDot>
		<drawLine public="1" get="inline" set="null" line="39" static="1">
			<f a="point1:point2:?thickness:?color" v="::1:">
				<x path="flixel.math.FlxPoint"/>
				<x path="flixel.math.FlxPoint"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ thickness : 1 }</e></m></meta>
		</drawLine>
		<drawRect public="1" get="inline" set="null" line="65" static="1">
			<f a="rect:?thickness:?color" v=":1:">
				<c path="flixel.math.FlxRect"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ thickness : 1 }</e></m></meta>
		</drawRect>
		<createDrawers public="1" get="inline" set="null" line="73" static="1"><f a=""><x path="Void"/></f></createDrawers>
		<destroyDrawers public="1" set="method" line="91" static="1"><f a=""><x path="Void"/></f></destroyDrawers>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.EngineUtil" params="" file="source/funkin/backend/utils/EngineUtil.hx" final="1">
		<startMultithreadedScript public="1" set="method" line="12" static="1">
			<f a="path">
				<c path="String"/>
				<c path="funkin.backend.scripting.MultiThreadedScript"/>
			</f>
			<haxe_doc>* Starts a new multithreaded script.
	 * This script will share all the variables with the current one, which means already existing callbacks will be replaced by new ones on conflict.
	 * @param path</haxe_doc>
		</startMultithreadedScript>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.FileAttributeWrapper" params="" file="source/funkin/backend/utils/FileAttributeWrapper.hx">
		<flags><x path="Int"/></flags>
		<getValue public="1" get="inline" set="null" line="13"><f a=""><x path="Int"/></f></getValue>
		<toString public="1" get="inline" set="null" line="26">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns a string representation of the attributes.</haxe_doc>
		</toString>
		<isArchived public="1" get="accessor" set="accessor"><x path="Bool"/></isArchived>
		<get_isArchived set="method" line="38"><f a=""><x path="Bool"/></f></get_isArchived>
		<set_isArchived set="method" line="46"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isArchived>
		<isHidden public="1" get="accessor" set="accessor"><x path="Bool"/></isHidden>
		<get_isHidden set="method" line="60"><f a=""><x path="Bool"/></f></get_isHidden>
		<set_isHidden set="method" line="68"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isHidden>
		<isNormal public="1" get="accessor" set="accessor"><x path="Bool"/></isNormal>
		<get_isNormal set="method" line="82"><f a=""><x path="Bool"/></f></get_isNormal>
		<set_isNormal set="method" line="90"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isNormal>
		<isNotContentIndexed public="1" get="accessor" set="accessor"><x path="Bool"/></isNotContentIndexed>
		<get_isNotContentIndexed set="method" line="104"><f a=""><x path="Bool"/></f></get_isNotContentIndexed>
		<set_isNotContentIndexed set="method" line="112"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isNotContentIndexed>
		<isOffline public="1" get="accessor" set="accessor"><x path="Bool"/></isOffline>
		<get_isOffline set="method" line="126"><f a=""><x path="Bool"/></f></get_isOffline>
		<set_isOffline set="method" line="134"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isOffline>
		<isReadOnly public="1" get="accessor" set="accessor"><x path="Bool"/></isReadOnly>
		<get_isReadOnly set="method" line="148"><f a=""><x path="Bool"/></f></get_isReadOnly>
		<set_isReadOnly set="method" line="156"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isReadOnly>
		<isSystem public="1" get="accessor" set="accessor"><x path="Bool"/></isSystem>
		<get_isSystem set="method" line="170"><f a=""><x path="Bool"/></f></get_isSystem>
		<set_isSystem set="method" line="178"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isSystem>
		<isTemporary public="1" get="accessor" set="accessor"><x path="Bool"/></isTemporary>
		<get_isTemporary set="method" line="192"><f a=""><x path="Bool"/></f></get_isTemporary>
		<set_isTemporary set="method" line="200"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isTemporary>
		<isCompressed public="1" get="accessor" set="null"><x path="Bool"/></isCompressed>
		<get_isCompressed set="method" line="215"><f a=""><x path="Bool"/></f></get_isCompressed>
		<isDevice public="1" get="accessor" set="null"><x path="Bool"/></isDevice>
		<get_isDevice set="method" line="225"><f a=""><x path="Bool"/></f></get_isDevice>
		<isDirectory public="1" get="accessor" set="null"><x path="Bool"/></isDirectory>
		<get_isDirectory set="method" line="235"><f a=""><x path="Bool"/></f></get_isDirectory>
		<isEncrypted public="1" get="accessor" set="null"><x path="Bool"/></isEncrypted>
		<get_isEncrypted set="method" line="245"><f a=""><x path="Bool"/></f></get_isEncrypted>
		<isReparsePoint public="1" get="accessor" set="null"><x path="Bool"/></isReparsePoint>
		<get_isReparsePoint set="method" line="255"><f a=""><x path="Bool"/></f></get_isReparsePoint>
		<isSparseFile public="1" get="accessor" set="null"><x path="Bool"/></isSparseFile>
		<get_isSparseFile set="method" line="265"><f a=""><x path="Bool"/></f></get_isSparseFile>
		<isNothing public="1" get="accessor" set="null"><x path="Bool"/></isNothing>
		<get_isNothing set="method" line="276"><f a=""><x path="Bool"/></f></get_isNothing>
		<new public="1" set="method" line="18"><f a="flags">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Currently only for Windows, but planned to work on other platforms later.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.FlxInterpolateColor" params="" file="source/funkin/backend/utils/FlxInterpolateColor.hx">
		<red public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</red>
		<green public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</green>
		<blue public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</blue>
		<alpha public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</alpha>
		<color public="1" get="accessor" set="accessor"><x path="flixel.util.FlxColor"/></color>
		<get_color get="inline" set="null" line="18"><f a=""><x path="flixel.util.FlxColor"/></f></get_color>
		<set_color get="inline" set="null" line="20"><f a="c">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_color>
		<toString public="1" get="inline" set="null" line="29"><f a=""><c path="String"/></f></toString>
		<lerpTo public="1" set="method" line="34"><f a="color:ratio">
	<x path="flixel.util.FlxColor"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lerpTo>
		<fpsLerpTo public="1" get="inline" set="null" line="42"><f a="color:ratio">
	<x path="flixel.util.FlxColor"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fpsLerpTo>
		<new public="1" set="method" line="30"><f a="color">
	<x path="flixel.util.FlxColor"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Additional class for FlxColor lerping.
 * Gets rid of precision issues with `FlxColor.interpolate`</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.FunkinParentDisabler" params="" file="source/funkin/backend/utils/FunkinParentDisabler.hx">
		<extends path="flixel.FlxBasic"/>
		<__tweens><c path="Array"><c path="flixel.tweens.FlxTween"/></c></__tweens>
		<__cameras><c path="Array"><c path="flixel.FlxCamera"/></c></__cameras>
		<__timers><c path="Array"><c path="flixel.util.FlxTimer"/></c></__timers>
		<__sounds><c path="Array"><c path="flixel.sound.FlxSound"/></c></__sounds>
		<__replaceUponDestroy><x path="Bool"/></__replaceUponDestroy>
		<__restoreUponDestroy><x path="Bool"/></__restoreUponDestroy>
		<draw public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></draw>
		<reset public="1" set="method" line="48"><f a=""><x path="Void"/></f></reset>
		<destroy public="1" set="method" line="55" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="23">
			<f a="?replaceUponDestroy:?restoreUponDestroy" v="false:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ restoreUponDestroy : true, replaceUponDestroy : false }</e></m></meta>
		</new>
		<haxe_doc>* FlxBasic allowing you to disable those elements from the parent state while this substate is opened
 * - Tweens
 * - Camera Movement
 * - Timers
 * - Sounds
 *
 * To use, add `add(new FunkinParentDisabler());` after `super.create();` in your `create` function.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.HttpUtil" params="" file="source/funkin/backend/utils/HttpUtil.hx" final="1">
		<userAgent public="1" expr="Flags.USER_AGENT" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.USER_AGENT</e></m></meta>
		</userAgent>
		<requestText public="1" set="method" line="10" static="1"><f a="url">
	<c path="String"/>
	<c path="String"/>
</f></requestText>
		<requestBytes public="1" set="method" line="54" static="1"><f a="url">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></requestBytes>
		<hasInternet public="1" set="method" line="98" static="1"><f a=""><x path="Bool"/></f></hasInternet>
		<isRedirect set="method" line="109" static="1"><f a="status">
	<x path="Int"/>
	<x path="Bool"/>
</f></isRedirect>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils._HttpUtil.HttpError" params="" file="source/funkin/backend/utils/HttpUtil.hx" private="1" module="funkin.backend.utils.HttpUtil">
		<message public="1"><c path="String"/></message>
		<url public="1"><c path="String"/></url>
		<status public="1"><x path="Int"/></status>
		<redirected public="1"><x path="Bool"/></redirected>
		<toString public="1" set="method" line="134"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="127">
			<f a="message:url:?status:?redirected" v="::-1:false">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ redirected : false, status : -1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.IniUtil" params="" file="source/funkin/backend/utils/IniUtil.hx">
		<parseAsset public="1" get="inline" set="null" line="5" static="1"><f a="assetPath">
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<t path="Map">
			<c path="String"/>
			<c path="String"/>
		</t>
	</t>
</f></parseAsset>
		<parseString public="1" set="method" line="7" static="1"><f a="data">
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<t path="Map">
			<c path="String"/>
			<c path="String"/>
		</t>
	</t>
</f></parseString>
		<parseStringToMap public="1" set="method" line="13" static="1"><f a="map:data">
	<t path="Map">
		<c path="String"/>
		<t path="Map">
			<c path="String"/>
			<c path="String"/>
		</t>
	</t>
	<c path="String"/>
	<x path="Void"/>
</f></parseStringToMap>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.MarkdownUtil" params="" file="source/funkin/backend/utils/MarkdownUtil.hx" final="1">
		<applyMarkdownText public="1" set="method" line="7" static="1"><f a="text:str">
	<c path="flixel.text.FlxText"/>
	<c path="String"/>
	<x path="Void"/>
</f></applyMarkdownText>
		<createAdvancedMarkerPair public="1" set="method" line="39" static="1">
			<f a="marker:color:size:?bold:?italic:?underline:?blockIndent:?bullet" v=":::false:false:false::">
				<c path="String"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Null"><x path="Float"/></x>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.text.FlxTextFormatMarkerPair"/>
			</f>
			<meta><m n=":value"><e>{ underline : false, italic : false, bold : false }</e></m></meta>
		</createAdvancedMarkerPair>
		<parseWarnings public="1" set="method" line="50" static="1"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></parseWarnings>
		<prepareMarkdown public="1" set="method" line="58" static="1"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></prepareMarkdown>
		<parseEmote public="1" set="method" line="77" static="1">
			<f a="text:emote:beginning:end:?emoteEnd" v="::::&quot;\n&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ emoteEnd : "\n" }</e></m></meta>
		</parseEmote>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.MathUtil" params="" file="source/funkin/backend/utils/MathUtil.hx" final="1">
		<maxInt public="1" set="method" line="12" static="1">
			<f a="args">
				<x path="haxe.Rest"><x path="Int"/></x>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the maximum value in the arguments.
	 * @param args Array of values
	 *
	 * @return The maximum value</haxe_doc>
		</maxInt>
		<minInt public="1" set="method" line="28" static="1">
			<f a="args">
				<x path="haxe.Rest"><x path="Int"/></x>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the minimum value in the arguments.
	 * @param args Array of values
	 *
	 * @return The minimum value</haxe_doc>
		</minInt>
		<max public="1" set="method" line="47" static="1">
			<f a="args">
				<x path="haxe.Rest"><x path="Float"/></x>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the maximum value in the arguments.
	 *
	 * NOTE: If you are using this in compile time, you should use `MathUtil.maxSmart` instead of this for better performance.
	 *
	 * @param args Array of values
	 *
	 * @return The maximum value</haxe_doc>
		</max>
		<min public="1" set="method" line="66" static="1">
			<f a="args">
				<x path="haxe.Rest"><x path="Float"/></x>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the minimum value in the arguments.
	 *
	 * NOTE: If you are using this in compile time, you should use `MathUtil.minSmart` instead of this for better performance.
	 *
	 * @param args Array of values
	 *
	 * @return The minimum value</haxe_doc>
		</min>
		<lessThan public="1" set="method" line="85" static="1">
			<f a="a:b:?margin" v="::0.0000001">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ margin : 0.0000001 }</e></m></meta>
			<haxe_doc>* Checks if a is less than b with considering a margin of error.
	 * 
	 * @param a Float
	 * @param b Float
	 * @param margin Float (Default: EPSILON)
	 * 
	 * @return Bool</haxe_doc>
		</lessThan>
		<lessThanEqual public="1" set="method" line="98" static="1">
			<f a="a:b:?margin" v="::0.0000001">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ margin : 0.0000001 }</e></m></meta>
			<haxe_doc>* Checks if a is less than or equally b with considering a margin of error.
	 * 
	 * @param a Float
	 * @param b Float
	 * @param margin Float (Default: EPSILON)
	 * 
	 * @return Bool</haxe_doc>
		</lessThanEqual>
		<greaterThan public="1" set="method" line="111" static="1">
			<f a="a:b:?margin" v="::0.0000001">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ margin : 0.0000001 }</e></m></meta>
			<haxe_doc>* Checks if a is greater than b with considering a margin of error.
	 * 
	 * @param a Float
	 * @param b Float
	 * @param margin Float (Default: EPSILON)
	 * 
	 * @return Bool</haxe_doc>
		</greaterThan>
		<greaterThanEqual public="1" set="method" line="124" static="1">
			<f a="a:b:?margin" v="::0.0000001">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ margin : 0.0000001 }</e></m></meta>
			<haxe_doc>* Checks if a is greater than or equally b with considering a margin of error.
	 * 
	 * @param a Float
	 * @param b Float
	 * @param margin Float (Default: EPSILON)
	 * 
	 * @return Bool</haxe_doc>
		</greaterThanEqual>
		<equal public="1" set="method" line="137" static="1">
			<f a="a:b:?margin" v="::0.0000001">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ margin : 0.0000001 }</e></m></meta>
			<haxe_doc>* Checks if a is approximately equal to b.
	 * 
	 * @param a Float
	 * @param b Float
	 * @param margin Float (Default: EPSILON)
	 * 
	 * @return Bool</haxe_doc>
		</equal>
		<notEqual public="1" set="method" line="150" static="1">
			<f a="a:b:?margin" v="::0.0000001">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ margin : 0.0000001 }</e></m></meta>
			<haxe_doc>* Checks if a are not approximately equal to b.
	 * 
	 * @param a Float
	 * @param b Float
	 * @param margin Float (Default: EPSILON)
	 * 
	 * @return Bool</haxe_doc>
		</notEqual>
		<maxSmart public="1" set="method" static="1">
			<f a="_args">
				<d/>
				<d/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Shortcut to `Math.max` but with infinite amount of arguments
	 *
	 * Might not preserve the order of arguments, please test this.
	 *
	 * Dont use this in hscript, it doesnt work, it only works on compile time</haxe_doc>
		</maxSmart>
		<minSmart public="1" set="method" static="1">
			<f a="_args">
				<d/>
				<d/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Shortcut to `Math.min` but with infinite amount of arguments
	 *
	 * Might not preserve the order of arguments, please test this.
	 *
	 * Dont use this in hscript, it doesnt work, it only works on compile time</haxe_doc>
		</minSmart>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.IPrePostDraw" params="" file="source/funkin/backend/utils/MatrixUtil.hx" module="funkin.backend.utils.MatrixUtil" interface="1">
		<preDraw public="1" set="method"><f a=""><x path="Void"/></f></preDraw>
		<postDraw public="1" set="method"><f a=""><x path="Void"/></f></postDraw>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.MatrixUtil" params="" file="source/funkin/backend/utils/MatrixUtil.hx" final="1">
		<getMatrixPosition public="1" set="method" line="32" static="1">
			<f a="sprite:points:?camera:?_width:?_height" v=":::1:1">
				<c path="flixel.FlxSprite"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<x path="flixel.math.FlxPoint"/>
					<c path="Array"><x path="flixel.math.FlxPoint"/></c>
				</x>
				<c path="flixel.FlxCamera"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="flixel.math.FlxPoint"/></c>
			</f>
			<meta><m n=":value"><e>{ _height : 1, _width : 1 }</e></m></meta>
		</getMatrixPosition>
		<transformPoints public="1" set="method" line="189" static="1">
			<f a="sprite:points:matrix:?camera:?_width:?_height:?doCameraTransform" v="::::1:1:true">
				<c path="flixel.FlxSprite"/>
				<c path="Array"><x path="flixel.math.FlxPoint"/></c>
				<c path="flixel.math.FlxMatrix"/>
				<c path="flixel.FlxCamera"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><x path="flixel.math.FlxPoint"/></c>
			</f>
			<meta><m n=":value"><e>{ doCameraTransform : true, _height : 1, _width : 1 }</e></m></meta>
			<haxe_doc>* Warning: modifies the points in the array</haxe_doc>
		</transformPoints>
		<rawTransformPoints set="method" line="214" static="1">
			<f a="points:matrix:?_width:?_height" v="::1:1">
				<c path="Array"><x path="flixel.math.FlxPoint"/></c>
				<c path="flixel.math.FlxMatrix"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="flixel.math.FlxPoint"/></c>
			</f>
			<meta><m n=":value"><e>{ _height : 1, _width : 1 }</e></m></meta>
		</rawTransformPoints>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>flixel.FlxCamera</e></m>
			<m n=":access"><e>flixel.FlxSprite</e></m>
			<m n=":access"><e>flixel.math.FlxMatrix</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
		</meta>
	</class>
	<class path="funkin.backend.utils.MemoryUtil" params="" file="source/funkin/backend/utils/MemoryUtil.hx" final="1">
		<disableCount public="1" expr="0" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</disableCount>
		<askDisable public="1" set="method" line="26" static="1"><f a=""><x path="Void"/></f></askDisable>
		<askEnable public="1" set="method" line="33" static="1"><f a=""><x path="Void"/></f></askEnable>
		<init public="1" set="method" line="41" static="1"><f a=""><x path="Void"/></f></init>
		<clearMinor public="1" set="method" line="46" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Does a minor garbage collection.</haxe_doc>
		</clearMinor>
		<clearMajor public="1" set="method" line="55" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Does a full garbage collection.</haxe_doc>
		</clearMajor>
		<enable public="1" set="method" line="69" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Enables garbage collection.</haxe_doc>
		</enable>
		<disable public="1" set="method" line="79" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Disables garbage collection.
	 * Fyi: doesn't fully disable garbage collection, but prevents it from running as much.</haxe_doc>
		</disable>
		<getTotalMem public="1" set="method" line="90" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Gets the total memory of the system.
	 * Output depends on the hardware.</haxe_doc>
		</getTotalMem>
		<currentMemUsage public="1" get="inline" set="null" line="110" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Gets the current memory usage of the app.
	 * DISCLAIMER: This gets the memory usage that is taken up by Haxe, not the actual memory usage of the app.</haxe_doc>
		</currentMemUsage>
		<getMemType public="1" set="method" line="127" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Gets the memory type of the system.
	 * Output depends on the platform, and hardware.</haxe_doc>
		</getMemType>
		<haxe_doc>* Tools that are related to memory.
 * Including garbage collection, and memory usage, and hardware info.
 *
 * DISCLAIMER: Hardware info is only available on Native platforms.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.NativeAPI" params="" file="source/funkin/backend/utils/NativeAPI.hx">
		<registerAudio public="1" set="method" line="16" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</registerAudio>
		<registerAsDPICompatible public="1" set="method" line="22" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</registerAsDPICompatible>
		<allocConsole public="1" set="method" line="31" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Allocates a new console. The console will automatically be opened</haxe_doc>
		</allocConsole>
		<getFileAttributesRaw public="1" set="method" line="41" static="1">
			<f a="path:?useAbsolute" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ useAbsolute : true }</e></m></meta>
			<haxe_doc>* Gets the specified file's (or folder) attributes.</haxe_doc>
		</getFileAttributesRaw>
		<getFileAttributes public="1" set="method" line="53" static="1">
			<f a="path:?useAbsolute" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="funkin.backend.utils.FileAttributeWrapper"/>
			</f>
			<meta><m n=":value"><e>{ useAbsolute : true }</e></m></meta>
			<haxe_doc>* Gets the specified file's (or folder) attributes and passes it to `FileAttributeWrapper`.</haxe_doc>
		</getFileAttributes>
		<setFileAttributes public="1" set="method" line="60" static="1">
			<f a="path:attrib:?useAbsolute" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfThree">
					<x path="funkin.backend.utils.FileAttribute"/>
					<c path="funkin.backend.utils.FileAttributeWrapper"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ useAbsolute : true }</e></m></meta>
			<haxe_doc>* Sets the specified file's (or folder) attributes. If it fails, the return value is `0`.</haxe_doc>
		</setFileAttributes>
		<addFileAttributes public="1" set="method" line="72" static="1">
			<f a="path:attrib:?useAbsolute" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<x path="funkin.backend.utils.FileAttribute"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ useAbsolute : true }</e></m></meta>
			<haxe_doc>* Removes from the specified file's (or folder) one (or more) specific attribute.</haxe_doc>
		</addFileAttributes>
		<removeFileAttributes public="1" set="method" line="83" static="1">
			<f a="path:attrib:?useAbsolute" v="::true">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<x path="funkin.backend.utils.FileAttribute"/>
					<x path="Int"/>
				</x>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ useAbsolute : true }</e></m></meta>
			<haxe_doc>* Removes from the specified file's (or folder) one (or more) specific attribute.</haxe_doc>
		</removeFileAttributes>
		<setDarkMode public="1" set="method" line="98" static="1">
			<f a="title:enable">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Switch the window's color mode to dark or light mode.</haxe_doc>
		</setDarkMode>
		<setWindowBorderColor public="1" set="method" line="112" static="1">
			<f a="title:color:?setHeader:?setBorder" v="::true:true">
				<c path="String"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ setBorder : true, setHeader : true }</e></m></meta>
			<haxe_doc>* Switch the window's color to any color.
	 *
	 * WARNING: This is exclusive to windows 11 users, unfortunately.
	 *
	 * NOTE: Setting the color to 0x00000000 (FlxColor.TRANSPARENT) will set the border (must have setBorder on) invisible.</haxe_doc>
		</setWindowBorderColor>
		<resetWindowBorderColor public="1" set="method" line="124" static="1">
			<f a="title:?setHeader:?setBorder" v=":true:true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ setBorder : true, setHeader : true }</e></m></meta>
			<haxe_doc>* Resets the window's border color to the default one.
	 *
	 * WARNING: This is exclusive to windows 11 users, unfortunately.</haxe_doc>
		</resetWindowBorderColor>
		<setWindowTitleColor public="1" set="method" line="136" static="1">
			<f a="title:color">
				<c path="String"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Switch the window's title text to any color.
	 *
	 * WARNING: This is exclusive to windows 11 users, unfortunately.</haxe_doc>
		</setWindowTitleColor>
		<resetWindowTitleColor public="1" set="method" line="148" static="1">
			<f a="title">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resets the window's title color to the default one.
	 *
	 * WARNING: This is exclusive to windows 11 users, unfortunately.</haxe_doc>
		</resetWindowTitleColor>
		<redrawWindowHeader public="1" set="method" line="158" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Forces the window header to redraw, causes a small visual jitter so use it sparingly.</haxe_doc>
		</redrawWindowHeader>
		<hasVersion public="1" set="method" line="169" static="1">
			<f a="vers">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Can be used to check if your using a specific version of an OS (or if your using a certain OS).</haxe_doc>
		</hasVersion>
		<showMessageBox public="1" set="method" line="174" static="1">
			<f a="caption:message:?icon" v="::MSG_WARNING">
				<c path="String"/>
				<c path="String"/>
				<x path="funkin.backend.utils.MessageBoxIcon"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ icon : MSG_WARNING }</e></m></meta>
			<haxe_doc>* Shows a message box</haxe_doc>
		</showMessageBox>
		<setConsoleColors public="1" set="method" line="185" static="1">
			<f a="?foregroundColor:?backgroundColor" v="NONE:NONE">
				<x path="funkin.backend.utils.ConsoleColor"/>
				<x path="funkin.backend.utils.ConsoleColor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ backgroundColor : NONE, foregroundColor : NONE }</e></m></meta>
			<haxe_doc>* Sets the console colors</haxe_doc>
		</setConsoleColors>
		<setCursorIcon public="1" set="method" line="209" static="1">
			<f a="icon">
				<x path="funkin.backend.utils.CodeCursor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set cursor icon.</haxe_doc>
		</setCursorIcon>
		<consoleColorToANSI public="1" set="method" line="217" static="1"><f a="color">
	<x path="funkin.backend.utils.ConsoleColor"/>
	<x path="Int"/>
</f></consoleColorToANSI>
		<consoleColorToOpenFL public="1" set="method" line="238" static="1"><f a="color">
	<x path="funkin.backend.utils.ConsoleColor"/>
	<x path="Int"/>
</f></consoleColorToOpenFL>
		<haxe_doc>* Class for functions that talk to a lower level than haxe, such as message boxes, and more.
 * Some functions might not have effect on some platforms.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.utils.FileAttribute" params="" file="source/funkin/backend/utils/NativeAPI.hx" module="funkin.backend.utils.NativeAPI">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._NativeAPI.FileAttribute_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
	<ARCHIVE public="1" get="inline" set="null" expr="cast 0x20" line="262" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x20</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ARCHIVE>
	<HIDDEN public="1" get="inline" set="null" expr="cast 0x2" line="263" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HIDDEN>
	<NORMAL public="1" get="inline" set="null" expr="cast 0x80" line="264" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x80</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NORMAL>
	<NOT_CONTENT_INDEXED public="1" get="inline" set="null" expr="cast 0x2000" line="265" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x2000</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOT_CONTENT_INDEXED>
	<OFFLINE public="1" get="inline" set="null" expr="cast 0x1000" line="266" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x1000</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OFFLINE>
	<READONLY public="1" get="inline" set="null" expr="cast 0x1" line="267" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</READONLY>
	<SYSTEM public="1" get="inline" set="null" expr="cast 0x4" line="268" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SYSTEM>
	<TEMPORARY public="1" get="inline" set="null" expr="cast 0x100" line="269" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x100</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TEMPORARY>
	<COMPRESSED public="1" get="inline" set="null" expr="cast 0x800" line="272" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x800</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</COMPRESSED>
	<DEVICE public="1" get="inline" set="null" expr="cast 0x40" line="273" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x40</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DEVICE>
	<DIRECTORY public="1" get="inline" set="null" expr="cast 0x10" line="274" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DIRECTORY>
	<ENCRYPTED public="1" get="inline" set="null" expr="cast 0x4000" line="275" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x4000</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ENCRYPTED>
	<REPARSE_POINT public="1" get="inline" set="null" expr="cast 0x400" line="276" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x400</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</REPARSE_POINT>
	<SPARSE_FILE public="1" get="inline" set="null" expr="cast 0x200" line="277" static="1">
		<x path="funkin.backend.utils.FileAttribute"/>
		<meta>
			<m n=":value"><e>cast 0x200</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SPARSE_FILE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._NativeAPI.FileAttribute_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
		<ARCHIVE public="1" get="inline" set="null" expr="cast 0x20" line="262" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x20</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ARCHIVE>
		<HIDDEN public="1" get="inline" set="null" expr="cast 0x2" line="263" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HIDDEN>
		<NORMAL public="1" get="inline" set="null" expr="cast 0x80" line="264" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x80</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NORMAL>
		<NOT_CONTENT_INDEXED public="1" get="inline" set="null" expr="cast 0x2000" line="265" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x2000</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOT_CONTENT_INDEXED>
		<OFFLINE public="1" get="inline" set="null" expr="cast 0x1000" line="266" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x1000</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OFFLINE>
		<READONLY public="1" get="inline" set="null" expr="cast 0x1" line="267" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</READONLY>
		<SYSTEM public="1" get="inline" set="null" expr="cast 0x4" line="268" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SYSTEM>
		<TEMPORARY public="1" get="inline" set="null" expr="cast 0x100" line="269" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x100</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TEMPORARY>
		<COMPRESSED public="1" get="inline" set="null" expr="cast 0x800" line="272" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x800</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</COMPRESSED>
		<DEVICE public="1" get="inline" set="null" expr="cast 0x40" line="273" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x40</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DEVICE>
		<DIRECTORY public="1" get="inline" set="null" expr="cast 0x10" line="274" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DIRECTORY>
		<ENCRYPTED public="1" get="inline" set="null" expr="cast 0x4000" line="275" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x4000</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ENCRYPTED>
		<REPARSE_POINT public="1" get="inline" set="null" expr="cast 0x400" line="276" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x400</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</REPARSE_POINT>
		<SPARSE_FILE public="1" get="inline" set="null" expr="cast 0x200" line="277" static="1">
			<x path="funkin.backend.utils.FileAttribute"/>
			<meta>
				<m n=":value"><e>cast 0x200</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SPARSE_FILE>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="funkin.backend.utils.ConsoleColor" params="" file="source/funkin/backend/utils/NativeAPI.hx" module="funkin.backend.utils.NativeAPI">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._NativeAPI.ConsoleColor_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
	<BLACK public="1" get="inline" set="null" expr="cast 0" line="281" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BLACK>
	<DARKBLUE public="1" get="inline" set="null" expr="cast 1" line="282" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKBLUE>
	<DARKGREEN public="1" get="inline" set="null" expr="cast 2" line="283" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKGREEN>
	<DARKCYAN public="1" get="inline" set="null" expr="cast 3" line="284" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKCYAN>
	<DARKRED public="1" get="inline" set="null" expr="cast 4" line="285" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKRED>
	<DARKMAGENTA public="1" get="inline" set="null" expr="cast 5" line="286" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKMAGENTA>
	<DARKYELLOW public="1" get="inline" set="null" expr="cast 6" line="287" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DARKYELLOW>
	<LIGHTGRAY public="1" get="inline" set="null" expr="cast 7" line="288" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LIGHTGRAY>
	<GRAY public="1" get="inline" set="null" expr="cast 8" line="289" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GRAY>
	<BLUE public="1" get="inline" set="null" expr="cast 9" line="290" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BLUE>
	<GREEN public="1" get="inline" set="null" expr="cast 10" line="291" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</GREEN>
	<CYAN public="1" get="inline" set="null" expr="cast 11" line="292" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CYAN>
	<RED public="1" get="inline" set="null" expr="cast 12" line="293" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RED>
	<MAGENTA public="1" get="inline" set="null" expr="cast 13" line="294" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MAGENTA>
	<YELLOW public="1" get="inline" set="null" expr="cast 14" line="295" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</YELLOW>
	<WHITE public="1" get="inline" set="null" expr="cast 15" line="296" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WHITE>
	<NONE public="1" get="inline" set="null" expr="cast -1" line="298" static="1">
		<x path="funkin.backend.utils.ConsoleColor"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._NativeAPI.ConsoleColor_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
		<BLACK public="1" get="inline" set="null" expr="cast 0" line="281" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BLACK>
		<DARKBLUE public="1" get="inline" set="null" expr="cast 1" line="282" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKBLUE>
		<DARKGREEN public="1" get="inline" set="null" expr="cast 2" line="283" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKGREEN>
		<DARKCYAN public="1" get="inline" set="null" expr="cast 3" line="284" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKCYAN>
		<DARKRED public="1" get="inline" set="null" expr="cast 4" line="285" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKRED>
		<DARKMAGENTA public="1" get="inline" set="null" expr="cast 5" line="286" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKMAGENTA>
		<DARKYELLOW public="1" get="inline" set="null" expr="cast 6" line="287" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DARKYELLOW>
		<LIGHTGRAY public="1" get="inline" set="null" expr="cast 7" line="288" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LIGHTGRAY>
		<GRAY public="1" get="inline" set="null" expr="cast 8" line="289" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GRAY>
		<BLUE public="1" get="inline" set="null" expr="cast 9" line="290" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BLUE>
		<GREEN public="1" get="inline" set="null" expr="cast 10" line="291" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</GREEN>
		<CYAN public="1" get="inline" set="null" expr="cast 11" line="292" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CYAN>
		<RED public="1" get="inline" set="null" expr="cast 12" line="293" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RED>
		<MAGENTA public="1" get="inline" set="null" expr="cast 13" line="294" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MAGENTA>
		<YELLOW public="1" get="inline" set="null" expr="cast 14" line="295" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</YELLOW>
		<WHITE public="1" get="inline" set="null" expr="cast 15" line="296" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WHITE>
		<NONE public="1" get="inline" set="null" expr="cast -1" line="298" static="1">
			<x path="funkin.backend.utils.ConsoleColor"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="funkin.backend.utils.MessageBoxIcon" params="" file="source/funkin/backend/utils/NativeAPI.hx" module="funkin.backend.utils.NativeAPI">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._NativeAPI.MessageBoxIcon_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
	<MSG_ERROR public="1" get="inline" set="null" expr="cast 0x00000010" line="302" static="1">
		<x path="funkin.backend.utils.MessageBoxIcon"/>
		<meta>
			<m n=":value"><e>cast 0x00000010</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MSG_ERROR>
	<MSG_QUESTION public="1" get="inline" set="null" expr="cast 0x00000020" line="303" static="1">
		<x path="funkin.backend.utils.MessageBoxIcon"/>
		<meta>
			<m n=":value"><e>cast 0x00000020</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MSG_QUESTION>
	<MSG_WARNING public="1" get="inline" set="null" expr="cast 0x00000030" line="304" static="1">
		<x path="funkin.backend.utils.MessageBoxIcon"/>
		<meta>
			<m n=":value"><e>cast 0x00000030</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MSG_WARNING>
	<MSG_INFORMATION public="1" get="inline" set="null" expr="cast 0x00000040" line="305" static="1">
		<x path="funkin.backend.utils.MessageBoxIcon"/>
		<meta>
			<m n=":value"><e>cast 0x00000040</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MSG_INFORMATION>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._NativeAPI.MessageBoxIcon_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" extern="1" final="1">
		<MSG_ERROR public="1" get="inline" set="null" expr="cast 0x00000010" line="302" static="1">
			<x path="funkin.backend.utils.MessageBoxIcon"/>
			<meta>
				<m n=":value"><e>cast 0x00000010</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MSG_ERROR>
		<MSG_QUESTION public="1" get="inline" set="null" expr="cast 0x00000020" line="303" static="1">
			<x path="funkin.backend.utils.MessageBoxIcon"/>
			<meta>
				<m n=":value"><e>cast 0x00000020</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MSG_QUESTION>
		<MSG_WARNING public="1" get="inline" set="null" expr="cast 0x00000030" line="304" static="1">
			<x path="funkin.backend.utils.MessageBoxIcon"/>
			<meta>
				<m n=":value"><e>cast 0x00000030</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MSG_WARNING>
		<MSG_INFORMATION public="1" get="inline" set="null" expr="cast 0x00000040" line="305" static="1">
			<x path="funkin.backend.utils.MessageBoxIcon"/>
			<meta>
				<m n=":value"><e>cast 0x00000040</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MSG_INFORMATION>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="funkin.backend.utils.CodeCursor" params="" file="source/funkin/backend/utils/NativeAPI.hx" module="funkin.backend.utils.NativeAPI">
		<this><c path="String"/></this>
		<to>
			<icast field="toOpenFL"><x path="openfl.ui.MouseCursor"/></icast>
			<icast field="toInt"><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._NativeAPI.CodeCursor_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" final="1">
	<CUSTOM public="1" get="inline" set="null" expr="cast &quot;CUSTOM&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "CUSTOM"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CUSTOM>
	<ARROW public="1" get="inline" set="null" expr="cast &quot;ARROW&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "ARROW"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ARROW>
	<CLICK public="1" get="inline" set="null" expr="cast &quot;CLICK&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "CLICK"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CLICK>
	<CROSSHAIR public="1" get="inline" set="null" expr="cast &quot;CROSSHAIR&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "CROSSHAIR"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CROSSHAIR>
	<HAND public="1" get="inline" set="null" expr="cast &quot;HAND&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "HAND"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HAND>
	<IBEAM public="1" get="inline" set="null" expr="cast &quot;IBEAM&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "IBEAM"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</IBEAM>
	<MOVE public="1" get="inline" set="null" expr="cast &quot;MOVE&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "MOVE"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MOVE>
	<RESIZE_H public="1" get="inline" set="null" expr="cast &quot;RESIZE_H&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_H"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_H>
	<RESIZE_V public="1" get="inline" set="null" expr="cast &quot;RESIZE_V&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_V"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_V>
	<RESIZE_TL public="1" get="inline" set="null" expr="cast &quot;RESIZE_TL&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_TL"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_TL>
	<RESIZE_TR public="1" get="inline" set="null" expr="cast &quot;RESIZE_TR&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_TR"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_TR>
	<RESIZE_BL public="1" get="inline" set="null" expr="cast &quot;RESIZE_BL&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_BL"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_BL>
	<RESIZE_BR public="1" get="inline" set="null" expr="cast &quot;RESIZE_BR&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_BR"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_BR>
	<RESIZE_T public="1" get="inline" set="null" expr="cast &quot;RESIZE_T&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_T"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_T>
	<RESIZE_B public="1" get="inline" set="null" expr="cast &quot;RESIZE_B&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_B"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_B>
	<RESIZE_L public="1" get="inline" set="null" expr="cast &quot;RESIZE_L&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_L"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_L>
	<RESIZE_R public="1" get="inline" set="null" expr="cast &quot;RESIZE_R&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_R"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_R>
	<RESIZE_TLBR public="1" get="inline" set="null" expr="cast &quot;RESIZE_TLBR&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_TLBR"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_TLBR>
	<RESIZE_TRBL public="1" get="inline" set="null" expr="cast &quot;RESIZE_TRBL&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "RESIZE_TRBL"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RESIZE_TRBL>
	<WAIT public="1" get="inline" set="null" expr="cast &quot;WAIT&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "WAIT"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WAIT>
	<WAIT_ARROW public="1" get="inline" set="null" expr="cast &quot;WAIT_ARROW&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "WAIT_ARROW"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</WAIT_ARROW>
	<DISABLED public="1" get="inline" set="null" expr="cast &quot;DISABLED&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "DISABLED"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DISABLED>
	<DRAG public="1" get="inline" set="null" expr="cast &quot;DRAG&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "DRAG"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DRAG>
	<DRAG_OPEN public="1" get="inline" set="null" expr="cast &quot;DRAG_OPEN&quot;" line="1" static="1">
		<x path="funkin.backend.utils.CodeCursor"/>
		<meta>
			<m n=":value"><e>cast "DRAG_OPEN"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DRAG_OPEN>
	<toOpenFL public="1" set="method" line="337" static="1">
		<f a="this">
			<c path="String"/>
			<x path="openfl.ui.MouseCursor"/>
		</f>
		<meta><m n=":to"/></meta>
	</toOpenFL>
	<toInt public="1" set="method" line="371" static="1">
		<f a="this">
			<c path="String"/>
			<x path="Int"/>
		</f>
		<meta><m n=":to"/></meta>
	</toInt>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._NativeAPI.CodeCursor_Impl_" params="" file="source/funkin/backend/utils/NativeAPI.hx" private="1" module="funkin.backend.utils.NativeAPI" final="1">
		<CUSTOM public="1" get="inline" set="null" expr="cast &quot;CUSTOM&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "CUSTOM"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CUSTOM>
		<ARROW public="1" get="inline" set="null" expr="cast &quot;ARROW&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "ARROW"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ARROW>
		<CLICK public="1" get="inline" set="null" expr="cast &quot;CLICK&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "CLICK"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CLICK>
		<CROSSHAIR public="1" get="inline" set="null" expr="cast &quot;CROSSHAIR&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "CROSSHAIR"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CROSSHAIR>
		<HAND public="1" get="inline" set="null" expr="cast &quot;HAND&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "HAND"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HAND>
		<IBEAM public="1" get="inline" set="null" expr="cast &quot;IBEAM&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "IBEAM"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</IBEAM>
		<MOVE public="1" get="inline" set="null" expr="cast &quot;MOVE&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "MOVE"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MOVE>
		<RESIZE_H public="1" get="inline" set="null" expr="cast &quot;RESIZE_H&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_H"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_H>
		<RESIZE_V public="1" get="inline" set="null" expr="cast &quot;RESIZE_V&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_V"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_V>
		<RESIZE_TL public="1" get="inline" set="null" expr="cast &quot;RESIZE_TL&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_TL"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_TL>
		<RESIZE_TR public="1" get="inline" set="null" expr="cast &quot;RESIZE_TR&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_TR"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_TR>
		<RESIZE_BL public="1" get="inline" set="null" expr="cast &quot;RESIZE_BL&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_BL"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_BL>
		<RESIZE_BR public="1" get="inline" set="null" expr="cast &quot;RESIZE_BR&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_BR"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_BR>
		<RESIZE_T public="1" get="inline" set="null" expr="cast &quot;RESIZE_T&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_T"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_T>
		<RESIZE_B public="1" get="inline" set="null" expr="cast &quot;RESIZE_B&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_B"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_B>
		<RESIZE_L public="1" get="inline" set="null" expr="cast &quot;RESIZE_L&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_L"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_L>
		<RESIZE_R public="1" get="inline" set="null" expr="cast &quot;RESIZE_R&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_R"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_R>
		<RESIZE_TLBR public="1" get="inline" set="null" expr="cast &quot;RESIZE_TLBR&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_TLBR"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_TLBR>
		<RESIZE_TRBL public="1" get="inline" set="null" expr="cast &quot;RESIZE_TRBL&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "RESIZE_TRBL"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RESIZE_TRBL>
		<WAIT public="1" get="inline" set="null" expr="cast &quot;WAIT&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "WAIT"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WAIT>
		<WAIT_ARROW public="1" get="inline" set="null" expr="cast &quot;WAIT_ARROW&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "WAIT_ARROW"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</WAIT_ARROW>
		<DISABLED public="1" get="inline" set="null" expr="cast &quot;DISABLED&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "DISABLED"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DISABLED>
		<DRAG public="1" get="inline" set="null" expr="cast &quot;DRAG&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "DRAG"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DRAG>
		<DRAG_OPEN public="1" get="inline" set="null" expr="cast &quot;DRAG_OPEN&quot;" line="1" static="1">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta>
				<m n=":value"><e>cast "DRAG_OPEN"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DRAG_OPEN>
		<toOpenFL public="1" set="method" line="337" static="1">
			<f a="this">
				<c path="String"/>
				<x path="openfl.ui.MouseCursor"/>
			</f>
			<meta><m n=":to"/></meta>
		</toOpenFL>
		<toInt public="1" set="method" line="371" static="1">
			<f a="this">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":to"/></meta>
		</toInt>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="funkin.backend.utils.NdllUtil" params="" file="source/funkin/backend/utils/NdllUtil.hx" final="1">
		<os final="1" public="1" set="null" expr="&quot;windows&quot;" line="19" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"windows"</e></m></meta>
		</os>
		<getFunction public="1" set="method" line="34" static="1">
			<f a="ndll:name:args">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>* Returns an function from a Haxe NDLL.
	 * Limited to 25 argument due to a limitation
	 *
	 * @param ndll Name of the NDLL.
	 * @param name Name of the function.
	 * @param args Number of arguments of that function.</haxe_doc>
		</getFunction>
		<getFunctionFromPath public="1" set="method" line="56" static="1">
			<f a="ndll:name:args">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>* Returns an function from a Haxe NDLL at specified path.
	 *
	 * @param ndll Asset path to the NDLL.
	 * @param name Name of the function.
	 * @param args Number of arguments of that function.</haxe_doc>
		</getFunctionFromPath>
		<noop set="method" line="75" static="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</noop>
		<haxe_doc>* Small util that allows you to load any function from ndlls via `getFunction`.
 *
 * NDLLs must be in your mod's "ndlls" folder, and must follow this name scheme:
 * - `name-windows.ndll` for Windows targeted ndlls
 * - `name-linux.ndll` for Linux targeted ndlls
 * - `name-mac.ndll` for Mac targeted ndlls
 *
 * If:
 * - The platform does not support NDLLs
 * - The NDLL is not found
 * - The Function cannot be found in the NDLL
 * then an empty function will be returned instead, and a message will be shown in logs.</haxe_doc>
	</class>
	<abstract path="funkin.backend.utils.RegistryHive" params="" file="source/funkin/backend/utils/RegistryUtil.hx" module="funkin.backend.utils.RegistryUtil">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.backend.utils._RegistryUtil.RegistryHive_Impl_" params="" file="source/funkin/backend/utils/RegistryUtil.hx" private="1" module="funkin.backend.utils.RegistryUtil" extern="1" final="1">
	<HKEY_CLASSES_ROOT public="1" get="inline" set="null" expr="cast 0x80000000" line="4" static="1">
		<x path="funkin.backend.utils.RegistryHive"/>
		<meta>
			<m n=":value"><e>cast 0x80000000</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HKEY_CLASSES_ROOT>
	<HKEY_CURRENT_USER public="1" get="inline" set="null" expr="cast 0x80000001" line="5" static="1">
		<x path="funkin.backend.utils.RegistryHive"/>
		<meta>
			<m n=":value"><e>cast 0x80000001</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HKEY_CURRENT_USER>
	<HKEY_LOCAL_MACHINE public="1" get="inline" set="null" expr="cast 0x80000002" line="6" static="1">
		<x path="funkin.backend.utils.RegistryHive"/>
		<meta>
			<m n=":value"><e>cast 0x80000002</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HKEY_LOCAL_MACHINE>
	<HKEY_USERS public="1" get="inline" set="null" expr="cast 0x80000003" line="7" static="1">
		<x path="funkin.backend.utils.RegistryHive"/>
		<meta>
			<m n=":value"><e>cast 0x80000003</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HKEY_USERS>
	<HKEY_CURRENT_CONFIG public="1" get="inline" set="null" expr="cast 0x80000005" line="8" static="1">
		<x path="funkin.backend.utils.RegistryHive"/>
		<meta>
			<m n=":value"><e>cast 0x80000005</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</HKEY_CURRENT_CONFIG>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._RegistryUtil.RegistryHive_Impl_" params="" file="source/funkin/backend/utils/RegistryUtil.hx" private="1" module="funkin.backend.utils.RegistryUtil" extern="1" final="1">
		<HKEY_CLASSES_ROOT public="1" get="inline" set="null" expr="cast 0x80000000" line="4" static="1">
			<x path="funkin.backend.utils.RegistryHive"/>
			<meta>
				<m n=":value"><e>cast 0x80000000</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HKEY_CLASSES_ROOT>
		<HKEY_CURRENT_USER public="1" get="inline" set="null" expr="cast 0x80000001" line="5" static="1">
			<x path="funkin.backend.utils.RegistryHive"/>
			<meta>
				<m n=":value"><e>cast 0x80000001</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HKEY_CURRENT_USER>
		<HKEY_LOCAL_MACHINE public="1" get="inline" set="null" expr="cast 0x80000002" line="6" static="1">
			<x path="funkin.backend.utils.RegistryHive"/>
			<meta>
				<m n=":value"><e>cast 0x80000002</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HKEY_LOCAL_MACHINE>
		<HKEY_USERS public="1" get="inline" set="null" expr="cast 0x80000003" line="7" static="1">
			<x path="funkin.backend.utils.RegistryHive"/>
			<meta>
				<m n=":value"><e>cast 0x80000003</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HKEY_USERS>
		<HKEY_CURRENT_CONFIG public="1" get="inline" set="null" expr="cast 0x80000005" line="8" static="1">
			<x path="funkin.backend.utils.RegistryHive"/>
			<meta>
				<m n=":value"><e>cast 0x80000005</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</HKEY_CURRENT_CONFIG>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.backend.utils.RegistryUtil" params="" file="source/funkin/backend/utils/RegistryUtil.hx">
		<get public="1" set="method" line="49" static="1">
			<f a="hive:key:string">
				<x path="funkin.backend.utils.RegistryHive"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tHKEY hKey;\r\n\t\tLONG result;\r\n\t\tDWORD dataSize = 0;\r\n\t\tDWORD dataType = 0;\r\n\r\n\t\tstd::wstring subkey = std::wstring(key.wchar_str());\r\n\t\tstd::wstring valname = std::wstring(string.wchar_str());\r\n\r\n\t\tresult = RegOpenKeyExW((HKEY)reinterpret_cast&lt;HKEY&gt;(static_cast&lt;uintptr_t&gt;(hive)), subkey.c_str(), 0, KEY_READ, &amp;hKey);\r\n\t\tif (result != ERROR_SUCCESS) return null();\r\n\r\n\t\tresult = RegQueryValueExW(hKey, valname.c_str(), NULL, &amp;dataType, NULL, &amp;dataSize);\r\n\t\tif (result != ERROR_SUCCESS || dataSize == 0) {\r\n\t\t\tRegCloseKey(hKey);\r\n\t\t\treturn null();\r\n\t\t}\r\n\r\n\t\tstd::vector&lt;wchar_t&gt; buffer(dataSize / sizeof(wchar_t));\r\n\t\tresult = RegQueryValueExW(hKey, valname.c_str(), NULL, NULL, (LPBYTE)buffer.data(), &amp;dataSize);\r\n\t\tRegCloseKey(hKey);\r\n\r\n\t\tif (result == ERROR_SUCCESS) {\r\n\t\t\treturn ::String(buffer.data());\r\n\t\t}\r\n\t\treturn null();\r\n\t"</e></m></meta>
		</get>
		<set public="1" set="method" line="72" static="1">
			<f a="hive:key:string:value">
				<x path="funkin.backend.utils.RegistryHive"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tHKEY hKey;\r\n\t\tLONG result;\r\n\r\n\t\tstd::wstring subkey = std::wstring(key.wchar_str());\r\n\t\tstd::wstring valname = std::wstring(string.wchar_str());\r\n\t\tstd::wstring data = std::wstring(value.wchar_str());\r\n\r\n\t\tresult = RegCreateKeyExW((HKEY)reinterpret_cast&lt;HKEY&gt;(static_cast&lt;uintptr_t&gt;(hive)), subkey.c_str(), 0, NULL, 0, KEY_WRITE, NULL, &amp;hKey, NULL);\r\n\t\tif (result != ERROR_SUCCESS) return false;\r\n\r\n\t\tresult = RegSetValueExW(hKey, valname.c_str(), 0, REG_SZ, (const BYTE*)data.c_str(), (DWORD)((data.length() + 1) * sizeof(wchar_t)));\r\n\t\tRegCloseKey(hKey);\r\n\r\n\t\treturn result == ERROR_SUCCESS;\r\n\t"</e></m></meta>
		</set>
		<exists public="1" set="method" line="96" static="1">
			<f a="hive:key:string">
				<x path="funkin.backend.utils.RegistryHive"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tHKEY hKey;\r\n\t\tLONG result;\r\n\r\n\t\tstd::wstring subkey = std::wstring(key.wchar_str());\r\n\t\tstd::wstring valname = std::wstring(string.wchar_str());\r\n\r\n\t\tresult = RegOpenKeyExW((HKEY)reinterpret_cast&lt;HKEY&gt;(static_cast&lt;uintptr_t&gt;(hive)), subkey.c_str(), 0, KEY_READ, &amp;hKey);\r\n\t\tif (result != ERROR_SUCCESS) return false;\r\n\r\n\t\tDWORD dataType = 0;\r\n\t\tresult = RegQueryValueExW(hKey, valname.c_str(), NULL, &amp;dataType, NULL, NULL);\r\n\r\n\t\tRegCloseKey(hKey);\r\n\r\n\t\treturn result == ERROR_SUCCESS;\r\n\t"</e></m></meta>
		</exists>
		<delete public="1" set="method" line="117" static="1">
			<f a="hive:key:string">
				<x path="funkin.backend.utils.RegistryHive"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tHKEY hKey;\r\n\t\tLONG result;\r\n\r\n\t\tstd::wstring subkey = std::wstring(key.wchar_str());\r\n\t\tstd::wstring valname = std::wstring(string.wchar_str());\r\n\r\n\t\tresult = RegOpenKeyExW((HKEY)reinterpret_cast&lt;HKEY&gt;(static_cast&lt;uintptr_t&gt;(hive)), subkey.c_str(), 0, KEY_SET_VALUE, &amp;hKey);\r\n\t\tif (result != ERROR_SUCCESS) return false;\r\n\r\n\t\tresult = RegDeleteValueW(hKey, valname.c_str());\r\n\t\tRegCloseKey(hKey);\r\n\r\n\t\treturn result == ERROR_SUCCESS;\r\n\t"</e></m></meta>
		</delete>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":cppFileCode"><e>"\r\n#include &lt;windows.h&gt;\r\n#include &lt;tchar.h&gt;\r\n#include &lt;string&gt;\r\n#include &lt;vector&gt;\r\n"</e></m>
		</meta>
	</class>
	<class path="funkin.backend.utils.ShaderResizeFix" params="" file="source/funkin/backend/utils/ShaderResizeFix.hx" final="1">
		<doResizeFix public="1" expr="true" line="6" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</doResizeFix>
		<init public="1" set="method" line="8" static="1"><f a=""><x path="Void"/></f></init>
		<fixSpritesShadersSizes public="1" get="inline" set="null" line="12" static="1"><f a=""><x path="Void"/></f></fixSpritesShadersSizes>
		<fixSpriteShaderSize public="1" get="inline" set="null" line="27" static="1"><f a="sprite">
	<c path="openfl.display.Sprite"/>
	<x path="Void"/>
</f></fixSpriteShaderSize>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.SortedArrayUtil" params="" file="source/funkin/backend/utils/SortedArrayUtil.hx" final="1">
		<binarySearch public="1" params="T" set="method" line="15" static="1">
			<f a="array:val:getVal">
				<c path="Array"><c path="binarySearch.T"/></c>
				<x path="Float"/>
				<f a="">
					<c path="binarySearch.T"/>
					<x path="Float"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>* Gets the index of a possible new element of an Array of T using an efficient algorithm.
	 * @param array Array of T to check in
	 * @param getVal Function that returns the position value of T
	 * @return The index of the element</haxe_doc>
		</binarySearch>
		<addSorted public="1" params="T" get="inline" set="null" line="47" static="1">
			<f a="array:val:getVal">
				<c path="Array"><c path="addSorted.T"/></c>
				<c path="addSorted.T"/>
				<f a="">
					<c path="addSorted.T"/>
					<x path="Float"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to a sorted array, using binary search.
	 * @param array Array to add to
	 * @param val Value to add
	 * @param getVal Function that returns the value that needs to be sorted</haxe_doc>
		</addSorted>
		<removeSorted public="1" params="T" get="inline" set="null" line="58" static="1">
			<f a="array:val:getVal">
				<c path="Array"><c path="removeSorted.T"/></c>
				<c path="removeSorted.T"/>
				<f a="">
					<c path="removeSorted.T"/>
					<x path="Float"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes from a sorted array, using binary search.
	 * @param array Array to remove from
	 * @param val Value to remove
	 * @param getVal Function that returns the value that needs to be sorted</haxe_doc>
		</removeSorted>
		<haxe_doc>* Tools to work with sorted arrays, in a more efficient way.
 *
 * DISCLAIMER: All types of utils only usable in a sorted array.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.SysZip" params="" file="source/funkin/backend/utils/SysZip.hx">
		<extends path="haxe.zip.Reader"/>
		<openFromFile public="1" set="method" line="25" static="1">
			<f a="path">
				<c path="String"/>
				<c path="funkin.backend.utils.SysZip"/>
			</f>
			<haxe_doc>* Opens a zip from a specified path.
	 * @param path Path to the zip file.</haxe_doc>
		</openFromFile>
		<input><c path="haxe.io.Input"/></input>
		<fileInput><c path="sys.io.FileInput"/></fileInput>
		<entries public="1"><t path="List"><t path="funkin.backend.utils.SysZipEntry"/></t></entries>
		<readEntryData public="1" set="method" line="44">
			<f a="e">
				<t path="funkin.backend.utils.SysZipEntry"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Reads all the data present in a specified entry.
	 * NOTE: If the entry is compressed, the data won't be decompressed. For decompression, use `unzipEntry`.
	 * @param e Entry</haxe_doc>
		</readEntryData>
		<unzipEntry public="1" set="method" line="116">
			<f a="f">
				<t path="funkin.backend.utils.SysZipEntry"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Unzips and returns all of the data present in an entry.
	 * @param f Entry to read from.</haxe_doc>
		</unzipEntry>
		<read public="1" set="method" line="131" override="1"><f a=""><t path="List"><t path="haxe.zip.Entry"/></t></f></read>
		<dispose public="1" set="method" line="148"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="34">
			<f a="input">
				<c path="sys.io.FileInput"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new SysZip from a specified file input.
	 * @param input File input.</haxe_doc>
		</new>
		<haxe_doc>* Class that extends Reader allowing you to load ZIP entries without blowing your RAM up!!
 * Half of the code is taken from haxe libraries btw</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.utils.SysZipEntry" params="" file="source/funkin/backend/utils/SysZip.hx" module="funkin.backend.utils.SysZip"><a>
	<seekPos><x path="Int"/></seekPos>
	<fileTime><c path="Date"/></fileTime>
	<fileSize><x path="Int"/></fileSize>
	<fileName><c path="String"/></fileName>
	<extraFields>
		<x path="Null"><c path="haxe.ds.List"><e path="haxe.zip.ExtraField"/></c></x>
		<meta><m n=":optional"/></meta>
	</extraFields>
	<dataSize><x path="Int"/></dataSize>
	<data><x path="Null"><c path="haxe.io.Bytes"/></x></data>
	<crc32><x path="Null"><x path="Int"/></x></crc32>
	<compressed><x path="Bool"/></compressed>
</a></typedef>
	<class path="funkin.backend.utils.ThreadUtil" params="" file="source/funkin/backend/utils/ThreadUtil.hx" final="1"><createSafe public="1" set="method" line="10" static="1">
	<f a="func:?autoRestart" v=":false">
		<f a=""><x path="Void"/></f>
		<x path="Bool"/>
		<x path="sys.thread.Thread"/>
	</f>
	<meta><m n=":value"><e>{ autoRestart : false }</e></m></meta>
	<haxe_doc>* Creates a new Thread with an error handler.
	 * @param func Function to execute
	 * @param autoRestart Whenever the thread should auto restart itself after crashing.</haxe_doc>
</createSafe></class>
	<class path="funkin.backend.utils.TranslationUtil" params="" file="source/funkin/backend/utils/TranslationUtil.hx" final="1">
		<stringMap public="1" set="accessor" expr="[]" line="25" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.backend.utils.translations.IFormatInfo"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The current language selected translation map.
	 *
	 * It'll never be `null`.</haxe_doc>
		</stringMap>
		<alternativeStringMap public="1" set="accessor" expr="[]" line="36" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.backend.utils.translations.IFormatInfo"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The alternative language selected translation map.
	 * It is filled with the default language.
	 *
	 * This is filled in if the current language is not the same as the default language.
	 * Its used when showMissingIds in the config is false (or is not present).
	 *
	 * It'll never be `null`.</haxe_doc>
		</alternativeStringMap>
		<config public="1" expr="[]" line="41" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Returns the current language config.</haxe_doc>
		</config>
		<curLanguage public="1" get="accessor" set="accessor" static="1">
			<c path="String"/>
			<haxe_doc>* Returns the current language.</haxe_doc>
		</curLanguage>
		<curLanguageName public="1" get="accessor" set="accessor" static="1">
			<c path="String"/>
			<haxe_doc>* Returns the current language name.</haxe_doc>
		</curLanguageName>
		<isDefaultLanguage public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* Returns if the current language is the default one (`DEFAULT_LANGUAGE`).</haxe_doc>
		</isDefaultLanguage>
		<isLanguageLoaded public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* Returns if any translation are loaded.</haxe_doc>
		</isLanguageLoaded>
		<foundLanguages public="1" expr="[]" line="64" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Returns an array has a list of the languages that were found.</haxe_doc>
		</foundLanguages>
		<LANG_FOLDER get="inline" set="null" expr="&quot;languages&quot;" line="67" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"languages"</e></m></meta>
		</LANG_FOLDER>
		<langConfigs expr="[]" line="68" static="1">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<c path="String"/>
				</t>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</langConfigs>
		<nameMap expr="[]" line="69" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</nameMap>
		<getDefaultNameMap get="inline" set="null" line="70" static="1"><f a=""><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></f></getDefaultNameMap>
		<getDefaultLangConfigs get="inline" set="null" line="73" static="1"><f a=""><t path="Map">
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
</t></f></getDefaultLangConfigs>
		<getDefaultConfig get="inline" set="null" line="76" static="1">
			<f a="name">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<c path="String"/>
				</t>
			</f>
			<meta><m n=":noUsing"/></meta>
		</getDefaultConfig>
		<setLanguage public="1" set="method" line="87" static="1">
			<f a="?name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates the language.
	 * Also changes the translations map.
	 *
	 * If `name` is `null`, its gonna use the current language.
	 * If `name` is not `null`, it will load the translations for the given language.</haxe_doc>
		</setLanguage>
		<get public="1" get="inline" set="null" line="127" static="1">
			<f a="?id:?params:?def">
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* This is for checking and getting a translation, `defString` it's just the string that gets returned just in case it won't find the translation OR the current language selected is ``DEFAULT_LANGUAGE``.
	 *
	 * If `id` is `null` then it's gonna search using `defString`.</haxe_doc>
		</get>
		<translate public="1" get="inline" set="null" line="130" static="1"><f a="?id:?params:?def">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
	<c path="String"/>
</f></translate>
		<translateDiff public="1" get="inline" set="null" line="133" static="1"><f a="?id:?params">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translateDiff>
		<exists public="1" set="method" line="135" static="1"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getRaw public="1" set="method" line="143" static="1"><f a="id:?def">
	<c path="String"/>
	<c path="String"/>
	<c path="funkin.backend.utils.translations.IFormatInfo"/>
</f></getRaw>
		<raw2Id public="1" set="method" line="169" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Formats a normal string into an ID for translations.
	 *
	 * Example: `Resume Song` =&gt; `resumeSong`</haxe_doc>
		</raw2Id>
		<isBlacklisted public="1" get="inline" set="null" line="177" static="1"><f a="lang">
	<c path="String"/>
	<x path="Bool"/>
</f></isBlacklisted>
		<isWhitelisted public="1" get="inline" set="null" line="180" static="1"><f a="lang">
	<c path="String"/>
	<x path="Bool"/>
</f></isWhitelisted>
		<isAllowed public="1" get="inline" set="null" line="183" static="1"><f a="lang">
	<c path="String"/>
	<x path="Bool"/>
</f></isAllowed>
		<findAllLanguages public="1" set="method" line="189" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Returns an array that specifies which languages were found.</haxe_doc>
		</findAllLanguages>
		<loadLanguage public="1" set="method" line="235" static="1">
			<f a="lang">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<c path="funkin.backend.utils.translations.IFormatInfo"/>
				</t>
			</f>
			<haxe_doc>* Returns a map of translations based on its XML.</haxe_doc>
		</loadLanguage>
		<getLanguageName public="1" set="method" line="309" static="1"><f a="lang">
	<c path="String"/>
	<c path="String"/>
</f></getLanguageName>
		<getLanguageFromName public="1" set="method" line="313" static="1"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getLanguageFromName>
		<getConfig public="1" set="method" line="319" static="1"><f a="lang">
	<c path="String"/>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
</f></getConfig>
		<isShowingMissingIds public="1" get="inline" set="null" line="323" static="1"><f a=""><x path="Bool"/></f></isShowingMissingIds>
		<translationsMain public="1" get="inline" set="null" line="328" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></translationsMain>
		<translations public="1" get="inline" set="null" line="331" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></translations>
		<set_stringMap set="method" line="335" static="1">
			<f a="value">
				<t path="Map">
					<c path="String"/>
					<c path="funkin.backend.utils.translations.IFormatInfo"/>
				</t>
				<t path="Map">
					<c path="String"/>
					<c path="funkin.backend.utils.translations.IFormatInfo"/>
				</t>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_stringMap>
		<set_alternativeStringMap set="method" line="340" static="1">
			<f a="value">
				<t path="Map">
					<c path="String"/>
					<c path="funkin.backend.utils.translations.IFormatInfo"/>
				</t>
				<t path="Map">
					<c path="String"/>
					<c path="funkin.backend.utils.translations.IFormatInfo"/>
				</t>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_alternativeStringMap>
		<get_curLanguage set="method" line="345" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_curLanguage>
		<set_curLanguage set="method" line="348" static="1">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_curLanguage>
		<get_curLanguageName set="method" line="352" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_curLanguageName>
		<set_curLanguageName set="method" line="355" static="1">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_curLanguageName>
		<get_isDefaultLanguage set="method" line="360" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isDefaultLanguage>
		<get_isLanguageLoaded set="method" line="363" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isLanguageLoaded>
		<haxe_doc>* The class used for translations based on the XMLs inside the translations folders.
 *
 * Made by @NexIsDumb originally for the Poldhub mod.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.backend.assets.TranslatedAssetLibrary</e></m>
		</meta>
	</class>
	<class path="funkin.backend.utils.TranslationPair" params="" file="source/funkin/backend/utils/TranslationUtil.hx" module="funkin.backend.utils.TranslationUtil">
		<prefix public="1"><c path="String"/></prefix>
		<node public="1"><x path="haxe.xml.Access"/></node>
		<new public="1" set="method" line="367">
			<f a="prefix:node">
				<c path="String"/>
				<x path="haxe.xml.Access"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="funkin.backend.utils.WindowUtils" params="" file="source/funkin/backend/utils/WindowUtils.hx" final="1">
		<title public="1" set="accessor" static="1"><c path="String"/></title>
		<set_title set="method" line="7" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_title>
		<prefix public="1" set="accessor" expr="&quot;&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</prefix>
		<set_prefix set="method" line="13" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_prefix>
		<suffix public="1" set="accessor" expr="&quot;&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</suffix>
		<set_suffix set="method" line="19" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_suffix>
		<preventClosing public="1" expr="true" line="25" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</preventClosing>
		<onClosing public="1" static="1"><f a=""><x path="Void"/></f></onClosing>
		<__triedClosing expr="false" line="28" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__triedClosing>
		<resetClosing public="1" get="inline" set="null" line="29" static="1"><f a=""><x path="Void"/></f></resetClosing>
		<init public="1" get="inline" set="null" line="31" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</init>
		<resetTitle public="1" get="inline" set="null" line="47" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the window title to the application name and resets the prefix and suffix.</haxe_doc>
		</resetTitle>
		<resetAffixes public="1" get="inline" set="null" line="55" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the prefix and suffix.</haxe_doc>
		</resetAffixes>
		<setWindow public="1" get="inline" set="null" line="66" static="1">
			<f a="?name:?image">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the window title and icon.
	 * @param title The title to set.
	 * @param image The image to set as the icon.</haxe_doc>
		</setWindow>
		<updateTitle public="1" get="inline" set="null" line="74" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the window title to have the current title and prefix/suffix.</haxe_doc>
		</updateTitle>
		<endfix public="1" get="accessor" set="accessor" static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</endfix>
		<set_endfix get="inline" set="null" line="78" static="1">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_endfix>
		<get_endfix get="inline" set="null" line="81" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_endfix>
		<winTitle public="1" get="accessor" set="accessor" static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</winTitle>
		<get_winTitle get="inline" set="null" line="86" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_winTitle>
		<set_winTitle get="inline" set="null" line="89" static="1">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_winTitle>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.backend.utils.ErrorCode" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil">
		<this><x path="Int"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
		<impl><class path="funkin.backend.utils._XMLUtil.ErrorCode_Impl_" params="" file="source/funkin/backend/utils/XMLUtil.hx" private="1" module="funkin.backend.utils.XMLUtil" extern="1" final="1">
	<OK public="1" get="inline" set="null" expr="cast 0" line="22" static="1">
		<x path="funkin.backend.utils.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OK>
	<FAILED public="1" get="inline" set="null" expr="cast 1" line="23" static="1">
		<x path="funkin.backend.utils.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</FAILED>
	<MISSING_PROPERTY public="1" get="inline" set="null" expr="cast 2" line="24" static="1">
		<x path="funkin.backend.utils.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MISSING_PROPERTY>
	<TYPE_INCORRECT public="1" get="inline" set="null" expr="cast 3" line="25" static="1">
		<x path="funkin.backend.utils.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TYPE_INCORRECT>
	<VALUE_NULL public="1" get="inline" set="null" expr="cast 4" line="26" static="1">
		<x path="funkin.backend.utils.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VALUE_NULL>
	<REFLECT_ERROR public="1" get="inline" set="null" expr="cast 5" line="27" static="1">
		<x path="funkin.backend.utils.ErrorCode"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</REFLECT_ERROR>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.backend.utils._XMLUtil.ErrorCode_Impl_" params="" file="source/funkin/backend/utils/XMLUtil.hx" private="1" module="funkin.backend.utils.XMLUtil" extern="1" final="1">
		<OK public="1" get="inline" set="null" expr="cast 0" line="22" static="1">
			<x path="funkin.backend.utils.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OK>
		<FAILED public="1" get="inline" set="null" expr="cast 1" line="23" static="1">
			<x path="funkin.backend.utils.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</FAILED>
		<MISSING_PROPERTY public="1" get="inline" set="null" expr="cast 2" line="24" static="1">
			<x path="funkin.backend.utils.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MISSING_PROPERTY>
		<TYPE_INCORRECT public="1" get="inline" set="null" expr="cast 3" line="25" static="1">
			<x path="funkin.backend.utils.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TYPE_INCORRECT>
		<VALUE_NULL public="1" get="inline" set="null" expr="cast 4" line="26" static="1">
			<x path="funkin.backend.utils.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VALUE_NULL>
		<REFLECT_ERROR public="1" get="inline" set="null" expr="cast 5" line="27" static="1">
			<x path="funkin.backend.utils.ErrorCode"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</REFLECT_ERROR>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="funkin.backend.utils.TextFormat" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil">
		<a>
			<text><c path="String"/></text>
			<format><d/></format>
		</a>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<class path="funkin.backend.utils.XMLUtil" params="" file="source/funkin/backend/utils/XMLUtil.hx" final="1">
		<applyXMLProperty public="1" set="method" line="68" static="1">
			<f a="object:property">
				<d/>
				<x path="haxe.xml.Access"/>
				<x path="funkin.backend.utils.ErrorCode"/>
			</f>
			<haxe_doc>* Applies a property XML node to an object.
	 * The format for the XML is as follows:
	 * ```xml
	 * &lt;!-- float --&gt;
	 * &lt;property name="name" type="float" value="value" /&gt;
	 * &lt;property name="name" type="number" value="value" /&gt;
	 * &lt;property name="name" type="f" value="value" /&gt;
	 * &lt;!-- string --&gt;
	 * &lt;property name="name" type="string" value="value" /&gt;
	 * &lt;property name="name" type="str" value="value" /&gt;
	 * &lt;property name="name" type="text" value="value" /&gt;
	 * &lt;property name="name" type="s" value="value" /&gt;
	 * &lt;!-- int --&gt;
	 * &lt;property name="name" type="int" value="value" /&gt;
	 * &lt;property name="name" type="integer" value="value" /&gt;
	 * &lt;property name="name" type="i" value="value" /&gt;
	 * &lt;!-- bool --&gt;
	 * &lt;property name="name" type="bool" value="value" /&gt;
	 * &lt;property name="name" type="boolean" value="value" /&gt;
	 * &lt;property name="name" type="b" value="value" /&gt;
	 * &lt;!-- color --&gt;
	 * &lt;property name="name" type="color" value="value" /&gt;
	 * &lt;property name="name" type="c" value="value" /&gt;
	 * ```
	 *
	 * @param object Object to which the xml property will be applied
	 * @param property `property` node.
	 * @return Error code (0 = OK, 1 = FAILED, 2 = MISSING_PROPERTY, 3 = TYPE_INCORRECT, 4 = VALUE_NULL, 5 = REFLECT_ERROR)</haxe_doc>
		</applyXMLProperty>
		<loadSpriteFromXML public="1" set="method" line="117" static="1">
			<f a="spr:node:?parentFolder:?defaultAnimType:?loadGraphic" v="::&quot;&quot;:BEAT:true">
				<c path="funkin.backend.FunkinSprite"/>
				<x path="haxe.xml.Access"/>
				<c path="String"/>
				<x path="funkin.backend.XMLAnimType"/>
				<x path="Bool"/>
				<c path="funkin.backend.FunkinSprite"/>
			</f>
			<meta><m n=":value"><e>{ loadGraphic : true, defaultAnimType : BEAT, parentFolder : "" }</e></m></meta>
			<haxe_doc>* Sets the properties of a sprite based on a XML node.
	 * @param spr The sprite
	 * @param node The XML node
	 * @param parentFolder The parent folder
	 * @param defaultAnimType The default animation type</haxe_doc>
		</loadSpriteFromXML>
		<createSpriteFromXML public="1" get="inline" set="null" line="243" static="1">
			<f a="node:?parentFolder:?defaultAnimType:?cl:?args:?loadGraphic" v=":&quot;&quot;:BEAT:::true">
				<x path="haxe.xml.Access"/>
				<c path="String"/>
				<x path="funkin.backend.XMLAnimType"/>
				<x path="Class"><c path="funkin.backend.FunkinSprite"/></x>
				<c path="Array"><d/></c>
				<x path="Bool"/>
				<c path="funkin.backend.FunkinSprite"/>
			</f>
			<meta><m n=":value"><e>{ loadGraphic : true, defaultAnimType : BEAT, parentFolder : "" }</e></m></meta>
			<haxe_doc>* Creates a new sprite based on a XML node.
	 * @param node The XML node
	 * @param parentFolder The parent folder
	 * @param defaultAnimType The default animation type
	 * @param cl The class to create (advanced)
	 * @param args The arguments to pass to the class (advanced)</haxe_doc>
		</createSpriteFromXML>
		<extractAnimFromXML public="1" set="method" line="255" static="1">
			<f a="anim:?animType:?loop" v=":NONE:false">
				<x path="haxe.xml.Access"/>
				<x path="funkin.backend.XMLAnimType"/>
				<x path="Bool"/>
				<t path="funkin.backend.utils.AnimData"/>
			</f>
			<meta><m n=":value"><e>{ loop : false, animType : NONE }</e></m></meta>
			<haxe_doc>* Extracts an animation from an XML node.
	 * @param anim The animation node
	 * @param animType The animation type
	 * @param loop Whether the animation should loop</haxe_doc>
		</extractAnimFromXML>
		<addXMLAnimation public="1" set="method" line="284" static="1">
			<f a="sprite:anim:?loop" v="::false">
				<c path="flixel.FlxSprite"/>
				<x path="haxe.xml.Access"/>
				<x path="Bool"/>
				<x path="funkin.backend.utils.ErrorCode"/>
			</f>
			<meta><m n=":value"><e>{ loop : false }</e></m></meta>
			<haxe_doc>* Adds an XML animation to `sprite`.
	 * @param sprite Destination sprite
	 * @param anim Animation (Must be a `anim` XML node)</haxe_doc>
		</addXMLAnimation>
		<addAnimToSprite public="1" set="method" line="298" static="1">
			<f a="sprite:animData">
				<c path="flixel.FlxSprite"/>
				<t path="funkin.backend.utils.AnimData"/>
				<x path="funkin.backend.utils.ErrorCode"/>
			</f>
			<haxe_doc>* Adds an animation to a sprite.
	 * @param sprite The sprite
	 * @param animData The animation data (gotten from `extractAnimFromXML`)</haxe_doc>
		</addAnimToSprite>
		<defaultForcedCheck public="1" get="inline" set="null" line="346" static="1"><f a="animName:sprite">
	<c path="String"/>
	<c path="funkin.backend.FunkinSprite"/>
	<x path="Bool"/>
</f></defaultForcedCheck>
		<fixXMLText public="1" get="inline" set="null" line="348" static="1"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></fixXMLText>
		<fixSpacingInNode public="1" set="method" line="358" static="1">
			<f a="node">
				<x path="haxe.xml.Access"/>
				<x path="haxe.xml.Access"/>
			</f>
			<haxe_doc>* Trims and removes spacing from the nodeValue in the XML
	 *
	 * WARNING: will edit directly the node!</haxe_doc>
		</fixSpacingInNode>
		<getTextFormats public="1" set="method" line="384" static="1">
			<f a="_node:?currentFormat:?parsedSegments" v=":null:null">
				<x path="flixel.util.typeLimit.OneOfTwo">
					<c path="Xml"/>
					<x path="haxe.xml.Access"/>
				</x>
				<d/>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
			</f>
			<meta><m n=":value"><e>{ parsedSegments : null, currentFormat : null }</e></m></meta>
			<haxe_doc>* Gets the text formats from an XML node.
	 * The format for the XML is as follows:
	 * ```xml
	 * &lt;text&gt;Hello &lt;format color="#FF0000"&gt;World&lt;/format&gt;&lt;/text&gt;
	 * ```
	 *
	 * @param _node The XML node
	 * @param currentFormat The current format
	 * @param parsedSegments The parsed segments</haxe_doc>
		</getTextFormats>
		<haxe_doc>* Class made to make XML parsing easier.
 * Used in Stage.hx, Character.hx, and more.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.XMLImportedScriptInfo" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil">
		<prepareInfos public="1" set="method" line="427" static="1"><f a="node:parentScriptPack:?onScriptPreLoad">
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.scripting.ScriptPack"/>
	<f a="">
		<c path="funkin.backend.utils.XMLImportedScriptInfo"/>
		<x path="Void"/>
	</f>
	<c path="funkin.backend.utils.XMLImportedScriptInfo"/>
</f></prepareInfos>
		<shouldLoadBefore public="1" get="inline" set="null" line="454" static="1">
			<f a="node">
				<x path="haxe.xml.Access"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</shouldLoadBefore>
		<path public="1"><c path="String"/></path>
		<shortLived public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</shortLived>
		<loadBefore public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</loadBefore>
		<importStageSprites public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</importStageSprites>
		<parentScriptPack public="1" expr="null">
			<c path="funkin.backend.scripting.ScriptPack"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</parentScriptPack>
		<getScript public="1" set="method" line="425"><f a=""><c path="funkin.backend.scripting.Script"/></f></getScript>
		<new public="1" set="method" line="419"><f a="path:parentScriptPack">
	<c path="String"/>
	<c path="funkin.backend.scripting.ScriptPack"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.utils.AnimData" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<name><c path="String"/></name>
	<loop><x path="Bool"/></loop>
	<indices><c path="Array"><x path="Int"/></c></indices>
	<fps><x path="Float"/></fps>
	<forced>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</forced>
	<animType><x path="funkin.backend.XMLAnimType"/></animType>
	<anim><c path="String"/></anim>
</a></typedef>
	<typedef path="funkin.backend.utils.BeatAnim" params="" file="source/funkin/backend/utils/XMLUtil.hx" module="funkin.backend.utils.XMLUtil"><a>
	<name><c path="String"/></name>
	<forced><x path="Bool"/></forced>
</a></typedef>
	<class path="funkin.backend.utils.ZipUtil" params="" file="source/funkin/backend/utils/ZipUtil.hx" final="1">
		<bannedNames public="1" expr="[&quot;.git&quot;, &quot;.gitignore&quot;, &quot;.github&quot;, &quot;.vscode&quot;, &quot;.gitattributes&quot;, &quot;readme.txt&quot;]" line="28" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[".git", ".gitignore", ".github", ".vscode", ".gitattributes", "readme.txt"]</e></m></meta>
		</bannedNames>
		<uncompressZip public="1" set="method" line="35" static="1">
			<f a="zip:destFolder:?prefix:?prog">
				<c path="haxe.zip.Reader"/>
				<c path="String"/>
				<c path="String"/>
				<c path="funkin.backend.utils.ZipProgress"/>
				<c path="funkin.backend.utils.ZipProgress"/>
			</f>
			<haxe_doc>* [Description] Decompresses a `zip` into the `destFolder` folder
	 * @param zip
	 * @param destFolder</haxe_doc>
		</uncompressZip>
		<uncompressZipAsync public="1" set="method" line="79" static="1"><f a="zip:destFolder:?prog:?prefix">
	<c path="haxe.zip.Reader"/>
	<c path="String"/>
	<c path="funkin.backend.utils.ZipProgress"/>
	<c path="String"/>
	<c path="funkin.backend.utils.ZipProgress"/>
</f></uncompressZipAsync>
		<openZip public="1" set="method" line="94" static="1">
			<f a="zipPath">
				<c path="String"/>
				<c path="haxe.zip.Reader"/>
			</f>
			<haxe_doc>* [Description] Returns a `zip.Reader` instance from path.
	 * @param zipPath
	 * @return Reader</haxe_doc>
		</openZip>
		<unzip public="1" set="method" line="102" static="1">
			<f a="f">
				<t path="haxe.zip.Entry"/>
				<x path="Null"><c path="haxe.io.Bytes"/></x>
			</f>
			<haxe_doc>* [Description] Copy of haxe's Zip unzip function cause lime replaced it.
	 * @param f Zip entry</haxe_doc>
		</unzip>
		<createZipFile public="1" set="method" line="122" static="1">
			<f a="path">
				<c path="String"/>
				<c path="funkin.backend.utils.ZipWriter"/>
			</f>
			<haxe_doc>* [Description] Creates a ZIP file at the specified location and returns the Writer.
	 * @param path
	 * @return Writer</haxe_doc>
		</createZipFile>
		<writeFolderToZip public="1" set="method" line="133" static="1">
			<f a="zip:path:?prefix:?prog:?whitelist">
				<c path="funkin.backend.utils.ZipWriter"/>
				<c path="String"/>
				<c path="String"/>
				<c path="funkin.backend.utils.ZipProgress"/>
				<c path="Array"><c path="String"/></c>
				<c path="funkin.backend.utils.ZipProgress"/>
			</f>
			<haxe_doc>[Description] Writes the entirety of a folder to a zip file.
		@param zip ZIP file to write to
		@param path Folder path
		@param prefix (Additional) allows you to set a prefix in the zip itself.</haxe_doc>
		</writeFolderToZip>
		<writeFolderToZipAsync public="1" set="method" line="196" static="1"><f a="zip:path:?prefix">
	<c path="funkin.backend.utils.ZipWriter"/>
	<c path="String"/>
	<c path="String"/>
	<c path="funkin.backend.utils.ZipProgress"/>
</f></writeFolderToZipAsync>
		<arrayToList public="1" set="method" line="209" static="1">
			<f a="array">
				<c path="Array"><t path="haxe.zip.Entry"/></c>
				<t path="List"><t path="haxe.zip.Entry"/></t>
			</f>
			<haxe_doc>* [Description] Converts an `Array&lt;Entry&gt;` to a `List&lt;Entry&gt;`.
	 * @param array
	 * @return List&lt;Entry&gt;</haxe_doc>
		</arrayToList>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.ZipProgress" params="" file="source/funkin/backend/utils/ZipUtil.hx" module="funkin.backend.utils.ZipUtil">
		<error public="1" expr="null">
			<c path="haxe.Exception"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</error>
		<curFile public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curFile>
		<fileCount public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</fileCount>
		<done public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</done>
		<percentage public="1" get="accessor" set="null"><x path="Float"/></percentage>
		<get_percentage set="method" line="224"><f a=""><x path="Float"/></f></get_percentage>
		<new public="1" set="method" line="228"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.ZipWriter" params="" file="source/funkin/backend/utils/ZipUtil.hx" module="funkin.backend.utils.ZipUtil">
		<extends path="haxe.zip.Writer"/>
		<flush public="1" set="method" line="232"><f a=""><x path="Void"/></f></flush>
		<writeFile public="1" set="method" line="236"><f a="entry">
	<t path="haxe.zip.Entry"/>
	<x path="Void"/>
</f></writeFile>
		<close public="1" set="method" line="241"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="231"><f a="o">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.StrNameLabel" params="" file="source/funkin/backend/utils/ZipUtil.hx" module="funkin.backend.utils.ZipUtil">
		<name public="1"><c path="String"/></name>
		<label public="1"><c path="String"/></label>
		<new public="1" set="method" line="250"><f a="name:label">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.ZipReader" params="" file="source/funkin/backend/utils/ZipUtil.hx" module="funkin.backend.utils.ZipUtil">
		<extends path="haxe.zip.Reader"/>
		<files public="1"><t path="List"><t path="haxe.zip.Entry"/></t></files>
		<read public="1" set="method" line="260" override="1"><f a=""><t path="List"><t path="haxe.zip.Entry"/></t></f></read>
		<new public="1" set="method" line="257"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.native.Stdin" params="" file="source/funkin/backend/utils/native/HiddenProcess.hx" module="funkin.backend.utils.native.HiddenProcess">
		<extends path="haxe.io.Output"/>
		<p><d/></p>
		<buf><c path="haxe.io.Bytes"/></buf>
		<close public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></close>
		<writeByte public="1" set="method" line="42" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="47" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<new public="1" set="method" line="32"><f a="p">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.native.Stdout" params="" file="source/funkin/backend/utils/native/HiddenProcess.hx" module="funkin.backend.utils.native.HiddenProcess">
		<extends path="haxe.io.Input"/>
		<p><d/></p>
		<out><x path="Bool"/></out>
		<buf><c path="haxe.io.Bytes"/></buf>
		<readByte public="1" set="method" line="68" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="74" override="1"><f a="str:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="62"><f a="p:out">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.native.HiddenProcess" params="" file="source/funkin/backend/utils/native/HiddenProcess.hx">
		<p><d/></p>
		<stdout public="1" set="null"><c path="haxe.io.Input"/></stdout>
		<stderr public="1" set="null"><c path="haxe.io.Input"/></stderr>
		<stdin public="1" set="null"><c path="haxe.io.Output"/></stdin>
		<getPid public="1" set="method" line="103"><f a=""><x path="Int"/></f></getPid>
		<exitCode public="1" set="method" line="107">
			<f a="?block" v="true">
				<x path="Bool"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":value"><e>{ block : true }</e></m></meta>
		</exitCode>
		<close public="1" set="method" line="111"><f a=""><x path="Void"/></f></close>
		<kill public="1" set="method" line="115"><f a=""><x path="Void"/></f></kill>
		<new public="1" set="method" line="94"><f a="cmd:?args:?detached">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.native.Windows" params="" file="source/funkin/backend/utils/native/Windows.hx" final="1">
		<__audioChangeCallback public="1" expr="function() {  trace(&quot;test&quot;); }" line="119" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>function() {
	trace("test");
}</e></m></meta>
		</__audioChangeCallback>
		<registerAudio public="1" set="method" line="127" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\tif (!curAudioFix) curAudioFix = new AudioFixClient();\r\n\t"</e></m></meta>
		</registerAudio>
		<setDarkMode public="1" set="method" line="146" static="1">
			<f a="title:enable">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tint darkMode = enable ? 1 : 0;\r\n\r\n\t\tHWND window = FindWindowA(NULL, title.c_str());\r\n\t\t// Look for child windows if top level is not found\r\n\t\tif (window == NULL) window = FindWindowExA(GetActiveWindow(), NULL, NULL, title.c_str());\r\n\t\t// If still not found, try to get the active window\r\n\t\tif (window == NULL) window = GetActiveWindow();\r\n\t\tif (window == NULL) return;\r\n\r\n\t\tif (S_OK != DwmSetWindowAttribute(window, 19, &amp;darkMode, sizeof(darkMode))) {\r\n\t\t\tDwmSetWindowAttribute(window, 20, &amp;darkMode, sizeof(darkMode));\r\n\t\t}\r\n\t\tUpdateWindow(window);\r\n\t"</e></m></meta>
		</setDarkMode>
		<setWindowBorderColor public="1" set="method" line="168" static="1">
			<f a="title:color:?setHeader:?setBorder" v="::true:true">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ setBorder : true, setHeader : true }</e></m>
				<m n=":functionCode"><e>"\r\n\tHWND window = FindWindowA(NULL, title.c_str());\r\n\tif (window == NULL) window = FindWindowExA(GetActiveWindow(), NULL, NULL, title.c_str());\r\n\tif (window == NULL) window = GetActiveWindow();\r\n\tif (window == NULL) return;\r\n\r\n\tCOLORREF finalColor;\r\n\tif(color[0] == -1 &amp;&amp; color[1] == -1 &amp;&amp; color[2] == -1 &amp;&amp; color[3] == -1) { // bad fix, I know :sob:\r\n\t\tfinalColor = 0xFFFFFFFF; // Default border\r\n\t} else if(color[3] == 0) {\r\n\t\tfinalColor = 0xFFFFFFFE; // No border (must have setBorder as true)\r\n\t} else {\r\n\t\tfinalColor = RGB(color[0], color[1], color[2]); // Use your custom color\r\n\t}\r\n\r\n\tif(setHeader) DwmSetWindowAttribute(window, 35, &amp;finalColor, sizeof(COLORREF));\r\n\tif(setBorder) DwmSetWindowAttribute(window, 34, &amp;finalColor, sizeof(COLORREF));\r\n\r\n\tUpdateWindow(window);\r\n\t"</e></m>
			</meta>
		</setWindowBorderColor>
		<setWindowTitleColor public="1" set="method" line="186" static="1">
			<f a="title:color">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\tHWND window = FindWindowA(NULL, title.c_str());\r\n\tif (window == NULL) window = FindWindowExA(GetActiveWindow(), NULL, NULL, title.c_str());\r\n\tif (window == NULL) window = GetActiveWindow();\r\n\tif (window == NULL) return;\r\n\r\n\tCOLORREF finalColor;\r\n\tif(color[0] == -1 &amp;&amp; color[1] == -1 &amp;&amp; color[2] == -1 &amp;&amp; color[3] == -1) { // bad fix, I know :sob:\r\n\t\tfinalColor = 0xFFFFFFFF; // Default border\r\n\t} else {\r\n\t\tfinalColor = RGB(color[0], color[1], color[2]); // Use your custom color\r\n\t}\r\n\r\n\tDwmSetWindowAttribute(window, 36, &amp;finalColor, sizeof(COLORREF));\r\n\tUpdateWindow(window);\r\n\t"</e></m></meta>
		</setWindowTitleColor>
		<allocConsole public="1" set="method" line="198" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t// https://stackoverflow.com/questions/15543571/allocconsole-not-displaying-cout\r\n\r\n\tif (!AllocConsole())\r\n\t\treturn;\r\n\r\n\tfreopen(\"CONIN$\", \"r\", stdin);\r\n\tfreopen(\"CONOUT$\", \"w\", stdout);\r\n\tfreopen(\"CONOUT$\", \"w\", stderr);\r\n\t"</e></m></meta>
		</allocConsole>
		<getFileAttributes public="1" set="method" line="205" static="1">
			<f a="path">
				<c path="String"/>
				<x path="funkin.backend.utils.FileAttribute"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\treturn GetFileAttributes(path);\r\n\t"</e></m></meta>
		</getFileAttributes>
		<setFileAttributes public="1" set="method" line="213" static="1">
			<f a="path:attrib">
				<c path="String"/>
				<x path="funkin.backend.utils.FileAttribute"/>
				<x path="Int"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\treturn SetFileAttributes(path, attrib);\r\n\t"</e></m></meta>
		</setFileAttributes>
		<setConsoleColors public="1" set="method" line="222" static="1">
			<f a="color">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":functionCode"><e>"\r\n\t\tHANDLE console = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\t\tSetConsoleTextAttribute(console, color);\r\n\t"</e></m></meta>
		</setConsoleColors>
		<clearScreen public="1" set="method" line="230" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\tsystem(\"CLS\");\r\n\t\tstd::cout&lt;&lt; \"\" &lt;&lt;std::flush;\r\n\t"</e></m></meta>
		</clearScreen>
		<showMessageBox public="1" set="method" line="238" static="1">
			<f a="caption:message:?icon" v="::MSG_WARNING">
				<c path="String"/>
				<c path="String"/>
				<x path="funkin.backend.utils.MessageBoxIcon"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ icon : MSG_WARNING }</e></m>
				<m n=":functionCode"><e>"\r\n\t\tMessageBox(GetActiveWindow(), message, caption, icon | MB_SETFOREGROUND);\r\n\t"</e></m>
			</meta>
		</showMessageBox>
		<registerAsDPICompatible public="1" set="method" line="245" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\tSetProcessDPIAware();\r\n\t"</e></m></meta>
		</registerAsDPICompatible>
		<getTotalRam public="1" set="method" line="254" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":functionCode"><e>"\r\n\t\t// simple but effective code\r\n\t\tunsigned long long allocatedRAM = 0;\r\n\t\tGetPhysicallyInstalledSystemMemory(&amp;allocatedRAM);\r\n\t\treturn (allocatedRAM / 1024);\r\n\t"</e></m></meta>
		</getTotalRam>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e>"\r\n&lt;target id=\"haxe\"&gt;\r\n\t&lt;lib name=\"dwmapi.lib\" if=\"windows\" /&gt;\r\n\t&lt;lib name=\"shell32.lib\" if=\"windows\" /&gt;\r\n\t&lt;lib name=\"gdi32.lib\" if=\"windows\" /&gt;\r\n\t&lt;lib name=\"ole32.lib\" if=\"windows\" /&gt;\r\n\t&lt;lib name=\"uxtheme.lib\" if=\"windows\" /&gt;\r\n&lt;/target&gt;\r\n"</e></m>
			<m n=":cppFileCode"><e>"\r\n#include \"mmdeviceapi.h\"\r\n#include \"combaseapi.h\"\r\n#include &lt;iostream&gt;\r\n#include &lt;Windows.h&gt;\r\n#include &lt;cstdio&gt;\r\n#include &lt;tchar.h&gt;\r\n#include &lt;dwmapi.h&gt;\r\n#include &lt;winuser.h&gt;\r\n#include &lt;Shlobj.h&gt;\r\n#include &lt;wingdi.h&gt;\r\n#include &lt;shellapi.h&gt;\r\n#include &lt;uxtheme.h&gt;\r\n\r\n#define SAFE_RELEASE(punk)  \\\r\n\t\t\t  if ((punk) != NULL)  \\\r\n\t\t\t\t{ (punk)-&gt;Release(); (punk) = NULL; }\r\n\r\nstatic long lastDefId = 0;\r\n\r\nclass AudioFixClient : public IMMNotificationClient {\r\n\tLONG _cRef;\r\n\tIMMDeviceEnumerator *_pEnumerator;\r\n\r\n\tpublic:\r\n\tAudioFixClient() :\r\n\t\t_cRef(1),\r\n\t\t_pEnumerator(NULL)\r\n\t{\r\n\t\tHRESULT result = CoCreateInstance(__uuidof(MMDeviceEnumerator),\r\n\t\t\t\t\t\t\t  NULL, CLSCTX_INPROC_SERVER,\r\n\t\t\t\t\t\t\t  __uuidof(IMMDeviceEnumerator),\r\n\t\t\t\t\t\t\t  (void**)&amp;_pEnumerator);\r\n\t\tif (result == S_OK) {\r\n\t\t\t_pEnumerator-&gt;RegisterEndpointNotificationCallback(this);\r\n\t\t}\r\n\t}\r\n\r\n\t~AudioFixClient()\r\n\t{\r\n\t\tSAFE_RELEASE(_pEnumerator);\r\n\t}\r\n\r\n\tULONG STDMETHODCALLTYPE AddRef()\r\n\t{\r\n\t\treturn InterlockedIncrement(&amp;_cRef);\r\n\t}\r\n\r\n\tULONG STDMETHODCALLTYPE Release()\r\n\t{\r\n\t\tULONG ulRef = InterlockedDecrement(&amp;_cRef);\r\n\t\tif (0 == ulRef)\r\n\t\t{\r\n\t\t\tdelete this;\r\n\t\t}\r\n\t\treturn ulRef;\r\n\t}\r\n\r\n\tHRESULT STDMETHODCALLTYPE QueryInterface(\r\n\t\t\t\t\t\t\t\tREFIID riid, VOID **ppvInterface)\r\n\t{\r\n\t\treturn S_OK;\r\n\t}\r\n\r\n\tHRESULT STDMETHODCALLTYPE OnDeviceAdded(LPCWSTR pwstrDeviceId)\r\n\t{\r\n\t\treturn S_OK;\r\n\t};\r\n\r\n\tHRESULT STDMETHODCALLTYPE OnDeviceRemoved(LPCWSTR pwstrDeviceId)\r\n\t{\r\n\t\treturn S_OK;\r\n\t}\r\n\r\n\tHRESULT STDMETHODCALLTYPE OnDeviceStateChanged(\r\n\t\t\t\t\t\t\t\tLPCWSTR pwstrDeviceId,\r\n\t\t\t\t\t\t\t\tDWORD dwNewState)\r\n\t{\r\n\t\treturn S_OK;\r\n\t}\r\n\r\n\tHRESULT STDMETHODCALLTYPE OnPropertyValueChanged(\r\n\t\t\t\t\t\t\t\tLPCWSTR pwstrDeviceId,\r\n\t\t\t\t\t\t\t\tconst PROPERTYKEY key)\r\n\t{\r\n\t\treturn S_OK;\r\n\t}\r\n\r\n\tHRESULT STDMETHODCALLTYPE OnDefaultDeviceChanged(\r\n\t\tEDataFlow flow, ERole role,\r\n\t\tLPCWSTR pwstrDeviceId)\r\n\t{\r\n\t\t::funkin::backend::_hx_system::Main_obj::audioDisconnected = true;\r\n\t\treturn S_OK;\r\n\t};\r\n};\r\n\r\nAudioFixClient *curAudioFix;\r\n"</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="funkin.backend.utils.translations.FormatUtil" params="" file="source/funkin/backend/utils/translations/FormatUtil.hx" final="1">
		<cache expr="new Map()" line="9" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.backend.utils.translations.IFormatInfo"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</cache>
		<cacheStr expr="new Map()" line="10" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.backend.utils.translations.IFormatInfo"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</cacheStr>
		<get public="1" set="method" line="12" static="1"><f a="id">
	<c path="String"/>
	<c path="funkin.backend.utils.translations.IFormatInfo"/>
</f></get>
		<getStr public="1" set="method" line="22" static="1"><f a="id">
	<c path="String"/>
	<c path="funkin.backend.utils.translations.IFormatInfo"/>
</f></getStr>
		<clear public="1" get="inline" set="null" line="31" static="1"><f a=""><x path="Void"/></f></clear>
		<haxe_doc>* The class used to format strings based on parameters.
 *
 * For example if the parameter list is just an `Int` which is `9`, `You have been blue balled {0} times` becomes `You have been blue balled 9 times`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.translations.IFormatInfo" params="" file="source/funkin/backend/utils/translations/FormatUtil.hx" module="funkin.backend.utils.translations.FormatUtil" interface="1"><format public="1" set="method"><f a="params">
	<c path="Array"><d/></c>
	<c path="String"/>
</f></format></class>
	<class path="funkin.backend.utils.translations.StrFormatInfo" params="" file="source/funkin/backend/utils/translations/FormatUtil.hx" module="funkin.backend.utils.translations.FormatUtil">
		<implements path="funkin.backend.utils.translations.IFormatInfo"/>
		<string public="1"><c path="String"/></string>
		<format public="1" set="method" line="44"><f a="params">
	<c path="Array"><d/></c>
	<c path="String"/>
</f></format>
		<toString public="1" set="method" line="48"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="40"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.utils.translations.ParamFormatInfo" params="" file="source/funkin/backend/utils/translations/FormatUtil.hx" module="funkin.backend.utils.translations.FormatUtil">
		<implements path="funkin.backend.utils.translations.IFormatInfo"/>
		<isValid public="1" set="method" line="78" static="1"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></isValid>
		<returnOnlyIfValid public="1" set="method" line="82" static="1"><f a="str">
	<c path="String"/>
	<c path="funkin.backend.utils.translations.IFormatInfo"/>
</f></returnOnlyIfValid>
		<strings public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</strings>
		<indexes public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</indexes>
		<format public="1" set="method" line="87"><f a="params">
	<c path="Array"><d/></c>
	<c path="String"/>
</f></format>
		<toString public="1" set="method" line="103"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="58"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.backend.week.Week" params="" file="source/funkin/backend/week/Week.hx">
		<loadWeek public="1" set="method" line="10" static="1">
			<f a="weekName:?loadCharactersData" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<t path="funkin.backend.week.WeekData"/>
			</f>
			<meta><m n=":value"><e>{ loadCharactersData : true }</e></m></meta>
		</loadWeek>
		<loadWeekCharacter public="1" set="method" line="71" static="1"><f a="charName">
	<c path="String"/>
	<t path="funkin.backend.week.WeekCharacter"/>
</f></loadWeekCharacter>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.backend.week.WeekData" params="" file="source/funkin/backend/week/WeekData.hx"><a>
	<xml>
		<x path="Null"><x path="haxe.xml.Access"/></x>
		<meta><m n=":optional"/></meta>
	</xml>
	<sprite><c path="String"/></sprite>
	<songs><c path="Array"><t path="funkin.backend.week.WeekSong"/></c></songs>
	<name><c path="String"/></name>
	<id><c path="String"/></id>
	<difficulties><c path="Array"><c path="String"/></c></difficulties>
	<chars><c path="Array"><t path="funkin.backend.week.WeekCharacter"/></c></chars>
	<bgColor><x path="flixel.util.FlxColor"/></bgColor>
</a></typedef>
	<typedef path="funkin.backend.week.WeekCharacter" params="" file="source/funkin/backend/week/WeekData.hx" module="funkin.backend.week.WeekData"><a>
	<xml>
		<x path="Null"><x path="haxe.xml.Access"/></x>
		<meta><m n=":optional"/></meta>
	</xml>
	<spritePath>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</spritePath>
	<scale>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</scale>
	<offset>
		<x path="Null"><x path="flixel.math.FlxPoint"/></x>
		<meta><m n=":optional"/></meta>
	</offset>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="funkin.backend.week.WeekSong" params="" file="source/funkin/backend/week/WeekData.hx" module="funkin.backend.week.WeekData"><a>
	<name><c path="String"/></name>
	<hide><x path="Bool"/></hide>
	<displayName>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</displayName>
</a></typedef>
	<class path="funkin.editors.EditorPicker" params="" file="source/funkin/editors/EditorPicker.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<bg public="1"><c path="flixel.FlxSprite"/></bg>
		<options public="1" expr="[{ name : &quot;Chart Editor&quot;, id : &quot;chart&quot;, state : funkin.editors.charter.CharterSelection }, { name : &quot;Character Editor&quot;, id : &quot;character&quot;, state : funkin.editors.character.CharacterSelection }, { name : &quot;Stage Editor&quot;, id : &quot;stage&quot;, state : funkin.editors.stage.StageSelection }, { name : &quot;Alphabet Editor&quot;, id : &quot;alphabet&quot;, state : funkin.editors.alphabet.AlphabetSelection }, { name : &quot;Wiki&quot;, id : &quot;wiki&quot;, state : null, onClick : function() {  CoolUtil.openURL(Flags.URL_WIKI); } }]">
			<c path="Array"><t path="funkin.editors.Editor"/></c>
			<meta><m n=":value"><e>[{ name : "Chart Editor", id : "chart", state : funkin.editors.charter.CharterSelection }, { name : "Character Editor", id : "character", state : funkin.editors.character.CharacterSelection }, { name : "Stage Editor", id : "stage", state : funkin.editors.stage.StageSelection }, { name : "Alphabet Editor", id : "alphabet", state : funkin.editors.alphabet.AlphabetSelection }, { name : "Wiki", id : "wiki", state : null, onClick : function() {
	CoolUtil.openURL(Flags.URL_WIKI);
} }]</e></m></meta>
		</options>
		<sprites public="1" expr="[]">
			<c path="Array"><c path="funkin.editors.EditorPickerOption"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sprites>
		<curSelected public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<subCam public="1"><c path="flixel.FlxCamera"/></subCam>
		<oldMousePos public="1" expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</oldMousePos>
		<curMousePos public="1" expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</curMousePos>
		<optionHeight public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</optionHeight>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<camVelocity public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</camVelocity>
		<create public="1" set="method" line="62" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="89" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="137" override="1"><f a=""><x path="Void"/></f></destroy>
		<changeSelection public="1" set="method" line="147"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<new public="1" set="method" line="6"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.Editor" params="" file="source/funkin/editors/EditorPicker.hx" module="funkin.editors.EditorPicker"><a>
	<state><x path="Class"><c path="funkin.backend.MusicBeatState"/></x></state>
	<onClick>
		<x path="Null"><f a=""><x path="Void"/></f></x>
		<meta><m n=":optional"/></meta>
	</onClick>
	<name><c path="String"/></name>
	<id><c path="String"/></id>
</a></typedef>
	<class path="funkin.editors.EditorPickerOption" params="" file="source/funkin/editors/EditorPicker.hx" module="funkin.editors.EditorPicker">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<iconSpr public="1"><c path="flixel.FlxSprite"/></iconSpr>
		<label public="1"><c path="funkin.menus.ui.Alphabet"/></label>
		<selectionBG public="1"><c path="flixel.FlxSprite"/></selectionBG>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<selectionLerp public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</selectionLerp>
		<iconRotationCycle public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</iconRotationCycle>
		<update public="1" set="method" line="203" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="220" override="1"><f a=""><x path="Void"/></f></destroy>
		<flicker public="1" set="method" line="224"><f a="callback">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></flicker>
		<new public="1" set="method" line="176"><f a="name:iconID:height">
	<c path="String"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIScaleMode" params="" file="source/funkin/editors/ui/UIScaleMode.hx">
		<extends path="flixel.system.scaleModes.StageSizeScaleMode"/>
		<onMeasure public="1" set="method" line="6" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMeasure>
		<updateGameSize set="method" line="28" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateGameSize>
		<new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIState" params="" file="source/funkin/editors/ui/UIState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<state public="1" get="accessor" set="null" static="1"><c path="funkin.editors.ui.UIState"/></state>
		<get_state get="inline" set="null" line="23" static="1"><f a=""><c path="funkin.editors.ui.UIState"/></f></get_state>
		<__point expr="new FlxPoint()" line="36" static="1">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</__point>
		<resolutionAware public="1" expr="false" line="187" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</resolutionAware>
		<uiScaleMode public="1" expr="new UIScaleMode()" line="188" static="1">
			<c path="funkin.editors.ui.UIScaleMode"/>
			<meta><m n=":value"><e>new UIScaleMode()</e></m></meta>
		</uiScaleMode>
		<setResolutionAware public="1" set="method" line="190" static="1"><f a=""><x path="Void"/></f></setResolutionAware>
		<curContextMenu public="1" expr="null">
			<c path="funkin.editors.ui.UIContextMenu"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curContextMenu>
		<buttonHandler public="1" expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</buttonHandler>
		<hoveredSprite public="1" expr="null">
			<c path="funkin.editors.ui.UISprite"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</hoveredSprite>
		<currentFocus public="1" expr="null">
			<c path="funkin.editors.ui.IUIFocusable"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</currentFocus>
		<currentCursor public="1" expr="ARROW">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta><m n=":value"><e>ARROW</e></m></meta>
		</currentCursor>
		<uiCameras public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</uiCameras>
		<__rect><c path="flixel.math.FlxRect"/></__rect>
		<__mousePos><x path="flixel.math.FlxPoint"/></__mousePos>
		<create public="1" set="method" line="38" override="1"><f a=""><x path="Void"/></f></create>
		<onKeyDown set="method" line="51"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyDown>
		<onKeyUp set="method" line="56"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyUp>
		<onTextInput set="method" line="61"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></onTextInput>
		<onTextEdit set="method" line="65"><f a="str:start:end">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTextEdit>
		<updateButtonHandler public="1" set="method" line="70"><f a="spr:buttonHandler">
	<c path="funkin.editors.ui.UISprite"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></updateButtonHandler>
		<isOverlapping public="1" set="method" line="75"><f a="spr:rect">
	<c path="funkin.editors.ui.UISprite"/>
	<c path="flixel.math.FlxRect"/>
	<x path="Bool"/>
</f></isOverlapping>
		<updateRectButtonHandler public="1" set="method" line="90"><f a="spr:rect:buttonHandler">
	<c path="funkin.editors.ui.UISprite"/>
	<c path="flixel.math.FlxRect"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></updateRectButtonHandler>
		<tryUpdate public="1" set="method" line="98" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></tryUpdate>
		<destroy public="1" set="method" line="125" override="1"><f a=""><x path="Void"/></f></destroy>
		<closeCurrentContextMenu public="1" set="method" line="149"><f a=""><x path="Void"/></f></closeCurrentContextMenu>
		<openContextMenu public="1" set="method" line="157"><f a="options:?callback:?x:?y:?w">
	<c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c>
	<x path="Null"><t path="funkin.editors.ui.UIContextMenuCallback"/></x>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<c path="funkin.editors.ui.UIContextMenu"/>
</f></openContextMenu>
		<displayNotification public="1" set="method" line="170"><f a="notification">
	<c path="funkin.editors.ui.notifications.UIBaseNotification"/>
	<x path="Void"/>
</f></displayNotification>
		<new public="1" set="method" line="17"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.TreeMenu" params="" file="source/funkin/options/TreeMenu.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<onMenuClosed public="1" expr="new FlxTypedSignal()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.options.TreeMenuScreen"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
		</onMenuClosed>
		<onMenuChanged public="1" expr="new FlxTypedSignal()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.options.TreeMenuScreen"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal()</e></m></meta>
		</onMenuChanged>
		<tree public="1" set="null" expr="[]">
			<c path="Array"><c path="funkin.options.TreeMenuScreen"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</tree>
		<treeLength public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</treeLength>
		<previousMenus public="1" expr="[]">
			<c path="Array"><c path="funkin.options.TreeMenuScreen"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</previousMenus>
		<destroyMenus public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</destroyMenus>
		<exitCallback public="1"><f a="">
	<c path="funkin.options.TreeMenu"/>
	<x path="Void"/>
</f></exitCallback>
		<titleLabel public="1"><c path="funkin.backend.FunkinText"/></titleLabel>
		<descLabel public="1"><c path="funkin.backend.FunkinText"/></descLabel>
		<bgLabel public="1"><c path="flixel.FlxSprite"/></bgLabel>
		<menuChangeTween><c path="flixel.tweens.FlxTween"/></menuChangeTween>
		<__drawer><c path="funkin.options.TreeMenuDrawer"/></__drawer>
		<__treeCreated expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__treeCreated>
		<create public="1" set="method" line="49" override="1"><f a=""><x path="Void"/></f></create>
		<createPost public="1" set="method" line="64" override="1"><f a=""><x path="Void"/></f></createPost>
		<updateMenuPositions public="1" set="method" line="85">
			<f a="?fromIndex:?cameraScroll" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cameraScroll : false, fromIndex : 0 }</e></m></meta>
		</updateMenuPositions>
		<updateLabels public="1" set="method" line="101"><f a=""><x path="Void"/></f></updateLabels>
		<updateDesc public="1" set="method" line="111"><f a="?customText">
	<c path="String"/>
	<x path="Void"/>
</f></updateDesc>
		<addMenu public="1" set="method" line="125"><f a="menu">
	<c path="funkin.options.TreeMenuScreen"/>
	<c path="funkin.options.TreeMenuScreen"/>
</f></addMenu>
		<insertMenu public="1" set="method" line="146"><f a="position:menu">
	<x path="Int"/>
	<c path="funkin.options.TreeMenuScreen"/>
	<c path="funkin.options.TreeMenuScreen"/>
</f></insertMenu>
		<popMenu public="1" set="method" line="171"><f a=""><c path="funkin.options.TreeMenuScreen"/></f></popMenu>
		<removeMenu public="1" set="method" line="174"><f a="menu">
	<c path="funkin.options.TreeMenuScreen"/>
	<c path="funkin.options.TreeMenuScreen"/>
</f></removeMenu>
		<removeMenuPosition public="1" set="method" line="176"><f a="position">
	<x path="Int"/>
	<c path="funkin.options.TreeMenuScreen"/>
</f></removeMenuPosition>
		<menuChanged public="1" set="method" line="200"><f a=""><x path="Void"/></f></menuChanged>
		<update public="1" set="method" line="217" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="239" override="1"><f a=""><x path="Void"/></f></destroy>
		<onResize public="1" set="method" line="244" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<reloadStrings public="1" set="method" line="258"><f a=""><x path="Void"/></f></reloadStrings>
		<destroyPreviousMenus public="1" set="method" line="263"><f a=""><x path="Void"/></f></destroyPreviousMenus>
		<exit public="1" set="method" line="268"><f a=""><x path="Void"/></f></exit>
		<updateAll public="1" set="method" line="274"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateAll>
		<menuTransitionEase public="1" set="dynamic" line="278"><f a="e">
	<x path="Float"/>
	<x path="Float"/>
</f></menuTransitionEase>
		<new public="1" set="method" line="42">
			<f a="?exitCallback:?scriptsAllowed:?scriptName" v=":true:">
				<f a="">
					<c path="funkin.options.TreeMenu"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scriptsAllowed : true }</e></m></meta>
		</new>
	</class>
	<class path="funkin.editors.EditorTreeMenu" params="" file="source/funkin/editors/EditorTreeMenu.hx">
		<extends path="funkin.options.TreeMenu"/>
		<bg public="1"><c path="flixel.addons.display.FlxBackdrop"/></bg>
		<bgType public="1" expr="&quot;default&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"default"</e></m></meta>
		</bgType>
		<bgMovement public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</bgMovement>
		<create public="1" set="method" line="11" override="1"><f a=""><x path="Void"/></f></create>
		<createPost public="1" set="method" line="17" override="1"><f a=""><x path="Void"/></f></createPost>
		<setBackgroundRotation public="1" get="inline" set="null" line="25"><f a="rotation">
	<x path="Float"/>
	<x path="Void"/>
</f></setBackgroundRotation>
		<exit public="1" set="method" line="30" override="1"><f a=""><x path="Void"/></f></exit>
		<update public="1" set="method" line="34" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<menuChanged public="1" set="method" line="45" override="1"><f a=""><x path="Void"/></f></menuChanged>
		<new public="1" set="method" line="6"><f a="?exitCallback:?scriptsAllowed:?scriptName">
	<f a="">
		<c path="funkin.options.TreeMenu"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.options.TreeMenuScreen" params="" file="source/funkin/options/TreeMenuScreen.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<persistentUpdate public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</persistentUpdate>
		<persistentDraw public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</persistentDraw>
		<onClose public="1" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
		</onClose>
		<parent public="1"><c path="funkin.options.TreeMenu"/></parent>
		<transitioning public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transitioning>
		<inputEnabled public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</inputEnabled>
		<curSelected public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<name public="1"><c path="String"/></name>
		<desc public="1"><c path="String"/></desc>
		<prefix public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
			<haxe_doc>* The prefix to add to the translations ids.</haxe_doc>
		</prefix>
		<rawName set="accessor"><c path="String"/></rawName>
		<rawDesc set="accessor"><c path="String"/></rawDesc>
		<set_rawName set="method" line="33"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_rawName>
		<set_rawDesc set="method" line="39"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_rawDesc>
		<getNameID public="1" get="inline" set="null" line="45"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getNameID>
		<getDescID public="1" get="inline" set="null" line="46"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getDescID>
		<getID public="1" get="inline" set="null" line="47"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getID>
		<translate public="1" set="method" line="48"><f a="name:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<controls public="1" get="accessor" set="null"><c path="funkin.backend.system.Controls"/></controls>
		<get_controls get="inline" set="null" line="51"><f a=""><c path="funkin.backend.system.Controls"/></f></get_controls>
		<leftTurboControl expr="new TurboControls([Control.LEFT], 0.2, 1 / 48)">
			<c path="funkin.backend.TurboControls"/>
			<meta><m n=":value"><e>new TurboControls([Control.LEFT], 0.2, 1 / 48)</e></m></meta>
		</leftTurboControl>
		<rightTurboControl expr="new TurboControls([Control.RIGHT], 0.2, 1 / 48)">
			<c path="funkin.backend.TurboControls"/>
			<meta><m n=":value"><e>new TurboControls([Control.RIGHT], 0.2, 1 / 48)</e></m></meta>
		</rightTurboControl>
		<upTurboControl expr="new TurboControls([Control.UP])">
			<c path="funkin.backend.TurboControls"/>
			<meta><m n=":value"><e>new TurboControls([Control.UP])</e></m></meta>
		</upTurboControl>
		<downTurboControl expr="new TurboControls([Control.DOWN])">
			<c path="funkin.backend.TurboControls"/>
			<meta><m n=":value"><e>new TurboControls([Control.DOWN])</e></m></meta>
		</downTurboControl>
		<turboBasics><c path="Array"><c path="funkin.backend.TurboBasic"/></c></turboBasics>
		<curOption><c path="funkin.options.ITreeOption"/></curOption>
		<curFloatOption><c path="funkin.options.ITreeFloatOption"/></curFloatOption>
		<__firstFrame expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__firstFrame>
		<reloadStrings public="1" set="method" line="74"><f a=""><x path="Void"/></f></reloadStrings>
		<update public="1" set="method" line="81" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateItems public="1" set="method" line="126">
			<f a="?force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</updateItems>
		<close public="1" set="method" line="148"><f a=""><x path="Void"/></f></close>
		<changeSelection public="1" set="method" line="159">
			<f a="change:?force" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</changeSelection>
		<updateMenuDesc public="1" set="method" line="181"><f a="?customTxt">
	<c path="String"/>
	<x path="Void"/>
</f></updateMenuDesc>
		<mouseOverlaps set="method" line="186"><f a="sprite">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
</f></mouseOverlaps>
		<destroy public="1" set="method" line="188" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="63"><f a="name:desc:?prefix:?objects">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><c path="flixel.FlxSprite"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.EditorTreeMenuScreen" params="" file="source/funkin/editors/EditorTreeMenu.hx" module="funkin.editors.EditorTreeMenu">
		<extends path="funkin.options.TreeMenuScreen"/>
		<new public="1" set="method" line="66"><f a="name:desc:?prefix:?objects:?newButton:?newButtonDesc:?newCallback">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><c path="flixel.FlxSprite"/></c>
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ModConfigWarning" params="" file="source/funkin/editors/ModConfigWarning.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<hadPopup public="1" expr="false" line="7" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hadPopup>
		<defaultModConfigText public="1" get="inline" set="null" expr="&quot;[Common] # This section applies the 'MOD_' prefix to the flags so you don't have to.\r\nNAME=\&quot;YOUR MOD NAME HERE\&quot;\r\nDESCRIPTION=\&quot;YOUR MOD DESCRIPTION HERE\&quot;\r\nAUTHOR=\&quot;YOU/YOUR TEAM HERE\&quot;\r\nVERSION=\&quot;YOUR MOD'S VERSION HERE\&quot;\r\n\r\n# DO NOT EDIT!! this is used to check for version compatibility!\r\nAPI_VERSION=1\r\n\r\nDOWNLOAD_LINK=\&quot;YOUR MOD PAGE LINK HERE\&quot;\r\n\r\n# Not supported yet\r\n;MOD_ICON64=\&quot;path/to/icon64.png\&quot;\r\n;MOD_ICON32=\&quot;path/to/icon32.png\&quot;\r\n;MOD_ICON16=\&quot;path/to/icon16.png\&quot;\r\nICON=\&quot;path/to/icon.png\&quot;\r\n\r\n[Flags] # This section doesn't apply any prefix.\r\nDISABLE_WARNING_SCREEN=true\r\n# Set this to false if you want to bring back the warning state (prior to 1.0.0)\r\n# NOTE: Beta warning state has been renamed from BetaWarningState.hx to WarningState.hx\r\nDISABLE_LANGUAGES=true\r\n# Some people might not translate their mods, but if you do then you may set this to false\r\n\r\n[Discord] # This section applies the 'MOD_DISCORD_' prefix to the flags so you don't have to.\r\nCLIENT_ID=\&quot;\&quot;\r\nLOGO_KEY=\&quot;\&quot;\r\nLOGO_TEXT=\&quot;\&quot;\r\n\r\n[StateRedirects] # This section is used for state redirecting, see examples below.\r\n;StoryMenuState=\&quot;funkin.menus.FreeplayState\&quot;\r\n;FreeplayState=\&quot;scriptedFreeplayState\&quot;\r\n\r\n[StateRedirects.force] # Use this if you want to override redirects set by subsequent addons/mods\r\n&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"[Common] # This section applies the 'MOD_' prefix to the flags so you don't have to.\r\nNAME=\"YOUR MOD NAME HERE\"\r\nDESCRIPTION=\"YOUR MOD DESCRIPTION HERE\"\r\nAUTHOR=\"YOU/YOUR TEAM HERE\"\r\nVERSION=\"YOUR MOD'S VERSION HERE\"\r\n\r\n# DO NOT EDIT!! this is used to check for version compatibility!\r\nAPI_VERSION=1\r\n\r\nDOWNLOAD_LINK=\"YOUR MOD PAGE LINK HERE\"\r\n\r\n# Not supported yet\r\n;MOD_ICON64=\"path/to/icon64.png\"\r\n;MOD_ICON32=\"path/to/icon32.png\"\r\n;MOD_ICON16=\"path/to/icon16.png\"\r\nICON=\"path/to/icon.png\"\r\n\r\n[Flags] # This section doesn't apply any prefix.\r\nDISABLE_WARNING_SCREEN=true\r\n# Set this to false if you want to bring back the warning state (prior to 1.0.0)\r\n# NOTE: Beta warning state has been renamed from BetaWarningState.hx to WarningState.hx\r\nDISABLE_LANGUAGES=true\r\n# Some people might not translate their mods, but if you do then you may set this to false\r\n\r\n[Discord] # This section applies the 'MOD_DISCORD_' prefix to the flags so you don't have to.\r\nCLIENT_ID=\"\"\r\nLOGO_KEY=\"\"\r\nLOGO_TEXT=\"\"\r\n\r\n[StateRedirects] # This section is used for state redirecting, see examples below.\r\n;StoryMenuState=\"funkin.menus.FreeplayState\"\r\n;FreeplayState=\"scriptedFreeplayState\"\r\n\r\n[StateRedirects.force] # Use this if you want to override redirects set by subsequent addons/mods\r\n"</e></m></meta>
		</defaultModConfigText>
		<library expr="null">
			<c path="funkin.backend.assets.ModsFolderLibrary"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</library>
		<goToState><x path="Class"><c path="flixel.FlxState"/></x></goToState>
		<createPost public="1" set="method" line="55" override="1"><f a=""><x path="Void"/></f></createPost>
		<new public="1" set="method" line="49"><f a="library:?goToState">
	<c path="funkin.backend.assets.ModsFolderLibrary"/>
	<x path="Class"><c path="flixel.FlxState"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.SaveSubstate" params="" file="source/funkin/editors/SaveSubstate.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<saveOptions public="1"><t path="Map">
	<c path="String"/>
	<x path="Bool"/>
</t></saveOptions>
		<options public="1"><t path="funkin.editors.SaveSubstateData"/></options>
		<data public="1"><c path="String"/></data>
		<cam public="1"><c path="flixel.FlxCamera"/></cam>
		<create public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="38" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="14"><f a="data:?options:?saveOptions">
	<c path="String"/>
	<x path="Null"><t path="funkin.editors.SaveSubstateData"/></x>
	<t path="Map">
		<c path="String"/>
		<x path="Bool"/>
	</t>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.SaveSubstateData" params="" file="source/funkin/editors/SaveSubstate.hx" module="funkin.editors.SaveSubstate"><a>
	<saveExt>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</saveExt>
	<defaultSaveFile>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</defaultSaveFile>
</a></typedef>
	<class path="funkin.editors.SaveWarning" params="" file="source/funkin/editors/SaveWarning.hx">
		<showWarning public="1" set="accessor" static="1"><x path="Bool"/></showWarning>
		<set_showWarning public="1" set="method" line="6" static="1"><f a="warning">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_showWarning>
		<selectionClass public="1" expr="null" line="8" static="1">
			<x path="Class"><c path="funkin.editors.EditorTreeMenu"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</selectionClass>
		<saveFunc public="1" expr="null" line="9" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</saveFunc>
		<init public="1" set="method" line="11" static="1"><f a=""><x path="Void"/></f></init>
		<warningFunc public="1" expr="null" line="19" static="1">
			<f a="">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</warningFunc>
		<triggerWarning public="1" set="method" line="20" static="1">
			<f a="?closingWindow" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ closingWindow : false }</e></m></meta>
		</triggerWarning>
		<reset public="1" get="inline" set="null" line="62" static="1"><f a=""><x path="Void"/></f></reset>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.UIDebugState" params="" file="source/funkin/editors/UIDebugState.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<topMenuSpr public="1"><c path="funkin.editors.ui.UITopMenu"/></topMenuSpr>
		<testingUIItems public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</testingUIItems>
		<testingUIHidden public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</testingUIHidden>
		<create public="1" set="method" line="15" override="1"><f a=""><x path="Void"/></f></create>
		<spliceSprites public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</spliceSprites>
		<spliceText public="1"><c path="funkin.editors.ui.UIText"/></spliceText>
		<spliceTimer public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</spliceTimer>
		<spliceCoolDown public="1" expr="0.04">
			<x path="Float"/>
			<meta><m n=":value"><e>0.04</e></m></meta>
		</spliceCoolDown>
		<spliceUseTris public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</spliceUseTris>
		<spliceCl public="1" expr="UISliceSprite">
			<x path="Class"><c path="flixel.FlxSprite"/></x>
			<meta><m n=":value"><e>UISliceSprite</e></m></meta>
		</spliceCl>
		<update public="1" set="method" line="171" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="9"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.editors.UndoList" params="T" file="source/funkin/editors/UndoList.hx">
		<undoList public="1" expr="[]">
			<c path="Array"><c path="funkin.editors.UndoList.T"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</undoList>
		<redoList public="1" expr="[]">
			<c path="Array"><c path="funkin.editors.UndoList.T"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</redoList>
		<savedLength expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</savedLength>
		<unsaved public="1" get="accessor" set="null"><x path="Bool"/></unsaved>
		<get_unsaved public="1" get="inline" set="null" line="11"><f a=""><x path="Bool"/></f></get_unsaved>
		<addToUndo public="1" get="inline" set="null" line="15"><f a="c">
	<c path="funkin.editors.UndoList.T"/>
	<x path="Void"/>
</f></addToUndo>
		<undo public="1" get="inline" set="null" line="22"><f a=""><c path="funkin.editors.UndoList.T"/></f></undo>
		<redo public="1" get="inline" set="null" line="29"><f a=""><c path="funkin.editors.UndoList.T"/></f></redo>
		<save public="1" get="inline" set="null" line="37"><f a=""><x path="Void"/></f></save>
		<clear public="1" get="inline" set="null" line="39"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.alphabet.AlphabetEditor" params="" file="source/funkin/editors/alphabet/AlphabetEditor.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<__typeface static="1"><c path="String"/></__typeface>
		<instance public="1" get="accessor" set="null" static="1"><c path="funkin.editors.alphabet.AlphabetEditor"/></instance>
		<get_instance get="inline" set="null" line="19" static="1"><f a=""><c path="funkin.editors.alphabet.AlphabetEditor"/></f></get_instance>
		<topMenu public="1"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></topMenu>
		<topMenuSpr public="1"><c path="funkin.editors.ui.UITopMenu"/></topMenuSpr>
		<uiGroup public="1" expr="new FlxTypedGroup&lt;FlxSprite&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;FlxSprite&gt;()</e></m></meta>
		</uiGroup>
		<editorCamera><c path="flixel.FlxCamera"/></editorCamera>
		<uiCamera><c path="flixel.FlxCamera"/></uiCamera>
		<translate get="inline" set="null" line="35"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<brokenWarning public="1"><c path="funkin.editors.ui.UIText"/></brokenWarning>
		<tape public="1"><c path="funkin.menus.ui.Alphabet"/></tape>
		<bigLetter public="1"><c path="funkin.menus.ui.Alphabet"/></bigLetter>
		<curLetter public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curLetter>
		<targetX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</targetX>
		<queueReorder public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</queueReorder>
		<componentList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.alphabet.ComponentButton"/></c></componentList>
		<infoWindow public="1"><c path="funkin.editors.alphabet.GlyphInfoWindow"/></infoWindow>
		<curSelectedComponent public="1" expr="null">
			<c path="funkin.menus.ui.AlphabetComponent"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curSelectedComponent>
		<curSelectedData public="1" expr="null">
			<c path="funkin.menus.ui.AlphabetLetterData"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curSelectedData>
		<outlineIdx public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</outlineIdx>
		<defaultTmr public="1" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</defaultTmr>
		<charsForDefault public="1" expr="[]">
			<c path="Array"><c path="Array"><c path="String"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</charsForDefault>
		<create public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="238" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="247" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateTape set="method" line="305"><f a=""><x path="Void"/></f></updateTape>
		<changeLetter set="method" line="340"><f a="inc">
	<x path="Int"/>
	<x path="Void"/>
</f></changeLetter>
		<findOutline public="1" set="method" line="361"><f a=""><x path="Void"/></f></findOutline>
		<checkForFailed public="1" set="method" line="373"><f a=""><x path="Bool"/></f></checkForFailed>
		<_tape_left set="method" line="389"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_tape_left>
		<_tape_right set="method" line="392"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_tape_right>
		<_file_save set="method" line="396"><f a="_">
	<x path="Null"><t path="funkin.editors.ui.UIContextMenuOption"/></x>
	<x path="Void"/>
</f></_file_save>
		<_file_saveas set="method" line="407"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas>
		<_file_exit set="method" line="413"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_exit>
		<_edit_main set="method" line="418"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_main>
		<new public="1" set="method" line="29"><f a="typeface">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>funkin.menus.ui.Alphabet</e></m>
		</meta>
	</class>
	<class path="funkin.editors.ui.UISprite" params="" file="source/funkin/editors/ui/UISprite.hx">
		<extends path="flixel.FlxSprite"/>
		<members public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxBasic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</members>
		<__lastDrawCameras expr="[]">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__lastDrawCameras>
		<__rect expr="new FlxRect()">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>new FlxRect()</e></m></meta>
		</__rect>
		<__oldDefCams><c path="Array"><c path="flixel.FlxCamera"/></c></__oldDefCams>
		<hovered public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hovered>
		<hoveredByChild public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hoveredByChild>
		<pressed public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pressed>
		<canBeHovered public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</canBeHovered>
		<hoverCallback public="1" expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</hoverCallback>
		<cursor public="1" expr="ARROW">
			<x path="funkin.backend.utils.CodeCursor"/>
			<meta><m n=":value"><e>ARROW</e></m></meta>
		</cursor>
		<focused public="1" get="accessor" set="accessor"><x path="Bool"/></focused>
		<selectable public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</selectable>
		<autoAlpha public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoAlpha>
		<get_focused get="inline" set="null" line="32"><f a=""><x path="Bool"/></f></get_focused>
		<set_focused get="inline" set="null" line="34"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_focused>
		<update public="1" set="method" line="45" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="67" override="1"><f a=""><x path="Void"/></f></draw>
		<drawSuper public="1" set="method" line="72"><f a=""><x path="Void"/></f></drawSuper>
		<drawMembers public="1" set="method" line="77"><f a=""><x path="Void"/></f></drawMembers>
		<destroy public="1" set="method" line="90" override="1"><f a=""><x path="Void"/></f></destroy>
		<updateButton public="1" set="method" line="95"><f a=""><x path="Void"/></f></updateButton>
		<updateButtonHandler public="1" set="method" line="105"><f a=""><x path="Void"/></f></updateButtonHandler>
		<onHovered public="1" set="method" line="112">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called whenever the sprite is being hovered by the mouse.</haxe_doc>
		</onHovered>
		<updateSpriteRect public="1" set="method" line="120"><f a=""><x path="Void"/></f></updateSpriteRect>
		<new public="1" set="method" line="9"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.editors.ui.UIState</e></m>
			<m n=":allow"><e>funkin.editors.ui.UIUtil</e></m>
		</meta>
	</class>
	<class path="funkin.editors.ui.UISliceSprite" params="" file="source/funkin/editors/ui/UISliceSprite.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<getFixedSize get="inline" set="null" line="86" static="1"><f a="value:total">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getFixedSize>
		<bWidth public="1" expr="120">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</bWidth>
		<bHeight public="1" expr="20">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</bHeight>
		<framesOffset public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</framesOffset>
		<incorporeal public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</incorporeal>
		<updateButton public="1" set="method" line="20" override="1"><f a=""><x path="Void"/></f></updateButton>
		<resize public="1" set="method" line="26"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<topAlpha public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</topAlpha>
		<middleAlpha public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</middleAlpha>
		<bottomAlpha public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</bottomAlpha>
		<drawTop public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</drawTop>
		<drawMiddle public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</drawMiddle>
		<drawBottom public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</drawBottom>
		<topleft expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</topleft>
		<top expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</top>
		<topright expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</topright>
		<middleleft expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</middleleft>
		<middle expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</middle>
		<middleright expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</middleright>
		<bottomleft expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bottomleft>
		<bottom expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bottom>
		<bottomright expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bottomright>
		<topHeight public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</topHeight>
		<bottomHeight public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bottomHeight>
		<leftWidth public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</leftWidth>
		<rightWidth public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rightWidth>
		<set_frames set="method" line="54" override="1"><f a="val">
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
</f></set_frames>
		<set_framesOffset set="method" line="60"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_framesOffset>
		<calculateFrames set="method" line="68"><f a=""><x path="Void"/></f></calculateFrames>
		<draw public="1" set="method" line="90" override="1"><f a=""><x path="Void"/></f></draw>
		<__setSize set="method" line="228"><f a="Width:Height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__setSize>
		<new public="1" set="method" line="12"><f a="x:y:w:h:path">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIButton" params="" file="source/funkin/editors/ui/UIButton.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<callback public="1" expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
		</callback>
		<field public="1"><c path="funkin.editors.ui.UIText"/></field>
		<shouldPress public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</shouldPress>
		<hasBeenPressed public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasBeenPressed>
		<autoFrames public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoFrames>
		<autoFollow public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoFollow>
		<resize public="1" set="method" line="24" override="1"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<onHovered public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></onHovered>
		<update public="1" set="method" line="41" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="51" override="1"><f a=""><x path="Void"/></f></draw>
		<setFrameOffset public="1" set="method" line="56"><f a=""><x path="Void"/></f></setFrameOffset>
		<new public="1" set="method" line="12">
			<f a="x:y:text:callback:?w:?h" v="::::120:32">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : 32, w : 120 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.alphabet.ComponentButton" params="" file="source/funkin/editors/alphabet/AlphabetEditor.hx" module="funkin.editors.alphabet.AlphabetEditor">
		<extends path="funkin.editors.ui.UIButton"/>
		<component public="1"><c path="funkin.menus.ui.AlphabetComponent"/></component>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="492" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="446"><f a="component">
	<c path="funkin.menus.ui.AlphabetComponent"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UISubstateWindow" params="" file="source/funkin/editors/ui/UISubstateWindow.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<camShaders expr="[]">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</camShaders>
		<blurShader expr="{  var _ = new CustomShader(Options.intensiveBlur ? &quot;engine/editorBlur&quot; : &quot;engine/editorBlurFast&quot;);  if (!Options.intensiveBlur) {   var noiseTexture:ShaderInput&lt;openfl.display.BitmapData&gt; = _.data.noiseTexture;   noiseTexture.input = Assets.getBitmapData(&quot;assets/shaders/noise256.png&quot;);   noiseTexture.wrap = REPEAT;   var noiseTextureSize:ShaderParameter&lt;Float&gt; = _.data.noiseTextureSize;   noiseTextureSize.value = [noiseTexture.input.width, noiseTexture.input.height];  };  _; }">
			<c path="funkin.backend.shaders.CustomShader"/>
			<meta><m n=":value"><e>{
	var _ = new CustomShader(Options.intensiveBlur ? "engine/editorBlur" : "engine/editorBlurFast");
	if (!Options.intensiveBlur) {
		var noiseTexture:ShaderInput&lt;openfl.display.BitmapData&gt; = _.data.noiseTexture;
		noiseTexture.input = Assets.getBitmapData("assets/shaders/noise256.png");
		noiseTexture.wrap = REPEAT;
		var noiseTextureSize:ShaderParameter&lt;Float&gt; = _.data.noiseTextureSize;
		noiseTextureSize.value = [noiseTexture.input.width, noiseTexture.input.height];
	};
	_;
}</e></m></meta>
		</blurShader>
		<titleSpr><c path="funkin.editors.ui.UIText"/></titleSpr>
		<messageSpr><c path="funkin.editors.ui.UIText"/></messageSpr>
		<subCam><c path="flixel.FlxCamera"/></subCam>
		<windowSpr><c path="funkin.editors.ui.UISliceSprite"/></windowSpr>
		<onSubstateOpen public="1" set="method" line="32" override="1"><f a=""><x path="Void"/></f></onSubstateOpen>
		<winWidth expr="560">
			<x path="Int"/>
			<meta><m n=":value"><e>560</e></m></meta>
		</winWidth>
		<winHeight expr="570">
			<x path="Int"/>
			<meta><m n=":value"><e>570</e></m></meta>
		</winHeight>
		<winTitle expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</winTitle>
		<winSkin expr="&quot;editors/ui/normal-popup&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"editors/ui/normal-popup"</e></m></meta>
		</winSkin>
		<create public="1" set="method" line="43" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="88" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="99" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="11"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.alphabet.AlphabetMainDataScreen" params="" file="source/funkin/editors/alphabet/AlphabetMainDataScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<bigLetter><c path="funkin.menus.ui.Alphabet"/></bigLetter>
		<tape><c path="funkin.menus.ui.Alphabet"/></tape>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<helpButton public="1"><c path="funkin.editors.ui.UIButton"/></helpButton>
		<fpsStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></fpsStepper>
		<advanceStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></advanceStepper>
		<lineGapStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></lineGapStepper>
		<caseDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></caseDropdown>
		<colorDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></colorDropdown>
		<regTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></regTextBox>
		<upperTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></upperTextBox>
		<lowerTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></lowerTextBox>
		<targetPercent public="1" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</targetPercent>
		<helpBG public="1"><c path="funkin.editors.ui.UISliceSprite"/></helpBG>
		<helpTxt public="1"><c path="funkin.editors.ui.UIText"/></helpTxt>
		<helpScroll public="1"><c path="funkin.editors.ui.UIScrollBar"/></helpScroll>
		<create public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="144" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<saveInfo public="1" set="method" line="155"><f a=""><x path="Void"/></f></saveInfo>
		<setDefault set="method" line="177"><f a="index:name">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></setDefault>
		<new public="1" set="method" line="10"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.alphabet.AlphabetSelection" params="" file="source/funkin/editors/alphabet/AlphabetSelection.hx">
		<extends path="funkin.editors.EditorTreeMenu"/>
		<create public="1" set="method" line="12" override="1"><f a=""><x path="Void"/></f></create>
		<new public="1" set="method" line="11"><f a="?exitCallback:?scriptsAllowed:?scriptName">
	<f a="">
		<c path="funkin.options.TreeMenu"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.alphabet.AlphabetSelectionScreen" params="" file="source/funkin/editors/alphabet/AlphabetSelection.hx" module="funkin.editors.alphabet.AlphabetSelection">
		<extends path="funkin.editors.EditorTreeMenuScreen"/>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.ITreeOption" params="" file="source/funkin/options/TreeMenu.hx" module="funkin.options.TreeMenu" interface="1">
		<desc public="1"><c path="String"/></desc>
		<selected public="1"><x path="Bool"/></selected>
		<changeSelection public="1" set="method"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<select public="1" set="method"><f a=""><x path="Void"/></f></select>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.OptionType" params="" file="source/funkin/options/type/OptionType.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<implements path="funkin.options.ITreeOption"/>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<locked public="1" set="accessor"><x path="Bool"/></locked>
		<text public="1" set="accessor"><c path="String"/></text>
		<rawText public="1" set="accessor"><c path="String"/></rawText>
		<desc public="1"><c path="String"/></desc>
		<rawDesc public="1" set="accessor"><c path="String"/></rawDesc>
		<itemHeight public="1" expr="120">
			<x path="Float"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</itemHeight>
		<editorFlashColor public="1" expr="FlxColor.WHITE">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>FlxColor.WHITE</e></m></meta>
		</editorFlashColor>
		<set_locked set="method" line="31"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_locked>
		<set_text set="method" line="37"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<set_rawText set="method" line="38"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_rawText>
		<set_rawDesc set="method" line="44"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_rawDesc>
		<reloadStrings public="1" set="method" line="50"><f a=""><x path="Void"/></f></reloadStrings>
		<update public="1" set="method" line="55" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeSelection public="1" set="method" line="60"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<select public="1" set="method" line="61"><f a=""><x path="Void"/></f></select>
		<get_height set="method" line="63" override="1"><f a=""><x path="Float"/></f></get_height>
		<new public="1" set="method" line="25"><f a="text:desc">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Base class for all option types.
 * Used in OptionsMenu.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.TextOption" params="" file="source/funkin/options/type/TextOption.hx">
		<extends path="funkin.options.type.OptionType"/>
		<suffix public="1" set="accessor"><c path="String"/></suffix>
		<selectCallback public="1"><f a=""><x path="Void"/></f></selectCallback>
		<__text><c path="funkin.menus.ui.Alphabet"/></__text>
		<set_text set="method" line="13" override="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<set_suffix set="method" line="18"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_suffix>
		<select public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></select>
		<new public="1" set="method" line="24">
			<f a="text:desc:?suffix:?selectCallback" v="::&quot;&quot;:null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ selectCallback : null, suffix : "" }</e></m></meta>
		</new>
		<haxe_doc>* Option type that has text.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.alphabet.AlphabetIconOption" params="" file="source/funkin/editors/alphabet/AlphabetSelection.hx" module="funkin.editors.alphabet.AlphabetSelection">
		<extends path="funkin.options.type.TextOption"/>
		<iconSpr public="1"><c path="flixel.FlxSprite"/></iconSpr>
		<new public="1" set="method" line="39"><f a="name:desc:typeface:callback">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIWindow" params="" file="source/funkin/editors/ui/UIWindow.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<titleSpr public="1"><c path="funkin.editors.ui.UIText"/></titleSpr>
		<collapsable public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</collapsable>
		<content public="1"><c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxBasic"/></c></content>
		<update public="1" set="method" line="21" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="8"><f a="x:y:w:h:?title">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.alphabet.GlyphInfoWindow" params="" file="source/funkin/editors/alphabet/GlyphInfoWindow.hx">
		<extends path="funkin.editors.ui.UIWindow"/>
		<prefixBox public="1"><c path="funkin.editors.ui.UITextBox"/></prefixBox>
		<xBox public="1"><c path="funkin.editors.ui.UINumericStepper"/></xBox>
		<yBox public="1"><c path="funkin.editors.ui.UINumericStepper"/></yBox>
		<scaleXBox public="1"><c path="funkin.editors.ui.UINumericStepper"/></scaleXBox>
		<scaleYBox public="1"><c path="funkin.editors.ui.UINumericStepper"/></scaleYBox>
		<angleBox public="1"><c path="funkin.editors.ui.UINumericStepper"/></angleBox>
		<colorModeDrop public="1"><c path="funkin.editors.ui.UIDropDown"/></colorModeDrop>
		<outlineTitle public="1"><c path="funkin.editors.ui.UIText"/></outlineTitle>
		<outlineSep public="1"><c path="funkin.editors.ui.UISprite"/></outlineSep>
		<outlineCheck public="1"><c path="funkin.editors.ui.UICheckbox"/></outlineCheck>
		<outlineBoxTitle public="1"><c path="funkin.editors.ui.UIText"/></outlineBoxTitle>
		<outlineBox public="1"><c path="funkin.editors.ui.UITextBox"/></outlineBox>
		<outlineOffTitle public="1"><c path="funkin.editors.ui.UIText"/></outlineOffTitle>
		<outlineXBox public="1"><c path="funkin.editors.ui.UINumericStepper"/></outlineXBox>
		<outlineYBox public="1"><c path="funkin.editors.ui.UINumericStepper"/></outlineYBox>
		<targetPercent public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</targetPercent>
		<outlinePercent public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</outlinePercent>
		<outlineAlphaMults public="1"><c path="Array"><x path="Float"/></c></outlineAlphaMults>
		<outlineItems public="1"><c path="Array"><c path="flixel.FlxSprite"/></c></outlineItems>
		<initialY public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</initialY>
		<compon get="accessor" set="null"><c path="funkin.menus.ui.AlphabetComponent"/></compon>
		<data get="accessor" set="null"><c path="funkin.menus.ui.AlphabetLetterData"/></data>
		<update public="1" set="method" line="204" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateInfo public="1" set="method" line="223"><f a=""><x path="Void"/></f></updateInfo>
		<valueSet set="method" line="263"><f a="item:func:text">
	<c path="funkin.editors.ui.UINumericStepper"/>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></valueSet>
		<get_compon set="method" line="268"><f a=""><c path="funkin.menus.ui.AlphabetComponent"/></f></get_compon>
		<get_data set="method" line="271"><f a=""><c path="funkin.menus.ui.AlphabetLetterData"/></f></get_data>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterAnimButton" params="" file="source/funkin/editors/character/CharacterAnimButton.hx">
		<extends path="funkin.editors.ui.UIButton"/>
		<anim public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</anim>
		<valid public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</valid>
		<data public="1" expr="null">
			<t path="funkin.backend.utils.AnimData"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</data>
		<parent public="1"><c path="funkin.editors.character.CharacterAnimsWindow"/></parent>
		<animationDisplayBG public="1"><c path="funkin.editors.ui.UISliceSprite"/></animationDisplayBG>
		<nameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></nameTextBox>
		<animTextBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></animTextBox>
		<positionXStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></positionXStepper>
		<positionYStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></positionYStepper>
		<fpsStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></fpsStepper>
		<loopedCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></loopedCheckbox>
		<indicesTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></indicesTextBox>
		<XYComma public="1"><c path="funkin.editors.ui.UIText"/></XYComma>
		<editButton public="1"><c path="funkin.editors.ui.UIButton"/></editButton>
		<editIcon public="1"><c path="flixel.FlxSprite"/></editIcon>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<ghostButton public="1"><c path="funkin.editors.ui.UIButton"/></ghostButton>
		<ghostIcon public="1"><c path="flixel.FlxSprite"/></ghostIcon>
		<animIcon public="1"><c path="flixel.FlxSprite"/></animIcon>
		<labels public="1" expr="[]">
			<t path="Map">
				<c path="funkin.editors.ui.UISprite"/>
				<c path="funkin.editors.ui.UIText"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</labels>
		<foldableButtons public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</foldableButtons>
		<closed public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</closed>
		<translate get="inline" set="null" line="52"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<updateButtonsPos public="1" get="inline" set="null" line="184"><f a=""><x path="Void"/></f></updateButtonsPos>
		<update public="1" set="method" line="216" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeName public="1" set="method" line="225">
			<f a="newName:?addToUndo" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeName>
		<changeAnim public="1" set="method" line="268">
			<f a="newAnim:?addToUndo" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeAnim>
		<changeOffset public="1" set="method" line="300">
			<f a="newOffsetX:newOffsetY:?addToUndo" v="::true">
				<x path="Null"><x path="Float"/></x>
				<x path="Null"><x path="Float"/></x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeOffset>
		<changeFPS public="1" set="method" line="324">
			<f a="newFPS:?addToUndo" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeFPS>
		<changeLooping public="1" set="method" line="345">
			<f a="newLooping:?addToUndo" v=":true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeLooping>
		<changeIndicies public="1" set="method" line="366">
			<f a="indicies:?addToUndo" v=":true">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeIndicies>
		<refreshFlxAnimationFrames public="1" get="inline" set="null" line="403"><f a="flxAnimation:animData">
	<c path="flixel.animation.FlxAnimation"/>
	<t path="funkin.backend.utils.AnimData"/>
	<x path="Void"/>
</f></refreshFlxAnimationFrames>
		<refreshSymbolKeyFrames public="1" get="inline" set="null" line="428"><f a="symbol:animData">
	<c path="flxanimate.animate.FlxSymbolAnimation"/>
	<t path="funkin.backend.utils.AnimData"/>
	<x path="Void"/>
</f></refreshSymbolKeyFrames>
		<toggleGhost public="1" set="method" line="446"><f a=""><x path="Void"/></f></toggleGhost>
		<draw public="1" set="method" line="460" override="1"><f a=""><x path="Void"/></f></draw>
		<updateText public="1" set="method" line="479"><f a=""><x path="Void"/></f></updateText>
		<validate public="1" set="method" line="485">
			<f a="?isValid" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isValid : true }</e></m></meta>
		</validate>
		<invalidate public="1" get="inline" set="null" line="507"><f a=""><x path="Void"/></f></invalidate>
		<__getFlxAnimation public="1" get="inline" set="null" line="509"><f a=""><x path="Null"><c path="flixel.animation.FlxAnimation"/></x></f></__getFlxAnimation>
		<__getAnimationSymbol public="1" get="inline" set="null" line="520"><f a=""><x path="Null"><c path="flxanimate.animate.FlxSymbolAnimation"/></x></f></__getAnimationSymbol>
		<__refreshAnimation set="method" line="527">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__refreshAnimation>
		<checkValid public="1" get="inline" set="null" line="541"><f a=""><x path="Void"/></f></checkValid>
		<new public="1" set="method" line="54"><f a="x:y:animData:parent">
	<x path="Float"/>
	<x path="Float"/>
	<t path="funkin.backend.utils.AnimData"/>
	<c path="funkin.editors.character.CharacterAnimsWindow"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIButtonList" params="T" file="source/funkin/editors/ui/UIButtonList.hx">
		<extends path="funkin.editors.ui.UIWindow"/>
		<buttons public="1" expr="new FlxTypedGroup&lt;T&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="funkin.editors.ui.UIButtonList.T"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;T&gt;()</e></m></meta>
		</buttons>
		<addButton public="1"><c path="funkin.editors.ui.UIButton"/></addButton>
		<addIcon public="1"><c path="flixel.FlxSprite"/></addIcon>
		<buttonCameras public="1"><c path="flixel.FlxCamera"/></buttonCameras>
		<cameraSpacing public="1" expr="30">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</cameraSpacing>
		<buttonSpacing public="1" expr="16">
			<x path="Float"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</buttonSpacing>
		<buttonSize public="1" expr="null">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</buttonSize>
		<buttonOffset public="1" expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</buttonOffset>
		<dragging public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dragging>
		<dragCallback public="1"><f a="::">
	<c path="funkin.editors.ui.UIButtonList.T"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dragCallback>
		<curMoving expr="null">
			<c path="funkin.editors.ui.UIButtonList.T"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curMoving>
		<curMovingInterval expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curMovingInterval>
		<add public="1" get="inline" set="null" line="50"><f a="button">
	<c path="funkin.editors.ui.UIButtonList.T"/>
	<x path="Void"/>
</f></add>
		<insert public="1" get="inline" set="null" line="57"><f a="button:position">
	<c path="funkin.editors.ui.UIButtonList.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></insert>
		<remove public="1" get="inline" set="null" line="63"><f a="button">
	<c path="funkin.editors.ui.UIButtonList.T"/>
	<x path="Void"/>
</f></remove>
		<updateButtonsPos public="1" get="inline" set="null" line="69"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateButtonsPos>
		<nextscrollY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextscrollY>
		<update public="1" set="method" line="106" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="143" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="26"><f a="x:y:width:height:windowName:buttonSize:?buttonOffset:?buttonSpacing">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterAnimsWindow" params="" file="source/funkin/editors/character/CharacterAnimsWindow.hx">
		<extends path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.character.CharacterAnimButton"/></extends>
		<character public="1"><c path="funkin.editors.character.CharacterGhost"/></character>
		<displayWindowSprite public="1"><c path="flixel.FlxSprite"/></displayWindowSprite>
		<displayWindowGraphic public="1"><c path="flixel.graphics.FlxGraphic"/></displayWindowGraphic>
		<displayAnimsFramesList public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<a>
					<scale><x path="Float"/></scale>
					<frame><x path="flixel.util.typeLimit.OneOfTwo">
	<x path="Int"/>
	<c path="String"/>
</x></frame>
					<animBounds><c path="openfl.geom.Rectangle"/></animBounds>
				</a>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</displayAnimsFramesList>
		<animButtons public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.editors.character.CharacterAnimButton"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</animButtons>
		<animsList public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</animsList>
		<ghosts public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</ghosts>
		<__movingAnimOldOrder expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</__movingAnimOldOrder>
		<update public="1" set="method" line="55" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<buildAnimDisplay public="1" set="method" line="71"><f a="name:anim">
	<c path="String"/>
	<t path="funkin.backend.utils.AnimData"/>
	<x path="Void"/>
</f></buildAnimDisplay>
		<removeAnimDisplay public="1" set="method" line="99"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeAnimDisplay>
		<deleteAnimation public="1" set="method" line="101">
			<f a="button:?addToUndo" v=":true">
				<c path="funkin.editors.character.CharacterAnimButton"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</deleteAnimation>
		<generateAnimation public="1" set="method" line="115"><f a=""><x path="Void"/></f></generateAnimation>
		<addAnimation public="1" set="method" line="140">
			<f a="animData:?animID:?addToUndo" v=":-1:true">
				<t path="funkin.backend.utils.AnimData"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true, animID : -1 }</e></m></meta>
		</addAnimation>
		<__autoCompleteAnims expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__autoCompleteAnims>
		<setAnimAutoComplete public="1" get="inline" set="null" line="163"><f a="anims">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></setAnimAutoComplete>
		<findValid public="1" set="method" line="169"><f a=""><x path="Null"><c path="String"/></x></f></findValid>
		<new public="1" set="method" line="24"><f a="x:y:character">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.editors.character.CharacterGhost"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterCreationScreen" params="" file="source/funkin/editors/character/CharacterCreationScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<onSave expr="null">
			<f a="::">
				<c path="String"/>
				<t path="funkin.editors.ui.ImageSaveData"/>
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<characterNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></characterNameTextBox>
		<imageExplorer public="1"><c path="funkin.editors.ui.UIImageExplorer"/></imageExplorer>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<translate get="inline" set="null" line="19"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<create public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></create>
		<onLoadImage public="1" set="method" line="69"><f a=""><x path="Void"/></f></onLoadImage>
		<refreshWindowSize public="1" set="method" line="74"><f a=""><x path="Void"/></f></refreshWindowSize>
		<checkRequired public="1" set="method" line="84"><f a=""><x path="Void"/></f></checkRequired>
		<createCharacter public="1" set="method" line="88"><f a=""><x path="Void"/></f></createCharacter>
		<new public="1" set="method" line="21"><f a="?onSave">
	<f a="::">
		<c path="String"/>
		<t path="funkin.editors.ui.ImageSaveData"/>
		<c path="Xml"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterEditor" params="" file="source/funkin/editors/character/CharacterEditor.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<__character static="1"><c path="String"/></__character>
		<instance public="1" get="accessor" set="null" static="1"><c path="funkin.editors.character.CharacterEditor"/></instance>
		<get_instance get="inline" set="null" line="30" static="1"><f a=""><c path="funkin.editors.character.CharacterEditor"/></f></get_instance>
		<undos public="1" static="1"><c path="funkin.editors.UndoList"><e path="funkin.editors.character.CharacterEditorChange"/></c></undos>
		<character public="1"><c path="funkin.editors.character.CharacterGhost"/></character>
		<topMenu public="1"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></topMenu>
		<animationIndex expr="5">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>5</e></m>
				<m n=":noCompletion"/>
			</meta>
		</animationIndex>
		<stageIndex expr="3">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>3</e></m>
				<m n=":noCompletion"/>
			</meta>
		</stageIndex>
		<topMenuSpr public="1"><c path="funkin.editors.ui.UITopMenu"/></topMenuSpr>
		<axisGizmo public="1"><c path="funkin.editors.extra.AxisGizmo"/></axisGizmo>
		<characterGizmo public="1"><c path="funkin.editors.character.CharacterGizmos"/></characterGizmo>
		<uiGroup public="1" expr="new FlxTypedGroup&lt;FlxSprite&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;FlxSprite&gt;()</e></m></meta>
		</uiGroup>
		<cameraHoverDummy public="1"><c path="funkin.editors.extra.CameraHoverDummy"/></cameraHoverDummy>
		<characterPropertiesWindow public="1"><c path="funkin.editors.character.CharacterPropertiesWindow"/></characterPropertiesWindow>
		<characterAnimsWindow public="1"><c path="funkin.editors.character.CharacterAnimsWindow"/></characterAnimsWindow>
		<charCamera public="1"><c path="flixel.FlxCamera"/></charCamera>
		<gizmosCamera public="1"><c path="flixel.FlxCamera"/></gizmosCamera>
		<uiCamera public="1"><c path="flixel.FlxCamera"/></uiCamera>
		<animationText public="1"><c path="funkin.editors.ui.UIText"/></animationText>
		<currentStage public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</currentStage>
		<stage public="1" expr="null">
			<c path="funkin.game.Stage"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</stage>
		<stageSprites public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxBasic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</stageSprites>
		<stagePosition public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</stagePosition>
		<translate get="inline" set="null" line="69"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<create public="1" set="method" line="71" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="340" override="1"><f a=""><x path="Void"/></f></destroy>
		<_point expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</_point>
		<_nextScroll expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</_nextScroll>
		<_cameraZoomMulti expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_cameraZoomMulti>
		<draggingCharacter public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</draggingCharacter>
		<draggingOffset public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</draggingOffset>
		<update public="1" set="method" line="359" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<handleMouseOffsets get="inline" set="null" line="408"><f a=""><x path="Void"/></f></handleMouseOffsets>
		<onResize public="1" set="method" line="435" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<_file_new set="method" line="451"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_new>
		<_file_save set="method" line="454"><f a="_">
	<x path="Null"><t path="funkin.editors.ui.UIContextMenuOption"/></x>
	<x path="Void"/>
</f></_file_save>
		<_file_saveas set="method" line="467"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas>
		<_file_exit set="method" line="475"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_exit>
		<buildCharacter set="method" line="480"><f a=""><c path="String"/></f></buildCharacter>
		<clipboard expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</clipboard>
		<_edit_copy_offset set="method" line="494"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_copy_offset>
		<_edit_paste_offset set="method" line="497"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_paste_offset>
		<_undo set="method" line="501"><f a="undo">
	<e path="funkin.editors.character.CharacterEditorChange"/>
	<x path="Void"/>
</f></_undo>
		<_edit_undo set="method" line="567"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_undo>
		<_redo set="method" line="572"><f a="redo">
	<e path="funkin.editors.character.CharacterEditorChange"/>
	<x path="Void"/>
</f></_redo>
		<_edit_redo set="method" line="636"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_redo>
		<_edit_info set="method" line="641"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_info>
		<_edit_sprite set="method" line="642"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_sprite>
		<_offsets_left set="method" line="644"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_left>
		<_offsets_up set="method" line="645"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_up>
		<_offsets_down set="method" line="646"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_down>
		<_offsets_right set="method" line="647"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_right>
		<_offsets_extra_left set="method" line="648"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_extra_left>
		<_offsets_extra_up set="method" line="649"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_extra_up>
		<_offsets_extra_down set="method" line="650"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_extra_down>
		<_offsets_extra_right set="method" line="651"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_extra_right>
		<_offsets_drag_offsets_mouse set="method" line="653"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_offsets_drag_offsets_mouse>
		<_offsets_clear set="method" line="657"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_offsets_clear>
		<clearOffsets set="method" line="659">
			<f a="?addToUndo" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</clearOffsets>
		<_change_offset set="method" line="671"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></_change_offset>
		<_set_offset set="method" line="679"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></_set_offset>
		<buildStagesUI set="method" line="686"><f a=""><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></f></buildStagesUI>
		<changeStage set="method" line="712"><f a="__stage">
	<c path="String"/>
	<x path="Void"/>
</f></changeStage>
		<updateStagePositions set="method" line="757"><f a="stagePositions">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></updateStagePositions>
		<changeStagePosition public="1" set="method" line="766"><f a="position">
	<c path="String"/>
	<x path="Void"/>
</f></changeStagePosition>
		<changeCharacterDesginedAs public="1" set="method" line="784">
			<f a="player:?addToUndo" v=":true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeCharacterDesginedAs>
		<updateCharacterStagePosition public="1" get="inline" set="null" line="803"><f a=""><x path="Void"/></f></updateCharacterStagePosition>
		<changeCharacterIsPlayer public="1" set="method" line="809"><f a="player">
	<x path="Bool"/>
	<x path="Void"/>
</f></changeCharacterIsPlayer>
		<_view_zoomin set="method" line="819"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomin>
		<_view_zoomout set="method" line="824"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomout>
		<_view_zoomreset set="method" line="829"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomreset>
		<_view_character_show_hitbox set="method" line="834"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_view_character_show_hitbox>
		<_view_character_show_camera set="method" line="839"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_view_character_show_camera>
		<_view_character_show_axis set="method" line="844"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_view_character_show_axis>
		<_view_focus_character set="method" line="849"><f a="_">
	<x path="Null"><d/></x>
	<x path="Void"/>
</f></_view_focus_character>
		<zoom set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</zoom>
		<__camZoom set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</__camZoom>
		<set_zoom set="method" line="861"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zoom>
		<set___camZoom set="method" line="864"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set___camZoom>
		<_animation_play set="method" line="868"><f a="_">
	<x path="Null"><t path="funkin.editors.ui.UIContextMenuOption"/></x>
	<x path="Void"/>
</f></_animation_play>
		<_animation_stop set="method" line="873"><f a="_">
	<x path="Null"><t path="funkin.editors.ui.UIContextMenuOption"/></x>
	<x path="Void"/>
</f></_animation_stop>
		<_animation_up set="method" line="879"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_animation_up>
		<_animation_down set="method" line="887"><f a="_">
	<x path="Null"><t path="funkin.editors.ui.UIContextMenuOption"/></x>
	<x path="Void"/>
</f></_animation_down>
		<_animation_toggle_anim_playing_offsets set="method" line="894"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_animation_toggle_anim_playing_offsets>
		<characterFakeAnim public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</characterFakeAnim>
		<playAnimation public="1" set="method" line="900"><f a="anim">
	<c path="String"/>
	<x path="Void"/>
</f></playAnimation>
		<new public="1" set="method" line="63"><f a="character">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="funkin.editors.character.CharacterEditorChange" params="" file="source/funkin/editors/character/CharacterEditor.hx" module="funkin.editors.character.CharacterEditor">
		<CCharEditPosition a="oldPos:newPos">
			<x path="flixel.math.FlxPoint"/>
			<x path="flixel.math.FlxPoint"/>
		</CCharEditPosition>
		<CCharEditCamPosition a="oldPos:newPos">
			<x path="flixel.math.FlxPoint"/>
			<x path="flixel.math.FlxPoint"/>
		</CCharEditCamPosition>
		<CCharEditScale a="oldScale:newScale">
			<x path="Float"/>
			<x path="Float"/>
		</CCharEditScale>
		<CCharEditFlipped a="newFlipped"><x path="Bool"/></CCharEditFlipped>
		<CCharEditAntialiasing a="newAntialiasing"><x path="Bool"/></CCharEditAntialiasing>
		<CCharEditDesignedAs a="newIsPlayer"><x path="Bool"/></CCharEditDesignedAs>
		<CCharEditInfo a="oldInfo:newInfo">
			<t path="funkin.editors.character.CharacterExtraInfo"/>
			<t path="funkin.editors.character.CharacterExtraInfo"/>
		</CCharEditInfo>
		<CCharEditSprite a="fileID"><x path="Int"/></CCharEditSprite>
		<CAnimCreate a="animID:animData">
			<x path="Int"/>
			<t path="funkin.backend.utils.AnimData"/>
		</CAnimCreate>
		<CAnimDelete a="animID:animData">
			<x path="Int"/>
			<t path="funkin.backend.utils.AnimData"/>
		</CAnimDelete>
		<CAnimEditOrder a="animID:newAnimID">
			<x path="Int"/>
			<x path="Int"/>
		</CAnimEditOrder>
		<CAnimEditName a="animID:oldName:newName">
			<x path="Int"/>
			<c path="String"/>
			<c path="String"/>
		</CAnimEditName>
		<CAnimEditAnim a="animID:oldAnim:newAnim">
			<x path="Int"/>
			<c path="String"/>
			<c path="String"/>
		</CAnimEditAnim>
		<CAnimEditOffset a="animID:oldOffset:newOffset">
			<x path="Int"/>
			<x path="flixel.math.FlxPoint"/>
			<x path="flixel.math.FlxPoint"/>
		</CAnimEditOffset>
		<CAnimEditFPS a="animID:oldFPS:newFPS">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</CAnimEditFPS>
		<CAnimEditLooping a="animID:newLooping">
			<x path="Int"/>
			<x path="Bool"/>
		</CAnimEditLooping>
		<CAnimEditIndices a="animID:oldIndicies:newIndicies">
			<x path="Int"/>
			<c path="Array"><x path="Int"/></c>
			<c path="Array"><x path="Int"/></c>
		</CAnimEditIndices>
		<CCharClearOffsets a="oldOffsets"><t path="Map">
	<c path="String"/>
	<x path="flixel.math.FlxPoint"/>
</t></CCharClearOffsets>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="funkin.editors.character.AtlasState" params="" file="source/funkin/editors/character/CharacterGhost.hx" module="funkin.editors.character.CharacterGhost"><a>
	<oldTick><x path="Float"/></oldTick>
	<oldPlaying><x path="Bool"/></oldPlaying>
	<oldFrame><x path="Int"/></oldFrame>
	<oldAnim><c path="String"/></oldAnim>
</a></typedef>
	<class path="funkin.game.Character" params="" file="source/funkin/game/Character.hx">
		<extends path="funkin.backend.FunkinSprite"/>
		<implements path="funkin.backend.utils.IPrePostDraw"/>
		<implements path="funkin.backend.system.interfaces.IOffsetCompatible"/>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<characterProperties public="1" expr="[&quot;x&quot;, &quot;y&quot;, &quot;sprite&quot;, &quot;scale&quot;, &quot;antialiasing&quot;, &quot;flipX&quot;, &quot;camx&quot;, &quot;camy&quot;, &quot;isPlayer&quot;, &quot;icon&quot;, &quot;color&quot;, &quot;gameOverChar&quot;, &quot;holdTime&quot;]" line="409" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["x", "y", "sprite", "scale", "antialiasing", "flipX", "camx", "camy", "isPlayer", "icon", "color", "gameOverChar", "holdTime"]</e></m></meta>
		</characterProperties>
		<characterAnimProperties public="1" expr="[&quot;name&quot;, &quot;anim&quot;, &quot;x&quot;, &quot;y&quot;, &quot;fps&quot;, &quot;loop&quot;, &quot;indices&quot;]" line="414" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["name", "anim", "x", "y", "fps", "loop", "indices"]</e></m></meta>
		</characterAnimProperties>
		<FALLBACK_CHARACTER public="1" expr="Flags.DEFAULT_CHARACTER" line="500" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_CHARACTER</e></m></meta>
		</FALLBACK_CHARACTER>
		<FALLBACK_DEAD_CHARACTER public="1" expr="Flags.DEFAULT_GAMEOVER_CHARACTER" line="501" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_GAMEOVER_CHARACTER</e></m></meta>
		</FALLBACK_DEAD_CHARACTER>
		<getXMLFromCharName public="1" set="method" line="520" static="1"><f a="character">
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<c path="funkin.game.Character"/>
	</x>
	<x path="haxe.xml.Access"/>
</f></getXMLFromCharName>
		<getIconFromCharName public="1" set="method" line="555" static="1">
			<f a="?character:?defaultIcon" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ defaultIcon : null }</e></m></meta>
		</getIconFromCharName>
		<getList public="1" set="method" line="566" static="1">
			<f a="?mods:?includeFolders:?folder" v="false:false:&quot;data/characters/&quot;">
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ folder : "data/characters/", includeFolders : false, mods : false }</e></m></meta>
		</getList>
		<isPlayer public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isPlayer>
		<curCharacter public="1" expr="Flags.DEFAULT_CHARACTER">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_CHARACTER</e></m></meta>
		</curCharacter>
		<sprite public="1" expr="Flags.DEFAULT_CHARACTER">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_CHARACTER</e></m></meta>
		</sprite>
		<lastHit public="1" expr="Math.NEGATIVE_INFINITY">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.NEGATIVE_INFINITY</e></m></meta>
		</lastHit>
		<holdTime public="1" expr="4">
			<x path="Float"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</holdTime>
		<playerOffsets public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</playerOffsets>
		<icon public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</icon>
		<iconColor public="1" expr="null">
			<x path="Null"><x path="flixel.util.FlxColor"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</iconColor>
		<gameOverCharacter public="1" expr="Character.FALLBACK_DEAD_CHARACTER">
			<c path="String"/>
			<meta><m n=":value"><e>Character.FALLBACK_DEAD_CHARACTER</e></m></meta>
		</gameOverCharacter>
		<cameraOffset public="1" expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</cameraOffset>
		<globalOffset public="1" expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</globalOffset>
		<extraOffset public="1" expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</extraOffset>
		<xml public="1"><x path="haxe.xml.Access"/></xml>
		<scripts public="1"><c path="funkin.backend.scripting.ScriptPack"/></scripts>
		<xmlImportedScripts public="1" expr="[]">
			<c path="Array"><c path="funkin.backend.utils.XMLImportedScriptInfo"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</xmlImportedScripts>
		<script public="1" set="accessor"><c path="funkin.backend.scripting.Script"/></script>
		<prepareInfos public="1" set="method" line="59"><f a="node">
	<x path="haxe.xml.Access"/>
	<c path="funkin.backend.utils.XMLImportedScriptInfo"/>
</f></prepareInfos>
		<idleSuffix public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</idleSuffix>
		<stunned public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stunned>
		<__stunnedTime expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__stunnedTime>
		<__lockAnimThisFrame expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__lockAnimThisFrame>
		<__switchAnims expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__switchAnims>
		<__swappedLeftRightAnims expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__swappedLeftRightAnims>
		<__autoInterval expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__autoInterval>
		<fixChar public="1" set="method" line="97">
			<f a="?switchAnims:?autoInterval" v="false:false">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ autoInterval : false, switchAnims : false }</e></m></meta>
		</fixChar>
		<swapLeftRightAnimations public="1" set="method" line="110"><f a=""><x path="Void"/></f></swapLeftRightAnimations>
		<__baseFlipped expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__baseFlipped>
		<isDanceLeftDanceRight expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isDanceLeftDanceRight>
		<update public="1" set="method" line="123" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<danced expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</danced>
		<dance public="1" set="method" line="140"><f a=""><x path="Void"/></f></dance>
		<tryDance public="1" set="method" line="153"><f a=""><x path="Void"/></f></tryDance>
		<danceOnBeat public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the character should dance on beat or not.</haxe_doc>
		</danceOnBeat>
		<beatHit public="1" set="method" line="178" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<measureHit public="1" set="method" line="187" override="1"><f a="curMeasure">
	<x path="Int"/>
	<x path="Void"/>
</f></measureHit>
		<stepHit public="1" set="method" line="190" override="1"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<__reverseDrawProcedure expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__reverseDrawProcedure>
		<getScreenBounds public="1" set="method" line="193" override="1"><f a="?newRect:?camera">
	<c path="flixel.math.FlxRect"/>
	<c path="flixel.FlxCamera"/>
	<c path="flixel.math.FlxRect"/>
</f></getScreenBounds>
		<isOnScreen public="1" set="method" line="203" override="1"><f a="?camera">
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></isOnScreen>
		<isFlippedOffsets public="1" set="method" line="209"><f a=""><x path="Bool"/></f></isFlippedOffsets>
		<__reversePreDrawProcedure expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__reversePreDrawProcedure>
		<preDraw public="1" set="method" line="213"><f a=""><x path="Void"/></f></preDraw>
		<postDraw public="1" set="method" line="226"><f a=""><x path="Void"/></f></postDraw>
		<ghostDraw public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</ghostDraw>
		<draw public="1" set="method" line="240" override="1"><f a=""><x path="Void"/></f></draw>
		<singAnims public="1" expr="[&quot;singLEFT&quot;, &quot;singDOWN&quot;, &quot;singUP&quot;, &quot;singRIGHT&quot;]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["singLEFT", "singDOWN", "singUP", "singRIGHT"]</e></m></meta>
		</singAnims>
		<getSingAnim public="1" get="inline" set="null" line="253">
			<f a="direction:?suffix" v=":&quot;&quot;">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ suffix : "" }</e></m></meta>
		</getSingAnim>
		<playSingAnim public="1" set="method" line="259">
			<f a="direction:?suffix:?Context:?Force:?Reversed:?Frame" v=":&quot;&quot;:SING:null:false:0">
				<x path="Int"/>
				<c path="String"/>
				<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Force : null, Context : SING, suffix : "" }</e></m></meta>
			<haxe_doc>* Like `playSingAnimUnsafe` but checks if the character has the animation with the suffix part, otherwise it plays the animation without the suffix part.</haxe_doc>
		</playSingAnim>
		<playSingAnimUnsafe public="1" set="method" line="267">
			<f a="direction:?suffix:?Context:?Force:?Reversed:?Frame" v=":&quot;&quot;:SING:true:false:0">
				<x path="Int"/>
				<c path="String"/>
				<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Force : true, Context : SING, suffix : "" }</e></m></meta>
		</playSingAnimUnsafe>
		<playAnim public="1" set="method" line="275" override="1">
			<f a="AnimName:?Force:?Context:?Reversed:?Frame" v="::NONE:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Context : NONE }</e></m></meta>
		</playAnim>
		<getCameraPosition public="1" get="inline" set="null" line="287"><f a=""><x path="flixel.math.FlxPoint"/></f></getCameraPosition>
		<destroy public="1" set="method" line="298" override="1"><f a=""><x path="Void"/></f></destroy>
		<__reverseTrailProcedure expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__reverseTrailProcedure>
		<beforeTrailCache public="1" set="dynamic" line="314"><f a=""><x path="Void"/></f></beforeTrailCache>
		<afterTrailCache public="1" set="dynamic" line="321"><f a=""><x path="Void"/></f></afterTrailCache>
		<applyXML public="1" set="method" line="327"><f a="xml">
	<x path="haxe.xml.Access"/>
	<x path="Void"/>
</f></applyXML>
		<buildCharacter public="1" get="inline" set="null" line="343"><f a="xml">
	<x path="haxe.xml.Access"/>
	<x path="Void"/>
</f></buildCharacter>
		<buildXML public="1" get="inline" set="null" line="418"><f a="?animsOrder">
	<c path="Array"><c path="String"/></c>
	<c path="Xml"/>
</f></buildXML>
		<getIcon public="1" get="inline" set="null" line="482"><f a=""><c path="String"/></f></getIcon>
		<getAnimOrder public="1" set="method" line="485"><f a=""><c path="Array"><c path="String"/></c></f></getAnimOrder>
		<set_stunned set="method" line="487">
			<f a="b">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_stunned>
		<danceInterval public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</danceInterval>
		<set_danceInterval set="method" line="496">
			<f a="v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_danceInterval>
		<get_danceInterval set="method" line="498">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_danceInterval>
		<set_script set="method" line="503"><f a="script">
	<c path="funkin.backend.scripting.Script"/>
	<c path="funkin.backend.scripting.Script"/>
</f></set_script>
		<new public="1" set="method" line="69">
			<f a="x:y:?character:?isPlayer:?switchAnims:?disableScripts" v=":::false:true:false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ disableScripts : false, switchAnims : true, isPlayer : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.desktop.editors.CharacterEditor</e></m>
			<m n=":allow"><e>funkin.game.StrumLine</e></m>
			<m n=":allow"><e>funkin.game.PlayState</e></m>
		</meta>
	</class>
	<class path="funkin.editors.character.CharacterGhost" params="" file="source/funkin/editors/character/CharacterGhost.hx">
		<extends path="funkin.game.Character"/>
		<ghosts public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</ghosts>
		<draw public="1" set="method" line="17" override="1"><f a=""><x path="Void"/></f></draw>
		<setAnimOffset public="1" set="method" line="63"><f a="anim">
	<c path="String"/>
	<x path="Void"/>
</f></setAnimOffset>
		<atlasState expr="null">
			<t path="funkin.editors.character.AtlasState"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</atlasState>
		<storeAtlasState public="1" set="method" line="75"><f a=""><t path="funkin.editors.character.AtlasState"/></f></storeAtlasState>
		<restoreAtlasState public="1" set="method" line="84">
			<f a="?state" v="null">
				<x path="Null"><t path="funkin.editors.character.AtlasState"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</restoreAtlasState>
		<new public="1" set="method" line="15"><f a="x:y:?character:?isPlayer:?switchAnims:?disableScripts">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterGizmos" params="" file="source/funkin/editors/character/CharacterGizmos.hx">
		<extends path="flixel.FlxSprite"/>
		<character public="1"><c path="funkin.game.Character"/></character>
		<boxGizmo public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</boxGizmo>
		<cameraGizmo public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</cameraGizmo>
		<draw public="1" set="method" line="13" override="1"><f a=""><x path="Void"/></f></draw>
		<drawHitbox public="1" set="method" line="22"><f a=""><x path="Void"/></f></drawHitbox>
		<drawCamera public="1" set="method" line="54"><f a=""><x path="Void"/></f></drawCamera>
		<new public="1" set="method" line="7"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.character.CharacterExtraInfo" params="" file="source/funkin/editors/character/CharacterInfoScreen.hx" module="funkin.editors.character.CharacterInfoScreen"><a>
	<iconColor><x path="Null"><x path="flixel.util.FlxColor"/></x></iconColor>
	<icon><c path="String"/></icon>
	<holdTime><x path="Float"/></holdTime>
	<customProperties><t path="Map">
	<c path="String"/>
	<d/>
</t></customProperties>
</a></typedef>
	<class path="funkin.editors.character.CharacterInfoScreen" params="" file="source/funkin/editors/character/CharacterInfoScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<character public="1"><c path="funkin.game.Character"/></character>
		<iconColorPicker public="1"><c path="funkin.editors.ui.UIIconColorPicker"/></iconColorPicker>
		<iconColorWheel public="1"><c path="funkin.editors.ui.UIColorwheel"/></iconColorWheel>
		<useDurationCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></useDurationCheckbox>
		<durationStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></durationStepper>
		<customPropertiesButtonList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.extra.PropertyButton"/></c></customPropertiesButtonList>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<onSave public="1" expr="null">
			<f a="info">
				<t path="funkin.editors.character.CharacterExtraInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<translate get="inline" set="null" line="44"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<create public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></create>
		<saveCharacterInfo public="1" set="method" line="107"><f a=""><x path="Void"/></f></saveCharacterInfo>
		<new public="1" set="method" line="37"><f a="character:onSave">
	<c path="funkin.game.Character"/>
	<f a="info">
		<t path="funkin.editors.character.CharacterExtraInfo"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterPropertiesWindow" params="" file="source/funkin/editors/character/CharacterPropertiesWindow.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<character public="1"><c path="funkin.game.Character"/></character>
		<animsWindow public="1"><c path="funkin.editors.character.CharacterAnimsWindow"/></animsWindow>
		<positionXStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></positionXStepper>
		<positionYStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></positionYStepper>
		<positionXYComma public="1"><c path="funkin.editors.ui.UIText"/></positionXYComma>
		<scaleStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></scaleStepper>
		<editCharacterButton public="1"><c path="funkin.editors.ui.UIButton"/></editCharacterButton>
		<editSpriteButton public="1"><c path="funkin.editors.ui.UIButton"/></editSpriteButton>
		<flipXCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></flipXCheckbox>
		<cameraXStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></cameraXStepper>
		<cameraYStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></cameraYStepper>
		<cameraXYComma public="1"><c path="funkin.editors.ui.UIText"/></cameraXYComma>
		<antialiasingCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></antialiasingCheckbox>
		<testAsDropDown public="1"><c path="funkin.editors.ui.UIDropDown"/></testAsDropDown>
		<designedAsDropDown public="1"><c path="funkin.editors.ui.UIDropDown"/></designedAsDropDown>
		<labels public="1" expr="[]">
			<t path="Map">
				<c path="funkin.editors.ui.UISprite"/>
				<c path="funkin.editors.ui.UIText"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</labels>
		<translate get="inline" set="null" line="31"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<changePosition public="1" set="method" line="120">
			<f a="newPosX:newPosY:?addToUndo" v="::true">
				<x path="Null"><x path="Float"/></x>
				<x path="Null"><x path="Float"/></x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changePosition>
		<changeScale public="1" set="method" line="141">
			<f a="newScale:?addToUndo" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeScale>
		<editCharacterInfoUI public="1" set="method" line="154"><f a=""><x path="Void"/></f></editCharacterInfoUI>
		<editCharacterInfo public="1" set="method" line="158">
			<f a="info:?addToUndo" v=":true">
				<t path="funkin.editors.character.CharacterExtraInfo"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</editCharacterInfo>
		<editCharacterSpriteUI public="1" set="method" line="174"><f a=""><x path="Void"/></f></editCharacterSpriteUI>
		<changeSprite public="1" set="method" line="180"><f a="sprite">
	<c path="String"/>
	<x path="Void"/>
</f></changeSprite>
		<changeFlipX public="1" set="method" line="220">
			<f a="newFlipX:?addToUndo" v=":true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeFlipX>
		<changeCamPosition public="1" set="method" line="230">
			<f a="newPosX:newPosY:?addToUndo" v="::true">
				<x path="Null"><x path="Float"/></x>
				<x path="Null"><x path="Float"/></x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeCamPosition>
		<changeAntialiasing public="1" set="method" line="249">
			<f a="newAntialiasing:?addToUndo" v=":true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</changeAntialiasing>
		<updateButtonsPos public="1" set="method" line="258"><f a=""><x path="Void"/></f></updateButtonsPos>
		<draw public="1" set="method" line="278" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="33"><f a="x:y:character">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.game.Character"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterSelection" params="" file="source/funkin/editors/character/CharacterSelection.hx">
		<extends path="funkin.editors.EditorTreeMenu"/>
		<create public="1" set="method" line="13" override="1"><f a=""><x path="Void"/></f></create>
		<new public="1" set="method" line="12"><f a="?exitCallback:?scriptsAllowed:?scriptName">
	<f a="">
		<c path="funkin.options.TreeMenu"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterSelectionScreen" params="" file="source/funkin/editors/character/CharacterSelection.hx" module="funkin.editors.character.CharacterSelection">
		<extends path="funkin.editors.EditorTreeMenuScreen"/>
		<modsList public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</modsList>
		<createCharacter public="1" set="method" line="62"><f a="name:imageSaveData:xml">
	<c path="String"/>
	<t path="funkin.editors.ui.ImageSaveData"/>
	<c path="Xml"/>
	<x path="Void"/>
</f></createCharacter>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.character.CharacterSpriteScreen" params="" file="source/funkin/editors/character/CharacterSpriteScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<idCounter public="1" expr="-1" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</idCounter>
		<imagePath expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</imagePath>
		<onSave expr="null">
			<f a=":">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<ogImageSaveData public="1"><t path="funkin.editors.ui.ImageSaveData"/></ogImageSaveData>
		<imageExplorer public="1"><c path="funkin.editors.ui.UIImageExplorer"/></imageExplorer>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<translate get="inline" set="null" line="20"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<create public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></create>
		<onLoadImage public="1" set="method" line="71"><f a=""><x path="Void"/></f></onLoadImage>
		<refreshWindowSize public="1" set="method" line="79"><f a=""><x path="Void"/></f></refreshWindowSize>
		<addToUndo public="1" get="inline" set="null" line="90"><f a=""><x path="Void"/></f></addToUndo>
		<new public="1" set="method" line="22"><f a="imagePath:?onSave">
	<c path="String"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.ChartCreationScreen" params="" file="source/funkin/editors/charter/ChartCreationScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<onSave expr="null">
			<f a=":">
				<c path="String"/>
				<t path="funkin.backend.chart.ChartData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<charFileList public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</charFileList>
		<difficultyNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></difficultyNameTextBox>
		<scrollSpeedTextBox public="1"><c path="funkin.editors.ui.UINumericStepper"/></scrollSpeedTextBox>
		<stageTextBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></stageTextBox>
		<strumLineList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.StrumLineButton"/></c></strumLineList>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<create public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="137" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<createChart public="1" set="method" line="143"><f a=""><x path="Void"/></f></createChart>
		<new public="1" set="method" line="23"><f a="?onSave">
	<f a=":">
		<c path="String"/>
		<t path="funkin.backend.chart.ChartData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.StrumLineButton" params="" file="source/funkin/editors/charter/ChartCreationScreen.hx" module="funkin.editors.charter.ChartCreationScreen">
		<extends path="funkin.editors.ui.UIButton"/>
		<idText public="1"><c path="funkin.editors.ui.UIText"/></idText>
		<charactersList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.CompactCharacterButton"/></c></charactersList>
		<typeDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></typeDropdown>
		<stagePositionDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></stagePositionDropdown>
		<hudScaleStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudScaleStepper>
		<hudXStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudXStepper>
		<hudYStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudYStepper>
		<visibleCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></visibleCheckbox>
		<scrollSpeedStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></scrollSpeedStepper>
		<usesChartScrollSpeed public="1"><c path="funkin.editors.ui.UICheckbox"/></usesChartScrollSpeed>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<labels public="1" expr="[]">
			<t path="Map">
				<c path="funkin.editors.ui.UISprite"/>
				<c path="funkin.editors.ui.UIText"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</labels>
		<XYComma public="1"><c path="funkin.editors.ui.UIText"/></XYComma>
		<cameraClipShader public="1"><c path="funkin.backend.shaders.CustomShader"/></cameraClipShader>
		<update public="1" set="method" line="285" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="198"><f a="id:strumLine:parent">
	<x path="Int"/>
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.StrumLineButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CompactCharacterButton" params="" file="source/funkin/editors/charter/ChartCreationScreen.hx" module="funkin.editors.charter.ChartCreationScreen">
		<extends path="funkin.editors.ui.UIButton"/>
		<charIcon public="1"><c path="funkin.game.HealthIcon"/></charIcon>
		<textBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></textBox>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="353" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="317"><f a="char:charsList:parent">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.CompactCharacterButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.ChartDataScreen" params="" file="source/funkin/editors/charter/ChartDataScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<data public="1"><t path="funkin.backend.chart.ChartData"/></data>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<scrollSpeedStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></scrollSpeedStepper>
		<stageTextBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></stageTextBox>
		<strumLineCam public="1"><c path="funkin.game.HudCamera"/></strumLineCam>
		<previewStrumLine public="1"><c path="funkin.editors.charter.CharterPreviewStrumLine"/></previewStrumLine>
		<create public="1" set="method" line="27" override="1"><f a=""><x path="Void"/></f></create>
		<saveInfo public="1" set="method" line="78"><f a=""><x path="Void"/></f></saveInfo>
		<update public="1" set="method" line="89" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="99" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="22"><f a="data">
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.Charter" params="" file="source/funkin/editors/charter/Charter.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<__song public="1" static="1"><c path="String"/></__song>
		<__diff static="1"><c path="String"/></__diff>
		<__reload static="1"><x path="Bool"/></__reload>
		<instance public="1" get="accessor" set="null" static="1"><c path="funkin.editors.charter.Charter"/></instance>
		<get_instance get="inline" set="null" line="43" static="1"><f a=""><c path="funkin.editors.charter.Charter"/></f></get_instance>
		<autoSaveTimer public="1" expr="0" line="101" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</autoSaveTimer>
		<selection public="1" static="1"><x path="funkin.editors.charter.Selection"/></selection>
		<playtestInfo public="1" static="1"><t path="funkin.editors.charter.PlaytestInfo"/></playtestInfo>
		<undos public="1" static="1"><c path="funkin.editors.UndoList"><e path="funkin.editors.charter.CharterChange"/></c></undos>
		<clipboard public="1" expr="[]" line="108" static="1">
			<c path="Array"><e path="funkin.editors.charter.CharterCopyboardObject"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</clipboard>
		<waveformHandler public="1" static="1"><c path="funkin.editors.charter.CharterWaveformHandler"/></waveformHandler>
		<startTime public="1" expr="0" line="1407" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</startTime>
		<startHere public="1" expr="false" line="1408" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</startHere>
		<saveEverything public="1" set="method" line="1474" static="1">
			<f a="?shouldBuild" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shouldBuild : true }</e></m></meta>
		</saveEverything>
		<saveChart public="1" set="method" line="1481" static="1">
			<f a="?shouldBuild:?withEvents" v="true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ withEvents : true, shouldBuild : true }</e></m></meta>
		</saveChart>
		<saveChartAs public="1" set="method" line="1491" static="1">
			<f a="?shouldBuild:?withEvents" v="true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ withEvents : true, shouldBuild : true }</e></m></meta>
		</saveChartAs>
		<saveEvents public="1" set="method" line="1498" static="1">
			<f a="?shouldBuild" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shouldBuild : true }</e></m></meta>
		</saveEvents>
		<saveEventsAs public="1" set="method" line="1512" static="1">
			<f a="?shouldBuild" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shouldBuild : true }</e></m></meta>
		</saveEventsAs>
		<saveMeta public="1" set="method" line="1521" static="1">
			<f a="?shouldBuild" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shouldBuild : true }</e></m></meta>
		</saveMeta>
		<saveMetaAs public="1" set="method" line="1534" static="1">
			<f a="?shouldBuild" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shouldBuild : true }</e></m></meta>
		</saveMetaAs>
		<saveLegacyChartAs public="1" set="method" line="1540" static="1">
			<f a="?shouldBuild" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shouldBuild : true }</e></m></meta>
		</saveLegacyChartAs>
		<savePsychChartAs public="1" set="method" line="1546" static="1">
			<f a="?shouldBuild" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shouldBuild : true }</e></m></meta>
		</savePsychChartAs>
		<saveAs public="1" set="method" line="1552" static="1">
			<f a="data:?replacer:?space:?options:?saveOptions:?shouldBuild" v=":::::true">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<x path="Null"><t path="funkin.editors.SaveSubstateData"/></x>
				<t path="Map">
					<c path="String"/>
					<x path="Bool"/>
				</t>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shouldBuild : true }</e></m></meta>
		</saveAs>
		<saveTo public="1" set="method" line="1563" static="1">
			<f a="path:?separateEvents:?shouldBuild" v=":false:true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shouldBuild : true, separateEvents : false }</e></m></meta>
		</saveTo>
		<chart get="accessor" set="null"><t path="funkin.backend.chart.ChartData"/></chart>
		<get_chart set="method" line="35"><f a=""><t path="funkin.backend.chart.ChartData"/></f></get_chart>
		<translate get="inline" set="null" line="38"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<charterBG public="1"><c path="funkin.backend.FunkinSprite"/></charterBG>
		<uiGroup public="1" expr="new FlxTypedGroup&lt;FlxSprite&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;FlxSprite&gt;()</e></m></meta>
		</uiGroup>
		<topMenu public="1"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></topMenu>
		<playbackIndex expr="7">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>7</e></m>
				<m n=":noCompletion"/>
			</meta>
		</playbackIndex>
		<snapIndex expr="6">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>6</e></m>
				<m n=":noCompletion"/>
			</meta>
		</snapIndex>
		<noteIndex expr="5">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>5</e></m>
				<m n=":noCompletion"/>
			</meta>
		</noteIndex>
		<songIndex expr="4">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>4</e></m>
				<m n=":noCompletion"/>
			</meta>
		</songIndex>
		<scrollBar public="1"><c path="funkin.editors.ui.UIScrollBar"/></scrollBar>
		<songPosInfo public="1"><c path="funkin.editors.ui.UIText"/></songPosInfo>
		<shouldScroll public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</shouldScroll>
		<quantButtons public="1" expr="[]">
			<c path="Array"><c path="funkin.editors.charter.CharterQuantButton"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</quantButtons>
		<playBackSlider public="1"><c path="funkin.editors.ui.UISlider"/></playBackSlider>
		<topMenuSpr public="1"><c path="funkin.editors.ui.UITopMenu"/></topMenuSpr>
		<gridBackdrops public="1"><c path="funkin.editors.charter.CharterBackdropGroup"/></gridBackdrops>
		<leftEventsBackdrop public="1"><c path="funkin.editors.charter.EventBackdrop"/></leftEventsBackdrop>
		<localAddEventSpr public="1"><c path="funkin.editors.charter.CharterEventAdd"/></localAddEventSpr>
		<rightEventsBackdrop public="1"><c path="funkin.editors.charter.EventBackdrop"/></rightEventsBackdrop>
		<globalAddEventSpr public="1"><c path="funkin.editors.charter.CharterEventAdd"/></globalAddEventSpr>
		<gridBackdropDummy public="1"><c path="funkin.editors.extra.CameraHoverDummy"/></gridBackdropDummy>
		<noteHoverer public="1"><c path="funkin.editors.charter.CharterNoteHoverer"/></noteHoverer>
		<noteDeleteAnims public="1"><c path="funkin.editors.charter.CharterDeleteAnim"/></noteDeleteAnims>
		<strumlineInfoBG public="1"><c path="flixel.FlxSprite"/></strumlineInfoBG>
		<strumlineAddButton public="1"><c path="funkin.editors.charter.CharterStrumlineButton"/></strumlineAddButton>
		<strumlineLockButton public="1"><c path="funkin.editors.charter.CharterStrumlineButton"/></strumlineLockButton>
		<hitsound public="1"><c path="flixel.sound.FlxSound"/></hitsound>
		<metronome public="1"><c path="flixel.sound.FlxSound"/></metronome>
		<vocals public="1"><c path="flixel.sound.FlxSound"/></vocals>
		<quant public="1" expr="16">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</quant>
		<quants public="1" expr="[4, 8, 12, 16, 20, 24, 32, 48, 64, 192]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[4, 8, 12, 16, 20, 24, 32, 48, 64, 192]</e></m></meta>
		</quants>
		<noteType public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</noteType>
		<noteTypes public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</noteTypes>
		<noteTypeText public="1"><c path="funkin.editors.ui.UIText"/></noteTypeText>
		<strumLines public="1" expr="new CharterStrumLineGroup()">
			<c path="funkin.editors.charter.CharterStrumLineGroup"/>
			<meta><m n=":value"><e>new CharterStrumLineGroup()</e></m></meta>
		</strumLines>
		<notesGroup public="1" expr="new CharterNoteGroup()">
			<c path="funkin.editors.charter.CharterNoteGroup"/>
			<meta><m n=":value"><e>new CharterNoteGroup()</e></m></meta>
		</notesGroup>
		<leftEventRowText public="1"><c path="funkin.editors.ui.UIText"/></leftEventRowText>
		<rightEventRowText public="1"><c path="funkin.editors.ui.UIText"/></rightEventRowText>
		<leftEventsGroup public="1" expr="new CharterEventGroup()">
			<c path="funkin.editors.charter.CharterEventGroup"/>
			<meta><m n=":value"><e>new CharterEventGroup()</e></m></meta>
		</leftEventsGroup>
		<rightEventsGroup public="1" expr="new CharterEventGroup()">
			<c path="funkin.editors.charter.CharterEventGroup"/>
			<meta><m n=":value"><e>new CharterEventGroup()</e></m></meta>
		</rightEventsGroup>
		<charterCamera public="1"><c path="flixel.FlxCamera"/></charterCamera>
		<uiCamera public="1"><c path="flixel.FlxCamera"/></uiCamera>
		<selectionBox public="1"><c path="funkin.editors.ui.UISliceSprite"/></selectionBox>
		<autoSaveNotif public="1"><c path="funkin.editors.charter.CharterAutoSaveUI"/></autoSaveNotif>
		<SONGPOSINFO_STEP expr="TU.getRaw(&quot;songPosInfo.step&quot;)">
			<c path="funkin.backend.utils.translations.IFormatInfo"/>
			<meta><m n=":value"><e>TU.getRaw("songPosInfo.step")</e></m></meta>
		</SONGPOSINFO_STEP>
		<SONGPOSINFO_BEAT expr="TU.getRaw(&quot;songPosInfo.beat&quot;)">
			<c path="funkin.backend.utils.translations.IFormatInfo"/>
			<meta><m n=":value"><e>TU.getRaw("songPosInfo.beat")</e></m></meta>
		</SONGPOSINFO_BEAT>
		<SONGPOSINFO_MEASURE expr="TU.getRaw(&quot;songPosInfo.measure&quot;)">
			<c path="funkin.backend.utils.translations.IFormatInfo"/>
			<meta><m n=":value"><e>TU.getRaw("songPosInfo.measure")</e></m></meta>
		</SONGPOSINFO_MEASURE>
		<SONGPOSINFO_BPM expr="TU.getRaw(&quot;songPosInfo.bpm&quot;)">
			<c path="funkin.backend.utils.translations.IFormatInfo"/>
			<meta><m n=":value"><e>TU.getRaw("songPosInfo.bpm")</e></m></meta>
		</SONGPOSINFO_BPM>
		<SONGPOSINFO_TIMESIGNATURE expr="TU.getRaw(&quot;songPosInfo.timeSignature&quot;)">
			<c path="funkin.backend.utils.translations.IFormatInfo"/>
			<meta><m n=":value"><e>TU.getRaw("songPosInfo.timeSignature")</e></m></meta>
		</SONGPOSINFO_TIMESIGNATURE>
		<create public="1" set="method" line="126" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="584" override="1"><f a=""><x path="Void"/></f></destroy>
		<loadSong public="1" set="method" line="595"><f a=""><x path="Void"/></f></loadSong>
		<__endStep public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__endStep>
		<refreshBPMSensitive public="1" set="method" line="673"><f a=""><x path="Void"/></f></refreshBPMSensitive>
		<getWavesToGenerate public="1" set="method" line="686"><f a=""><c path="Array"><a>
	<sound><c path="flixel.sound.FlxSound"/></sound>
	<name><c path="String"/></name>
</a></c></f></getWavesToGenerate>
		<updateWaveforms public="1" set="method" line="705"><f a=""><x path="Void"/></f></updateWaveforms>
		<beatHit public="1" set="method" line="739" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<gridActionType public="1" expr="NONE">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* NOTE AND CHARTER GRID LOGIC HERE</haxe_doc>
		</gridActionType>
		<dragStartPos public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</dragStartPos>
		<mousePos public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</mousePos>
		<selectionDragging public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selectionDragging>
		<isSelecting public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isSelecting>
		<updateSelectionLogic public="1" set="method" line="757"><f a=""><x path="Void"/></f></updateSelectionLogic>
		<__autoSaveLocation expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</__autoSaveLocation>
		<updateAutoSaving public="1" set="method" line="781"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateAutoSaving>
		<deletedNotes expr="new Selection()">
			<x path="funkin.editors.charter.Selection"/>
			<meta><m n=":value"><e>new Selection()</e></m></meta>
		</deletedNotes>
		<updateNoteLogic public="1" set="method" line="808"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateNoteLogic>
		<quantStep public="1" set="method" line="1060">
			<f a="step">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* NOTE DRAG HANDLING</haxe_doc>
		</quantStep>
		<quantStepRounded public="1" set="method" line="1065">
			<f a="step:?roundRatio" v=":0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ roundRatio : 0.5 }</e></m></meta>
		</quantStepRounded>
		<ratioRound public="1" set="method" line="1071"><f a="val:ratio">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></ratioRound>
		<getHoveredEvent public="1" set="method" line="1073"><f a="y:group">
	<x path="Float"/>
	<c path="funkin.editors.charter.CharterEventGroup"/>
	<c path="funkin.editors.charter.CharterEvent"/>
</f></getHoveredEvent>
		<deleteSingleSelection public="1" set="method" line="1085">
			<f a="selected:?addToUndo" v=":true">
				<c path="funkin.editors.charter.ICharterSelectable"/>
				<x path="Bool"/>
				<x path="Null"><c path="funkin.editors.charter.ICharterSelectable"/></x>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</deleteSingleSelection>
		<createSelection public="1" set="method" line="1107">
			<f a="selection:?addToUndo" v=":true">
				<x path="funkin.editors.charter.Selection"/>
				<x path="Bool"/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</createSelection>
		<deleteSelection public="1" set="method" line="1130">
			<f a="selection:?addToUndo" v=":true">
				<x path="funkin.editors.charter.Selection"/>
				<x path="Bool"/>
				<c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</deleteSelection>
		<updateEventsGroups public="1" set="method" line="1154"><f a="selection">
	<x path="funkin.editors.charter.Selection"/>
	<e path="funkin.editors.charter.CharterChange"/>
</f></updateEventsGroups>
		<createStrumline public="1" set="method" line="1175">
			<f a="strumLineID:strL:?addToUndo:?__createNotes" v="::true:true">
				<x path="Int"/>
				<t path="funkin.backend.chart.ChartStrumLine"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ __createNotes : true, addToUndo : true }</e></m></meta>
		</createStrumline>
		<deleteStrumline public="1" set="method" line="1198">
			<f a="strumLineID:?addToUndo" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</deleteStrumline>
		<getStrumlineID public="1" set="method" line="1227"><f a="strL">
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<x path="Int"/>
</f></getStrumlineID>
		<createStrumWithUI public="1" set="method" line="1235"><f a=""><x path="Void"/></f></createStrumWithUI>
		<deleteStrumlineFromData public="1" get="inline" set="null" line="1247"><f a="strL">
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<x path="Void"/>
</f></deleteStrumlineFromData>
		<editStrumline public="1" get="inline" set="null" line="1249"><f a="strL">
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<x path="Void"/>
</f></editStrumline>
		<removeStrumlineFromSelection public="1" get="inline" set="null" line="1264"><f a="strumLineID">
	<x path="Int"/>
	<x path="Void"/>
</f></removeStrumlineFromSelection>
		<__crochet><x path="Float"/></__crochet>
		<__firstFrame expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__firstFrame>
		<__timer expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__timer>
		<update public="1" set="method" line="1280" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateDisplaySprites set="method" line="1410"><f a=""><x path="Void"/></f></updateDisplaySprites>
		<onResize public="1" set="method" line="1438" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<zoom set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</zoom>
		<__camZoom set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</__camZoom>
		<set_zoom set="method" line="1460"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zoom>
		<set___camZoom set="method" line="1463"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set___camZoom>
		<sideScroll set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</sideScroll>
		<set_sideScroll set="method" line="1468"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_sideScroll>
		<_file_exit set="method" line="1572"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_exit>
		<_file_save_all set="method" line="1577"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_save_all>
		<_file_save set="method" line="1578"><f a="_">
	<d/>
	<x path="Void"/>
</f></_file_save>
		<_file_saveas set="method" line="1579"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas>
		<_file_events_save set="method" line="1580"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_events_save>
		<_file_events_saveas set="method" line="1581"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_events_saveas>
		<_file_save_no_events set="method" line="1582"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_save_no_events>
		<_file_saveas_no_events set="method" line="1583"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas_no_events>
		<_file_meta_save set="method" line="1584"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_meta_save>
		<_file_meta_saveas set="method" line="1585"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_meta_saveas>
		<_file_saveas_fnflegacy set="method" line="1586"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas_fnflegacy>
		<_file_saveas_psych set="method" line="1587"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas_psych>
		<_edit_copy set="method" line="1589">
			<f a="_:?playSFX" v=":true">
				<t path="funkin.editors.ui.UIContextMenuOption"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ playSFX : true }</e></m></meta>
		</_edit_copy>
		<_edit_paste set="method" line="1608"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_paste>
		<_edit_cut set="method" line="1636"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_cut>
		<_edit_delete set="method" line="1644"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_delete>
		<_undo set="method" line="1653"><f a="undo">
	<e path="funkin.editors.charter.CharterChange"/>
	<x path="Void"/>
</f></_undo>
		<_edit_undo set="method" line="1707"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_undo>
		<_redo set="method" line="1714"><f a="redo">
	<e path="funkin.editors.charter.CharterChange"/>
	<x path="Void"/>
</f></_redo>
		<_edit_redo set="method" line="1767"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_redo>
		<_chart_playtest get="inline" set="null" line="1775"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_chart_playtest>
		<_chart_playtest_here get="inline" set="null" line="1777"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_chart_playtest_here>
		<_chart_playtest_opponent get="inline" set="null" line="1779"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_chart_playtest_opponent>
		<_chart_playtest_opponent_here get="inline" set="null" line="1781"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_chart_playtest_opponent_here>
		<_chart_enablescripts set="method" line="1782"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_chart_enablescripts>
		<chart_edit_data set="method" line="1787"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></chart_edit_data>
		<chart_edit_metadata set="method" line="1789"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></chart_edit_metadata>
		<_playback_play set="method" line="1791"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_play>
		<_playback_speed_raise set="method" line="1807"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_speed_raise>
		<_playback_speed_reset set="method" line="1808"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_speed_reset>
		<_playback_speed_lower set="method" line="1809"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_speed_lower>
		<_playback_metronome set="method" line="1811"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_playback_metronome>
		<_song_muteinst set="method" line="1814"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_song_muteinst>
		<_song_mutevoices set="method" line="1818"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_song_mutevoices>
		<_playback_back set="method" line="1823"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_back>
		<_playback_forward set="method" line="1827"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_forward>
		<_playback_section_start set="method" line="1831"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_section_start>
		<_playback_back_step set="method" line="1835"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_back_step>
		<_playback_forward_step set="method" line="1839"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_playback_forward_step>
		<_song_start set="method" line="1843"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_song_start>
		<_song_end set="method" line="1847"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_song_end>
		<getBookmarkList public="1" set="method" line="1852"><f a=""><c path="Array"><t path="funkin.backend.chart.ChartBookmark"/></c></f></getBookmarkList>
		<_opponent_camera_add set="method" line="1862"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_opponent_camera_add>
		<_player_camera_add set="method" line="1876"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_player_camera_add>
		<_bookmarks_add set="method" line="1890"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_bookmarks_add>
		<_bookmarks_edit_list set="method" line="1912"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_bookmarks_edit_list>
		<__bookmarkObjects public="1" expr="[]">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__bookmarkObjects>
		<__scrollbarBookmarks public="1" expr="[]">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__scrollbarBookmarks>
		<updateBookmarks public="1" set="method" line="1917"><f a=""><x path="Void"/></f></updateBookmarks>
		<buildSongUI set="method" line="1988"><f a=""><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></f></buildSongUI>
		<_view_zoomin set="method" line="2056"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomin>
		<_view_zoomout set="method" line="2060"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomout>
		<_view_zoomreset set="method" line="2064"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomreset>
		<_view_showeventSecSeparator set="method" line="2068"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_view_showeventSecSeparator>
		<_view_showeventBeatSeparator set="method" line="2071"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_view_showeventBeatSeparator>
		<_view_switchWaveformRainbow set="method" line="2074"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_view_switchWaveformRainbow>
		<_view_switchWaveformDetail set="method" line="2080"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_view_switchWaveformDetail>
		<_view_scrollleft set="method" line="2085"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_scrollleft>
		<_view_scrollright set="method" line="2088"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_scrollright>
		<_view_scrollreset set="method" line="2091"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_scrollreset>
		<_snap_increasesnap get="inline" set="null" line="2095"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_snap_increasesnap>
		<_snap_decreasesnap get="inline" set="null" line="2096"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_snap_decreasesnap>
		<_snap_resetsnap get="inline" set="null" line="2097"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_snap_resetsnap>
		<changequant get="inline" set="null" line="2099"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changequant>
		<setquant get="inline" set="null" line="2100"><f a="newQuant">
	<x path="Int"/>
	<x path="Void"/>
</f></setquant>
		<buildSnapsUI set="method" line="2102"><f a=""><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></f></buildSnapsUI>
		<_note_addsustain get="inline" set="null" line="2135"><f a="t">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_note_addsustain>
		<_note_subtractsustain get="inline" set="null" line="2140"><f a="t">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_note_subtractsustain>
		<_note_selectall set="method" line="2145"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_note_selectall>
		<_note_selectmeasure set="method" line="2149"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_note_selectmeasure>
		<changeNoteSustain set="method" line="2156"><f a="change">
	<x path="Float"/>
	<x path="Void"/>
</f></changeNoteSustain>
		<changeNoteType public="1" get="inline" set="null" line="2171">
			<f a="?newID:?checkSelection" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkSelection : true }</e></m></meta>
		</changeNoteType>
		<editNoteTypesList set="method" line="2192"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></editNoteTypesList>
		<buildNoteTypesUI set="method" line="2194"><f a=""><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></f></buildNoteTypesUI>
		<playtestChart public="1" set="method" line="2249">
			<f a="?time:?opponentMode:?here" v="0:false:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ here : false, opponentMode : false, time : 0 }</e></m></meta>
		</playtestChart>
		<buildNote public="1" get="inline" set="null" line="2258"><f a="note">
	<c path="funkin.editors.charter.CharterNote"/>
	<t path="funkin.backend.chart.ChartNote"/>
</f></buildNote>
		<buildChart public="1" set="method" line="2268"><f a=""><x path="Void"/></f></buildChart>
		<buildEvents public="1" set="method" line="2284"><f a=""><x path="Void"/></f></buildEvents>
		<updateBPMEvents public="1" set="method" line="2298"><f a=""><x path="Void"/></f></updateBPMEvents>
		<checkSelectionForBPMUpdates public="1" get="inline" set="null" line="2325"><f a=""><x path="Void"/></f></checkSelectionForBPMUpdates>
		<hitsoundsEnabled public="1" get="inline" set="null" line="2334"><f a="id">
	<x path="Int"/>
	<x path="Bool"/>
</f></hitsoundsEnabled>
		<__fixSelection public="1" get="inline" set="null" line="2336"><f a="selection">
	<x path="funkin.editors.charter.Selection"/>
	<x path="funkin.editors.charter.Selection"/>
</f></__fixSelection>
		<__relinkSingleSelection public="1" set="method" line="2344">
			<f a="selectable">
				<c path="funkin.editors.charter.ICharterSelectable"/>
				<c path="funkin.editors.charter.ICharterSelectable"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__relinkSingleSelection>
		<__relinkSelection public="1" set="method" line="2354">
			<f a="selection">
				<x path="funkin.editors.charter.Selection"/>
				<x path="funkin.editors.charter.Selection"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__relinkSelection>
		<__relinkUndos public="1" get="inline" set="null" line="2361">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__relinkUndos>
		<__resetStatics public="1" set="method" line="2405">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__resetStatics>
		<__clearStatics public="1" set="method" line="2413">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__clearStatics>
		<__updatePlaytestInfo public="1" set="method" line="2418">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__updatePlaytestInfo>
		<__applyPlaytestInfo public="1" set="method" line="2431">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__applyPlaytestInfo>
		<new public="1" set="method" line="117">
			<f a="song:diff:?reload" v="::true">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ reload : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="funkin.editors.charter.CharterChange" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter">
		<CCreateStrumLine a="strumLineID:strumLine">
			<x path="Int"/>
			<t path="funkin.backend.chart.ChartStrumLine"/>
		</CCreateStrumLine>
		<CEditStrumLine a="strumLineID:oldStrumLine:newStrumLine">
			<x path="Int"/>
			<t path="funkin.backend.chart.ChartStrumLine"/>
			<t path="funkin.backend.chart.ChartStrumLine"/>
		</CEditStrumLine>
		<COrderStrumLine a="strumLineID:oldID:newID">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</COrderStrumLine>
		<CDeleteStrumLine a="strumLineID:strumLine">
			<x path="Int"/>
			<t path="funkin.backend.chart.ChartStrumLine"/>
		</CDeleteStrumLine>
		<CCreateSelection a="selection"><x path="funkin.editors.charter.Selection"/></CCreateSelection>
		<CDeleteSelection a="selection"><x path="funkin.editors.charter.Selection"/></CDeleteSelection>
		<CSelectionDrag a="selectionDrags"><c path="Array"><t path="funkin.editors.charter.SelectionDragChange"/></c></CSelectionDrag>
		<CEditSustains a="notes"><c path="Array"><t path="funkin.editors.charter.NoteSustainChange"/></c></CEditSustains>
		<CEditEvent a="event:oldEvents:newEvents">
			<c path="funkin.editors.charter.CharterEvent"/>
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
		</CEditEvent>
		<CEditEventGroups a="events"><c path="Array"><c path="funkin.editors.charter.CharterEvent"/></c></CEditEventGroups>
		<CEditChartData a="oldData:newData">
			<a>
				<stage><c path="String"/></stage>
				<speed><x path="Float"/></speed>
			</a>
			<a>
				<stage><c path="String"/></stage>
				<speed><x path="Float"/></speed>
			</a>
		</CEditChartData>
		<CEditNoteTypes a="oldArray:newArray">
			<c path="Array"><c path="String"/></c>
			<c path="Array"><c path="String"/></c>
		</CEditNoteTypes>
		<CEditBookmarks a="oldArray:newArray">
			<c path="Array"><t path="funkin.backend.chart.ChartBookmark"/></c>
			<c path="Array"><t path="funkin.backend.chart.ChartBookmark"/></c>
		</CEditBookmarks>
		<CEditSpecNotesType a="notes:oldNoteTypes:newNoteTypes">
			<c path="Array"><c path="funkin.editors.charter.CharterNote"/></c>
			<c path="Array"><x path="Int"/></c>
			<c path="Array"><x path="Int"/></c>
		</CEditSpecNotesType>
		<CChangeBundle a="changes"><c path="Array"><e path="funkin.editors.charter.CharterChange"/></c></CChangeBundle>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="funkin.editors.charter.CharterCopyboardObject" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter">
		<CNote a="step:id:strumLineID:susLength:type">
			<x path="Float"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Int"/>
		</CNote>
		<CEvent a="step:events:global">
			<x path="Float"/>
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
			<x path="Bool"/>
		</CEvent>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="funkin.editors.charter.NoteSustainChange" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter"><a>
	<note><c path="funkin.editors.charter.CharterNote"/></note>
	<before><x path="Float"/></before>
	<after><x path="Float"/></after>
</a></typedef>
	<typedef path="funkin.editors.charter.SelectionDragChange" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter"><a>
	<selectable><c path="funkin.editors.charter.ICharterSelectable"/></selectable>
	<change><x path="flixel.math.FlxPoint"/></change>
</a></typedef>
	<abstract path="funkin.editors.charter.Selection" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter">
		<from><icast><c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c></icast></from>
		<this><c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c></this>
		<to><icast><c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="funkin.editors.charter._Charter.Selection_Impl_" params="" file="source/funkin/editors/charter/Charter.hx" private="1" module="funkin.editors.charter.Charter" final="1">
	<_new public="1" get="inline" set="null" line="2485" static="1">
		<f a="?array">
			<c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c>
			<x path="funkin.editors.charter.Selection"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<loop public="1" get="inline" set="null" line="2489" static="1">
		<f a="this:onNote:?onEvent:?draggableOnly" v=":::true">
			<c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c>
			<f a="">
				<c path="funkin.editors.charter.CharterNote"/>
				<x path="Void"/>
			</f>
			<f a="">
				<c path="funkin.editors.charter.CharterEvent"/>
				<x path="Void"/>
			</f>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":value"><e>{ draggableOnly : true }</e></m></meta>
	</loop>
</class></impl>
	</abstract>
	<class path="funkin.editors.charter._Charter.Selection_Impl_" params="" file="source/funkin/editors/charter/Charter.hx" private="1" module="funkin.editors.charter.Charter" final="1">
		<_new public="1" get="inline" set="null" line="2485" static="1">
			<f a="?array">
				<c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c>
				<x path="funkin.editors.charter.Selection"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<loop public="1" get="inline" set="null" line="2489" static="1">
			<f a="this:onNote:?onEvent:?draggableOnly" v=":::true">
				<c path="Array"><c path="funkin.editors.charter.ICharterSelectable"/></c>
				<f a="">
					<c path="funkin.editors.charter.CharterNote"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="funkin.editors.charter.CharterEvent"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ draggableOnly : true }</e></m></meta>
		</loop>
	</class>
	<class path="funkin.editors.charter.ICharterSelectable" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter" interface="1">
		<set_x public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":noCompletion"/>
			</meta>
		</set_x>
		<set_y public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":noCompletion"/>
			</meta>
		</set_y>
		<x public="1" set="accessor"><x path="Float"/></x>
		<y public="1" set="accessor"><x path="Float"/></y>
		<ID public="1"><x path="Int"/></ID>
		<step public="1"><x path="Float"/></step>
		<selected public="1"><x path="Bool"/></selected>
		<hovered public="1"><x path="Bool"/></hovered>
		<draggable public="1"><x path="Bool"/></draggable>
		<snappedToGrid public="1"><x path="Bool"/></snappedToGrid>
		<handleSelection public="1" set="method"><f a="selectionBox">
	<c path="funkin.editors.ui.UISliceSprite"/>
	<x path="Bool"/>
</f></handleSelection>
		<handleDrag public="1" set="method"><f a="change">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></handleDrag>
	</class>
	<abstract path="funkin.editors.charter.CharterGridActionType" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.editors.charter._Charter.CharterGridActionType_Impl_" params="" file="source/funkin/editors/charter/Charter.hx" private="1" module="funkin.editors.charter.Charter" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="2515" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<BOX_SELECTION public="1" get="inline" set="null" expr="cast 1" line="2516" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BOX_SELECTION>
	<NOTE_DRAG public="1" get="inline" set="null" expr="cast 2" line="2517" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NOTE_DRAG>
	<INVALID_DRAG public="1" get="inline" set="null" expr="cast 3" line="2518" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</INVALID_DRAG>
	<SUSTAIN_DRAG public="1" get="inline" set="null" expr="cast 4" line="2519" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SUSTAIN_DRAG>
	<DELETE_SELECTION public="1" get="inline" set="null" expr="cast 5" line="2520" static="1">
		<x path="funkin.editors.charter.CharterGridActionType"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DELETE_SELECTION>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.editors.charter._Charter.CharterGridActionType_Impl_" params="" file="source/funkin/editors/charter/Charter.hx" private="1" module="funkin.editors.charter.Charter" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="2515" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<BOX_SELECTION public="1" get="inline" set="null" expr="cast 1" line="2516" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BOX_SELECTION>
		<NOTE_DRAG public="1" get="inline" set="null" expr="cast 2" line="2517" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NOTE_DRAG>
		<INVALID_DRAG public="1" get="inline" set="null" expr="cast 3" line="2518" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</INVALID_DRAG>
		<SUSTAIN_DRAG public="1" get="inline" set="null" expr="cast 4" line="2519" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SUSTAIN_DRAG>
		<DELETE_SELECTION public="1" get="inline" set="null" expr="cast 5" line="2520" static="1">
			<x path="funkin.editors.charter.CharterGridActionType"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DELETE_SELECTION>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="funkin.editors.charter.PlaytestInfo" params="" file="source/funkin/editors/charter/Charter.hx" module="funkin.editors.charter.Charter"><a>
	<waveforms><c path="Array"><x path="Int"/></c></waveforms>
	<strumlinesDraggable><x path="Bool"/></strumlinesDraggable>
	<songPosition><x path="Float"/></songPosition>
	<quantSelected><x path="Int"/></quantSelected>
	<playbackSpeed><x path="Float"/></playbackSpeed>
	<noteTypeSelected><x path="Int"/></noteTypeSelected>
	<mutedVocals><c path="Array"><x path="Bool"/></c></mutedVocals>
	<hitSounds><c path="Array"><x path="Bool"/></c></hitSounds>
</a></typedef>
	<class path="funkin.editors.charter.CharterAutoSaveUI" params="" file="source/funkin/editors/charter/CharterAutoSaveUI.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<icon public="1"><c path="flixel.FlxSprite"/></icon>
		<autosavingText public="1"><c path="funkin.editors.ui.UIText"/></autosavingText>
		<progressBarBack public="1"><c path="flixel.FlxSprite"/></progressBarBack>
		<progressBar public="1"><c path="flixel.FlxSprite"/></progressBar>
		<cancelButton public="1"><c path="funkin.editors.ui.UIButton"/></cancelButton>
		<cancelIcon public="1"><c path="flixel.FlxSprite"/></cancelIcon>
		<showedAnimation public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</showedAnimation>
		<cancelled public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</cancelled>
		<__timer><c path="flixel.util.FlxTimer"/></__timer>
		<__tween><c path="flixel.tweens.FlxTween"/></__tween>
		<startAutoSave public="1" set="method" line="67"><f a="time:successText">
	<x path="Float"/>
	<c path="String"/>
	<x path="Void"/>
</f></startAutoSave>
		<progress public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</progress>
		<update public="1" set="method" line="92" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<appearAnimation public="1" set="method" line="116"><f a=""><x path="Void"/></f></appearAnimation>
		<disappearAnimation public="1" set="method" line="127">
			<f a="?canned" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ canned : false }</e></m></meta>
		</disappearAnimation>
		<new public="1" set="method" line="21"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.FlxFastTypedGroup" params="T" file="source/funkin/editors/charter/CharterBackdropGroup.hx" module="funkin.editors.charter.CharterBackdropGroup">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.editors.charter.FlxFastTypedGroup.T"/></extends>
		<add public="1" set="method" line="15" override="1"><f a="Object">
	<c path="funkin.editors.charter.FlxFastTypedGroup.T"/>
	<c path="funkin.editors.charter.FlxFastTypedGroup.T"/>
</f></add>
		<new public="1" set="method" line="10">
			<f a="?maxSize" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maxSize : 0 }</e></m></meta>
		</new>
	</class>
	<class path="funkin.editors.charter.CharterBackdropGroup" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.editors.charter.CharterBackdrop"/></extends>
		<strumLineGroup public="1"><c path="funkin.editors.charter.CharterStrumLineGroup"/></strumLineGroup>
		<notesGroup public="1"><c path="funkin.editors.charter.CharterNoteGroup"/></notesGroup>
		<conductorSprY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</conductorSprY>
		<bottomLimitY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bottomLimitY>
		<strumlinesAmount public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</strumlinesAmount>
		<createGrids public="1" set="method" line="55">
			<f a="?amount" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ amount : 0 }</e></m></meta>
		</createGrids>
		<update public="1" set="method" line="63" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draggingObj public="1" expr="null">
			<c path="funkin.editors.charter.CharterBackdrop"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</draggingObj>
		<draw public="1" set="method" line="98" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="50"><f a="strumLineGroup">
	<c path="funkin.editors.charter.CharterStrumLineGroup"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.NotesDrawGroup" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx" module="funkin.editors.charter.CharterBackdropGroup">
		<extends path="funkin.editors.charter.FlxFastTypedGroup"><c path="funkin.editors.charter.CharterNote"/></extends>
		<draw public="1" set="method" line="129" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="128"><f a="?maxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterBackdrop" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx" module="funkin.editors.charter.CharterBackdropGroup">
		<extends path="flixel.group.FlxTypedGroup"><c path="flixel.FlxBasic"/></extends>
		<gridBackDrop public="1"><c path="flixel.addons.display.FlxBackdrop"/></gridBackDrop>
		<topLimit public="1"><c path="flixel.FlxSprite"/></topLimit>
		<topSeparator public="1"><c path="flixel.FlxSprite"/></topSeparator>
		<bottomLimit public="1"><c path="flixel.FlxSprite"/></bottomLimit>
		<bottomSeparator public="1"><c path="flixel.FlxSprite"/></bottomSeparator>
		<waveformSprite public="1"><c path="flixel.FlxSprite"/></waveformSprite>
		<conductorFollowerSpr public="1"><c path="flixel.FlxSprite"/></conductorFollowerSpr>
		<beatSeparator public="1"><c path="funkin.editors.charter.CharterGridSeperator"/></beatSeparator>
		<notesGroup public="1" expr="new NotesDrawGroup()">
			<c path="funkin.editors.charter.NotesDrawGroup"/>
			<meta><m n=":value"><e>new NotesDrawGroup()</e></m></meta>
		</notesGroup>
		<strumLine public="1"><c path="funkin.editors.charter.CharterStrumline"/></strumLine>
		<gridShader public="1" expr="new CustomShader(&quot;engine/charterGrid&quot;)">
			<c path="funkin.backend.shaders.CustomShader"/>
			<meta><m n=":value"><e>new CustomShader("engine/charterGrid")</e></m></meta>
		</gridShader>
		<__lastKeyCount expr="4">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</__lastKeyCount>
		<updateSprites public="1" set="method" line="241"><f a=""><x path="Void"/></f></updateSprites>
		<new public="1" set="method" line="181"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterGridSeperatorBase" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx" module="funkin.editors.charter.CharterBackdropGroup">
		<extends path="flixel.FlxSprite"/>
		<minStep expr="0" line="298" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</minStep>
		<maxStep expr="0" line="299" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</maxStep>
		<minBeat expr="0" line="301" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</minBeat>
		<maxBeat expr="0" line="302" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</maxBeat>
		<minMeasure expr="0" line="304" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</minMeasure>
		<maxMeasure expr="0" line="305" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</maxMeasure>
		<lastMinBeat expr="-1" line="307" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</lastMinBeat>
		<lastMaxBeat expr="-1" line="308" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</lastMaxBeat>
		<lastMinMeasure expr="-1" line="310" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</lastMinMeasure>
		<lastMaxMeasure expr="-1" line="311" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</lastMaxMeasure>
		<lastConductorSprY public="1" expr="Math.NEGATIVE_INFINITY" line="313" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.NEGATIVE_INFINITY</e></m></meta>
		</lastConductorSprY>
		<beatStepTimes expr="[]" line="315" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</beatStepTimes>
		<measureStepTimes expr="[]" line="316" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</measureStepTimes>
		<timeSignatureChangeGaps expr="[]" line="317" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</timeSignatureChangeGaps>
		<recalculateBeats set="method" line="319"><f a=""><x path="Void"/></f></recalculateBeats>
		<calculateTimeSignatureGaps get="inline" set="null" line="364"><f a=""><x path="Void"/></f></calculateTimeSignatureGaps>
		<calculateStepTimes get="inline" set="null" line="380"><f a=""><x path="Void"/></f></calculateStepTimes>
		<draw public="1" set="method" line="391" override="1"><f a=""><x path="Void"/></f></draw>
		<drawBeats set="method" line="402">
			<f a="?offset" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0.0 }</e></m></meta>
		</drawBeats>
		<drawMeasures set="method" line="408">
			<f a="?offset" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0.0 }</e></m></meta>
		</drawMeasures>
		<drawTimeSignatureChangeGaps set="method" line="414"><f a=""><x path="Void"/></f></drawTimeSignatureChangeGaps>
		<new public="1" set="method" line="296"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterGridSeperator" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx" module="funkin.editors.charter.CharterBackdropGroup">
		<extends path="funkin.editors.charter.CharterGridSeperatorBase"/>
		<drawBeats set="method" line="437" override="1">
			<f a="?offset" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0.0 }</e></m></meta>
		</drawBeats>
		<drawMeasures set="method" line="442" override="1">
			<f a="?offset" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0.0 }</e></m></meta>
		</drawMeasures>
		<new public="1" set="method" line="436"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.EventBackdrop" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx" module="funkin.editors.charter.CharterBackdropGroup">
		<extends path="flixel.addons.display.FlxBackdrop"/>
		<eventBeatSeparator public="1"><c path="funkin.editors.charter.CharterEventGridSeperator"/></eventBeatSeparator>
		<topSeparator public="1"><c path="flixel.FlxSprite"/></topSeparator>
		<bottomSeparator public="1"><c path="flixel.FlxSprite"/></bottomSeparator>
		<global public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</global>
		<draw public="1" set="method" line="485" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="457"><f a="global">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEventGridSeperator" params="" file="source/funkin/editors/charter/CharterBackdropGroup.hx" module="funkin.editors.charter.CharterBackdropGroup">
		<extends path="funkin.editors.charter.CharterGridSeperatorBase"/>
		<xPos public="1" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</xPos>
		<global public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</global>
		<drawBeats set="method" line="505" override="1">
			<f a="?offset" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0.0 }</e></m></meta>
		</drawBeats>
		<drawMeasures set="method" line="511" override="1">
			<f a="?offset" v="0.0">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0.0 }</e></m></meta>
		</drawMeasures>
		<drawTimeSignatureChangeGaps set="method" line="517" override="1"><f a=""><x path="Void"/></f></drawTimeSignatureChangeGaps>
		<new public="1" set="method" line="502"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterBookmarkCreation" params="" file="source/funkin/editors/charter/CharterBookmarkCreation.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<textBox public="1"><c path="funkin.editors.ui.UITextBox"/></textBox>
		<colorPicker public="1"><c path="funkin.editors.ui.UICompactColorwheel"/></colorPicker>
		<callback><f a=":::">
	<x path="Bool"/>
	<c path="String"/>
	<x path="flixel.util.FlxColor"/>
	<x path="Float"/>
	<x path="Void"/>
</f></callback>
		<bookmarkStep expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bookmarkStep>
		<create public="1" set="method" line="30" override="1"><f a=""><x path="Void"/></f></create>
		<new public="1" set="method" line="17"><f a="step:close">
	<x path="Float"/>
	<f a=":::">
		<x path="Bool"/>
		<c path="String"/>
		<x path="flixel.util.FlxColor"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterBookmarkList" params="" file="source/funkin/editors/charter/CharterBookmarkList.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<bookmarkList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.BookmarkButton"/></c></bookmarkList>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<create public="1" set="method" line="11" override="1"><f a=""><x path="Void"/></f></create>
		<saveList public="1" set="method" line="49"><f a=""><x path="Void"/></f></saveList>
		<new public="1" set="method" line="6"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.BookmarkButton" params="" file="source/funkin/editors/charter/CharterBookmarkList.hx" module="funkin.editors.charter.CharterBookmarkList">
		<extends path="funkin.editors.ui.UIButton"/>
		<textBox public="1"><c path="funkin.editors.ui.UITextBox"/></textBox>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<bookmark public="1"><t path="funkin.backend.chart.ChartBookmark"/></bookmark>
		<update public="1" set="method" line="85" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="65"><f a="x:y:bookmark:parent">
	<x path="Float"/>
	<x path="Float"/>
	<t path="funkin.backend.chart.ChartBookmark"/>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.BookmarkButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterNote" params="" file="source/funkin/editors/charter/CharterNote.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<implements path="funkin.editors.charter.ICharterSelectable"/>
		<colors expr="[0xFFC24B99, 0xFF00FFFF, 0xFF12FA05, 0xFFF9393F]" line="16" static="1">
			<c path="Array"><x path="flixel.util.FlxColor"/></c>
			<meta><m n=":value"><e>[0xFFC24B99, 0xFF00FFFF, 0xFF12FA05, 0xFFF9393F]</e></m></meta>
		</colors>
		<noteTypeTexts expr="[]" line="32" static="1">
			<c path="Array"><c path="funkin.editors.ui.UIText"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</noteTypeTexts>
		<angleTween><c path="flixel.tweens.FlxTween"/></angleTween>
		<__doAnim expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__doAnim>
		<__animSpeed expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</__animSpeed>
		<__susInstaLerp expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__susInstaLerp>
		<sustainSpr public="1"><c path="funkin.editors.ui.UISprite"/></sustainSpr>
		<tempSusLength public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tempSusLength>
		<sustainDraggable public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</sustainDraggable>
		<typeText public="1"><c path="funkin.editors.ui.UIText"/></typeText>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<draggable public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</draggable>
		<updateButtonHandler public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></updateButtonHandler>
		<step public="1"><x path="Float"/></step>
		<id public="1"><x path="Int"/></id>
		<susLength public="1"><x path="Float"/></susLength>
		<type public="1" set="accessor" expr="null">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</type>
		<typeVisible public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</typeVisible>
		<typeAlpha public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</typeAlpha>
		<set_type set="method" line="66"><f a="v">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_type>
		<strumLine public="1"><c path="funkin.editors.charter.CharterStrumline"/></strumLine>
		<strumLineID public="1" get="accessor" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</strumLineID>
		<get_strumLineID public="1" set="method" line="82"><f a=""><x path="Int"/></f></get_strumLineID>
		<snappedToGrid public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</snappedToGrid>
		<fullID public="1" get="accessor" set="null"><x path="Int"/></fullID>
		<get_fullID public="1" set="method" line="88"><f a=""><x path="Int"/></f></get_fullID>
		<updatePos public="1" set="method" line="90">
			<f a="step:id:?susLength:?type:?strumLine" v="::0:0:null">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="funkin.editors.charter.CharterStrumline"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ strumLine : null, type : 0, susLength : 0 }</e></m></meta>
		</updatePos>
		<kill public="1" set="method" line="130" override="1"><f a=""><x path="Void"/></f></kill>
		<__passed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__passed>
		<update public="1" set="method" line="147" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<handleSelection public="1" set="method" line="181"><f a="selectionBox">
	<c path="funkin.editors.ui.UISliceSprite"/>
	<x path="Bool"/>
</f></handleSelection>
		<handleDrag public="1" set="method" line="190"><f a="change">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></handleDrag>
		<draw public="1" set="method" line="198" override="1"><f a=""><x path="Void"/></f></draw>
		<drawNoteTypeText public="1" get="inline" set="null" line="207"><f a=""><x path="Void"/></f></drawNoteTypeText>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterDeleteAnim" params="" file="source/funkin/editors/charter/CharterDeleteAnim.hx">
		<extends path="funkin.editors.charter.CharterNote"/>
		<garbageIcon public="1"><c path="flixel.FlxSprite"/></garbageIcon>
		<garbageCircle public="1"><c path="flixel.FlxSprite"/></garbageCircle>
		<deleteNotes public="1" expr="[]">
			<c path="Array"><a>
	<time><x path="Float"/></time>
	<note><c path="funkin.editors.charter.CharterNote"/></note>
</a></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</deleteNotes>
		<deleteTime public="1" expr=".4">
			<x path="Float"/>
			<meta><m n=":value"><e>.4</e></m></meta>
		</deleteTime>
		<__garbageAlpha expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__garbageAlpha>
		<__deletionTimer expr=".1">
			<x path="Float"/>
			<meta><m n=":value"><e>.1</e></m></meta>
		</__deletionTimer>
		<__mousePos expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta>
				<m n=":value"><e>FlxPoint.get()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__mousePos>
		<update public="1" set="method" line="29" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="57" override="1"><f a=""><x path="Void"/></f></draw>
		<destroy public="1" set="method" line="87" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEvent" params="" file="source/funkin/editors/charter/CharterEvent.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<implements path="funkin.editors.charter.ICharterSelectable"/>
		<getPackData public="1" set="method" line="92" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Pack data is a list of 4 strings separated by `________PACKSEP________`
	 * [0] Event Name
	 * [1] Event Script
	 * [2] Event JSON Info
	 * [3] Event Icon
	 * [4] Event UI Script / Icon Script</haxe_doc>
		</getPackData>
		<getUIScript public="1" set="method" line="100" static="1">
			<f a="event:caller">
				<t path="funkin.backend.chart.ChartEvent"/>
				<c path="String"/>
				<c path="funkin.backend.scripting.Script"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</getUIScript>
		<generateDefaultIcon set="method" line="142" static="1">
			<f a="name">
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Generates the default event icon for the wanted event
	 * @param name The name of the event
	 * @return The icon</haxe_doc>
		</generateDefaultIcon>
		<getEventComponent public="1" set="method" line="184" static="1">
			<f a="type:?x:?y" v=":0.0:0.0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ y : 0.0, x : 0.0 }</e></m></meta>
			<haxe_doc>* Gets a component sprite from the editors/charter/event-icons/components folder
	 * If you wanna use a number, please use the EventNumber class instead
	 * @param type The type of component to get
	 * @param x The x position of the sprite (optional)
	 * @param y The y position of the sprite (optional)
	 * @return The component sprite</haxe_doc>
		</getEventComponent>
		<getIconFromStrumline public="1" set="method" line="196" static="1">
			<f a="index">
				<x path="Null"><x path="Int"/></x>
				<c path="funkin.game.HealthIcon"/>
			</f>
			<haxe_doc>* Expected to be called from inside of a ui script,
	 * calling this elsewhere might cause unexpected results or crashes</haxe_doc>
		</getIconFromStrumline>
		<getIconFromCharName public="1" set="method" line="204" static="1"><f a="name">
	<c path="String"/>
	<c path="funkin.game.HealthIcon"/>
</f></getIconFromCharName>
		<generateEventIcon public="1" set="method" line="213" static="1">
			<f a="event:?inMenu" v=":true">
				<t path="funkin.backend.chart.ChartEvent"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ inMenu : true }</e></m></meta>
		</generateEventIcon>
		<generateEventIconNumbers set="method" line="288" static="1">
			<f a="group:number:?x:?y:?spacing:?precision" v="::4:15:5:3">
				<c path="funkin.editors.charter.EventIconGroup"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ precision : 3, spacing : 5, y : 15, x : 4 }</e></m></meta>
		</generateEventIconNumbers>
		<generateEventIconDurationArrow set="method" line="299" static="1"><f a="group:stepDuration">
	<c path="funkin.editors.charter.EventIconGroup"/>
	<x path="Float"/>
	<x path="Void"/>
</f></generateEventIconDurationArrow>
		<generateEventIconWarning set="method" line="336" static="1"><f a="group">
	<c path="funkin.editors.charter.EventIconGroup"/>
	<x path="Void"/>
</f></generateEventIconWarning>
		<events public="1"><c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c></events>
		<step public="1"><x path="Float"/></step>
		<icons public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</icons>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<draggable public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</draggable>
		<eventsBackdrop public="1"><c path="funkin.editors.charter.EventBackdrop"/></eventsBackdrop>
		<snappedToGrid public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</snappedToGrid>
		<displayGlobal public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</displayGlobal>
		<global public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</global>
		<set_global set="method" line="32"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_global>
		<update public="1" set="method" line="48" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<selectedColorTransform get="inline" set="null" line="74">
			<f a="transform">
				<c path="openfl.geom.ColorTransform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</selectedColorTransform>
		<onHovered public="1" set="method" line="345" override="1"><f a=""><x path="Void"/></f></onHovered>
		<handleSelection public="1" set="method" line="353"><f a="selectionBox">
	<c path="funkin.editors.ui.UISliceSprite"/>
	<x path="Bool"/>
</f></handleSelection>
		<handleDrag public="1" set="method" line="357"><f a="change">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></handleDrag>
		<refreshEventIcons public="1" set="method" line="362"><f a=""><x path="Void"/></f></refreshEventIcons>
		<new public="1" set="method" line="37"><f a="step:?events:?global">
	<x path="Float"/>
	<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.EventIconGroup" params="" file="source/funkin/editors/charter/CharterEvent.hx" module="funkin.editors.charter.CharterEvent">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<forceWidth public="1" expr="16">
			<x path="Float"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</forceWidth>
		<forceHeight public="1" expr="16">
			<x path="Float"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</forceHeight>
		<dontTransformChildren public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dontTransformChildren>
		<copyColorTransformToChildren public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</copyColorTransformToChildren>
		<preAdd set="method" line="395" override="1"><f a="sprite">
	<c path="flixel.FlxSprite"/>
	<x path="Void"/>
</f></preAdd>
		<transformChildren public="1" params="V" set="method" line="401" override="1"><f a="Function:Value">
	<f a=":">
		<c path="flixel.FlxSprite"/>
		<c path="transformChildren.V"/>
		<x path="Void"/>
	</f>
	<c path="transformChildren.V"/>
	<x path="Void"/>
</f></transformChildren>
		<set_x set="method" line="409" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="416" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_width set="method" line="422" override="1"><f a=""><x path="Float"/></f></get_width>
		<get_height set="method" line="425" override="1"><f a=""><x path="Float"/></f></get_height>
		<draw public="1" set="method" line="429" override="1"><f a=""><x path="Void"/></f></draw>
		<update public="1" set="method" line="435" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="388"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.EventNumber" params="" file="source/funkin/editors/charter/CharterEvent.hx" module="funkin.editors.charter.CharterEvent">
		<extends path="flixel.FlxSprite"/>
		<ALIGN_NORMAL final="1" public="1" get="inline" set="null" expr="0" line="441" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ALIGN_NORMAL>
		<ALIGN_CENTER final="1" public="1" get="inline" set="null" expr="1" line="442" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ALIGN_CENTER>
		<FRAME_POINT final="1" public="1" get="inline" set="null" expr="10" line="445" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</FRAME_POINT>
		<FRAME_NEGATIVE final="1" public="1" get="inline" set="null" expr="11" line="446" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</FRAME_NEGATIVE>
		<digits public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</digits>
		<align public="1" expr="ALIGN_NORMAL">
			<x path="Int"/>
			<meta><m n=":value"><e>ALIGN_NORMAL</e></m></meta>
		</align>
		<spacing public="1" expr="6">
			<x path="Float"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</spacing>
		<update public="1" set="method" line="483" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="487" override="1"><f a=""><x path="Void"/></f></draw>
		<numWidth public="1" get="accessor" set="null"><x path="Float"/></numWidth>
		<get_numWidth set="method" line="502"><f a=""><x path="Float"/></f></get_numWidth>
		<numHeight public="1" get="accessor" set="null"><x path="Float"/></numHeight>
		<get_numHeight set="method" line="506"><f a=""><x path="Float"/></f></get_numHeight>
		<updateHitbox public="1" set="method" line="510" override="1"><f a=""><x path="Void"/></f></updateHitbox>
		<new public="1" set="method" line="451">
			<f a="x:y:number:?align:?spacing:?precision" v="::::6:3">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ precision : 3, spacing : 6 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEventAdd" params="" file="source/funkin/editors/charter/CharterEventAdd.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<text><c path="funkin.editors.ui.UIText"/></text>
		<sprAlpha public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</sprAlpha>
		<step public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</step>
		<curCharterEvent public="1" expr="null">
			<c path="funkin.editors.charter.CharterEvent"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curCharterEvent>
		<sideText public="1"><c path="funkin.editors.ui.UIText"/></sideText>
		<global public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</global>
		<onHovered public="1" set="method" line="27" override="1"><f a=""><x path="Void"/></f></onHovered>
		<update public="1" set="method" line="48" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updatePos public="1" set="method" line="60"><f a="step">
	<x path="Float"/>
	<x path="Void"/>
</f></updatePos>
		<updateEdit public="1" set="method" line="70"><f a="event">
	<c path="funkin.editors.charter.CharterEvent"/>
	<x path="Void"/>
</f></updateEdit>
		<new public="1" set="method" line="13"><f a="global">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEventGroup" params="" file="source/funkin/editors/charter/CharterEventGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.editors.charter.CharterEvent"/></extends>
		<stopThisFuckingShitDudeIstg public="1" expr="false" line="7" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stopThisFuckingShitDudeIstg>
		<eventsBackdrop public="1"><c path="funkin.editors.charter.EventBackdrop"/></eventsBackdrop>
		<eventsRowText public="1"><c path="funkin.editors.ui.UIText"/></eventsRowText>
		<autoSort public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoSort>
		<__lastSort expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__lastSort>
		<update public="1" set="method" line="14" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<remove public="1" set="method" line="23" override="1">
			<f a="v:?force" v=":true">
				<c path="funkin.editors.charter.CharterEvent"/>
				<x path="Bool"/>
				<c path="funkin.editors.charter.CharterEvent"/>
			</f>
			<meta><m n=":value"><e>{ force : true }</e></m></meta>
		</remove>
		<draw public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></draw>
		<sortEvents public="1" get="inline" set="null" line="37"><f a=""><x path="Void"/></f></sortEvents>
		<updateEventsIDs public="1" get="inline" set="null" line="45"><f a=""><x path="Void"/></f></updateEventsIDs>
		<updateEventsBackdrop public="1" get="inline" set="null" line="48"><f a=""><x path="Void"/></f></updateEventsBackdrop>
		<filterEvents public="1" get="inline" set="null" line="51"><f a=""><x path="Void"/></f></filterEvents>
		<sortEventsFilter public="1" set="dynamic" line="60"><f a="i:e1:e2">
	<x path="Int"/>
	<c path="funkin.editors.charter.CharterEvent"/>
	<c path="funkin.editors.charter.CharterEvent"/>
	<x path="Int"/>
</f></sortEventsFilter>
		<new public="1" set="method" line="6"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEventScreen" params="" file="source/funkin/editors/charter/CharterEventScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<chartEvent public="1"><c path="funkin.editors.charter.CharterEvent"/></chartEvent>
		<step public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</step>
		<events public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</events>
		<eventsList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.EventButton"/></c></eventsList>
		<eventName public="1"><c path="funkin.editors.ui.UIText"/></eventName>
		<paramsPanel public="1"><t path="flixel.group.FlxGroup"/></paramsPanel>
		<paramsFields public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxBasic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</paramsFields>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<global public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</global>
		<create public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></create>
		<curEvent public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</curEvent>
		<changeTab public="1" set="method" line="110">
			<f a="id:?save" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ save : true }</e></m></meta>
		</changeTab>
		<saveCurTab public="1" set="method" line="215"><f a=""><x path="Void"/></f></saveCurTab>
		<new public="1" set="method" line="31"><f a="step:global:?chartEvent">
	<x path="Float"/>
	<x path="Bool"/>
	<c path="funkin.editors.charter.CharterEvent"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.editors.charter.EventButton" params="" file="source/funkin/editors/charter/CharterEventScreen.hx" module="funkin.editors.charter.CharterEventScreen">
		<extends path="funkin.editors.ui.UIButton"/>
		<icon public="1" expr="null">
			<c path="flixel.FlxSprite"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</icon>
		<event public="1" expr="null">
			<t path="funkin.backend.chart.ChartEvent"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</event>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="287" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="260"><f a="event:icon:id:substate:parent">
	<t path="funkin.backend.chart.ChartEvent"/>
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<c path="funkin.editors.charter.CharterEventScreen"/>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.EventButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEventScreenNew" params="" file="source/funkin/editors/charter/CharterEventScreenNew.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<cam public="1"><c path="flixel.FlxCamera"/></cam>
		<eventCam public="1"><c path="flixel.FlxCamera"/></eventCam>
		<chartEvent public="1"><c path="funkin.editors.charter.CharterEvent"/></chartEvent>
		<events public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</events>
		<eventsList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.EventButtonNew"/></c></eventsList>
		<eventName public="1"><c path="funkin.editors.ui.UIText"/></eventName>
		<paramsPanel public="1"><t path="flixel.group.FlxGroup"/></paramsPanel>
		<paramsFields public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxBasic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</paramsFields>
		<downIndicator public="1"><c path="funkin.editors.ui.UIText"/></downIndicator>
		<bWidth public="1"><x path="Float"/></bWidth>
		<bg><c path="funkin.editors.ui.UISliceSprite"/></bg>
		<create public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></create>
		<curEvent public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</curEvent>
		<winHeight public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</winHeight>
		<changeTab public="1" set="method" line="107">
			<f a="id:?save" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ save : true }</e></m></meta>
		</changeTab>
		<boundWindow public="1" set="method" line="217"><f a=""><x path="Void"/></f></boundWindow>
		<__clickedWhileHovering expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__clickedWhileHovering>
		<__ignoreLastClick expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__ignoreLastClick>
		<sinner expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</sinner>
		<update public="1" set="method" line="246" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<quit public="1" set="method" line="286"><f a=""><x path="Void"/></f></quit>
		<saveCurTab public="1" set="method" line="303"><f a=""><x path="Void"/></f></saveCurTab>
		<destroy public="1" set="method" line="332" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="32"><f a="?chartEvent">
	<c path="funkin.editors.charter.CharterEvent"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.EventButtonNew" params="" file="source/funkin/editors/charter/CharterEventScreenNew.hx" module="funkin.editors.charter.CharterEventScreenNew">
		<extends path="funkin.editors.ui.UIButton"/>
		<icon public="1" expr="null">
			<c path="flixel.FlxSprite"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</icon>
		<event public="1" expr="null">
			<t path="funkin.backend.chart.ChartEvent"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</event>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="372" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="345"><f a="event:icon:id:substate:parent">
	<t path="funkin.backend.chart.ChartEvent"/>
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<c path="funkin.editors.charter.CharterEventScreenNew"/>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.EventButtonNew"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterEventTypeSelection" params="" file="source/funkin/editors/charter/CharterEventTypeSelection.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<callback><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></callback>
		<eventStepTime><x path="Float"/></eventStepTime>
		<buttons expr="[]">
			<c path="Array"><c path="funkin.editors.ui.UIButton"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</buttons>
		<buttonsBG><c path="funkin.editors.ui.UISliceSprite"/></buttonsBG>
		<buttonCameras><c path="flixel.FlxCamera"/></buttonCameras>
		<upIndicator><c path="funkin.editors.ui.UIText"/></upIndicator>
		<downIndicator><c path="funkin.editors.ui.UIText"/></downIndicator>
		<create public="1" set="method" line="24" override="1"><f a=""><x path="Void"/></f></create>
		<sinner expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</sinner>
		<update public="1" set="method" line="98" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="121" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="18"><f a="callback:eventStepTime">
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterMetaDataScreen" params="" file="source/funkin/editors/charter/CharterMetaDataScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<metadata public="1"><t path="funkin.backend.chart.ChartMetaData"/></metadata>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<songNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></songNameTextBox>
		<bpmStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></bpmStepper>
		<beatsPerMeasureStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></beatsPerMeasureStepper>
		<denominatorStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></denominatorStepper>
		<customPropertiesButtonList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.extra.PropertyButton"/></c></customPropertiesButtonList>
		<displayNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></displayNameTextBox>
		<iconTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></iconTextBox>
		<iconSprite public="1"><c path="funkin.game.HealthIcon"/></iconSprite>
		<opponentModeCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></opponentModeCheckbox>
		<coopAllowedCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></coopAllowedCheckbox>
		<colorWheel public="1"><c path="funkin.editors.ui.UIColorwheel"/></colorWheel>
		<difficultiesTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></difficultiesTextBox>
		<translate get="inline" set="null" line="35"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></translate>
		<create public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></create>
		<updateIcon set="method" line="130"><f a="icon">
	<c path="String"/>
	<x path="Void"/>
</f></updateIcon>
		<saveMeta public="1" set="method" line="141"><f a=""><x path="Void"/></f></saveMeta>
		<new public="1" set="method" line="29"><f a="metadata">
	<t path="funkin.backend.chart.ChartMetaData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterNoteGroup" params="" file="source/funkin/editors/charter/CharterNoteGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.editors.charter.CharterNote"/></extends>
		<getVar set="method" line="52" static="1"><f a="n">
	<c path="funkin.editors.charter.CharterNote"/>
	<x path="Float"/>
</f></getVar>
		<getVarForEachAdd set="method" line="55" static="1"><f a="n">
	<c path="funkin.editors.charter.CharterNote"/>
	<x path="Float"/>
</f></getVarForEachAdd>
		<getVarForEachRemove set="method" line="57" static="1"><f a="n">
	<c path="funkin.editors.charter.CharterNote"/>
	<x path="Float"/>
</f></getVarForEachRemove>
		<__loopSprite><c path="funkin.editors.charter.CharterNote"/></__loopSprite>
		<i expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</i>
		<max expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</max>
		<__currentlyLooping expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__currentlyLooping>
		<autoSort public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoSort>
		<__lastSort expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__lastSort>
		<forEach public="1" set="method" line="15" override="1">
			<f a="noteFunc:?recursive" v=":false">
				<f a="">
					<c path="funkin.editors.charter.CharterNote"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
		</forEach>
		<add public="1" set="method" line="41" override="1"><f a="v">
	<c path="funkin.editors.charter.CharterNote"/>
	<c path="funkin.editors.charter.CharterNote"/>
</f></add>
		<remove public="1" set="method" line="46" override="1">
			<f a="v:?force" v=":true">
				<c path="funkin.editors.charter.CharterNote"/>
				<x path="Bool"/>
				<c path="funkin.editors.charter.CharterNote"/>
			</f>
			<meta><m n=":value"><e>{ force : true }</e></m></meta>
		</remove>
		<draw public="1" set="method" line="59" override="1"><f a=""><x path="Void"/></f></draw>
		<update public="1" set="method" line="61" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<sortNotes public="1" set="method" line="78"><f a=""><x path="Void"/></f></sortNotes>
		<updateNoteIDs public="1" get="inline" set="null" line="89"><f a=""><x path="Void"/></f></updateNoteIDs>
		<preallocate public="1" get="inline" set="null" line="91"><f a="len">
	<x path="Int"/>
	<x path="Void"/>
</f></preallocate>
		<new public="1" set="method" line="6"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterNoteHoverer" params="" file="source/funkin/editors/charter/CharterNoteHoverer.hx">
		<extends path="funkin.editors.charter.CharterNote"/>
		<showHoverer public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</showHoverer>
		<__mousePos expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta>
				<m n=":value"><e>FlxPoint.get()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__mousePos>
		<update public="1" set="method" line="14" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="39" override="1"><f a=""><x path="Void"/></f></draw>
		<destroy public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterNoteTypesList" params="" file="source/funkin/editors/charter/CharterNoteTypesList.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<pathString public="1" expr="&quot;data/notes/&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"data/notes/"</e></m></meta>
		</pathString>
		<noteTypesList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.NoteTypeButton"/></c></noteTypesList>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<create public="1" set="method" line="13" override="1"><f a=""><x path="Void"/></f></create>
		<getNoteTypesList public="1" set="method" line="52">
			<f a="?mods" v="false">
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ mods : false }</e></m></meta>
		</getNoteTypesList>
		<saveList public="1" set="method" line="62"><f a=""><x path="Void"/></f></saveList>
		<new public="1" set="method" line="6"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.NoteTypeButton" params="" file="source/funkin/editors/charter/CharterNoteTypesList.hx" module="funkin.editors.charter.CharterNoteTypesList">
		<extends path="funkin.editors.ui.UIButton"/>
		<IDText public="1"><c path="funkin.editors.ui.UIText"/></IDText>
		<noteSpr public="1"><c path="flixel.FlxSprite"/></noteSpr>
		<textBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></textBox>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<updateNote public="1" set="method" line="107"><f a="notetype">
	<c path="String"/>
	<x path="Void"/>
</f></updateNote>
		<update public="1" set="method" line="122" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="80"><f a="x:y:name:noteID:suggestList:parent">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="Array"><c path="String"/></c>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.NoteTypeButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterPreviewStrumLine" params="" file="source/funkin/editors/charter/CharterPreviewStrumLine.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></extends>
		<note><c path="flixel.FlxSprite"/></note>
		<generateStrums public="1" set="method" line="14"><f a="x:y:scale:spacing:keyCount:scrollSpeed">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></generateStrums>
		<noteTime expr="FlxG.height">
			<x path="Float"/>
			<meta><m n=":value"><e>FlxG.height</e></m></meta>
		</noteTime>
		<scroll expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</scroll>
		<updatePos public="1" set="method" line="47"><f a="x:y:scale:spacing:keyCount:scrollSpeed">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updatePos>
		<new public="1" set="method" line="7"><f a="x:y:scale:spacing:keyCount:scrollSpeed">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UITopMenuButton" params="" file="source/funkin/editors/ui/UITopMenu.hx" module="funkin.editors.ui.UITopMenu">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<label public="1"><c path="funkin.editors.ui.UIText"/></label>
		<contextMenu public="1"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></contextMenu>
		<parent public="1"><c path="funkin.editors.ui.UITopMenu"/></parent>
		<curMenu public="1" expr="null">
			<c path="funkin.editors.ui.UIContextMenu"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curMenu>
		<justClosed expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</justClosed>
		<autoAnim expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoAnim>
		<update public="1" set="method" line="60" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onHovered public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></onHovered>
		<openContextMenu public="1" set="method" line="96"><f a=""><x path="Void"/></f></openContextMenu>
		<new public="1" set="method" line="45"><f a="x:y:parent:label:contextMenu">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.editors.ui.UITopMenu"/>
	<c path="String"/>
	<c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UITopButton" params="" file="source/funkin/editors/ui/UITopMenu.hx" module="funkin.editors.ui.UITopMenu">
		<extends path="funkin.editors.ui.UITopMenuButton"/>
		<onClick public="1"><f a=""><x path="Void"/></f></onClick>
		<update public="1" set="method" line="111" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<openContextMenu public="1" set="method" line="117" override="1"><f a=""><x path="Void"/></f></openContextMenu>
		<new public="1" set="method" line="109"><f a="x:y:name">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.editors.charter.CharterQuantButton" params="" file="source/funkin/editors/charter/CharterQuantButton.hx">
		<extends path="funkin.editors.ui.UITopButton"/>
		<quant public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</quant>
		<new public="1" set="method" line="5"><f a="x:y:quant">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterSelection" params="" file="source/funkin/editors/charter/CharterSelection.hx">
		<extends path="funkin.editors.EditorTreeMenu"/>
		<create public="1" set="method" line="15" override="1"><f a=""><x path="Void"/></f></create>
		<new public="1" set="method" line="14"><f a="?exitCallback:?scriptsAllowed:?scriptName">
	<f a="">
		<c path="funkin.options.TreeMenu"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterSelectionScreen" params="" file="source/funkin/editors/charter/CharterSelection.hx" module="funkin.editors.charter.CharterSelection">
		<extends path="funkin.editors.EditorTreeMenuScreen"/>
		<freeplayList public="1"><c path="funkin.menus.FreeplaySonglist"/></freeplayList>
		<songList public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</songList>
		<curSong public="1"><t path="funkin.backend.chart.ChartMetaData"/></curSong>
		<makeChartOption public="1" get="inline" set="null" line="28"><f a="d:name">
	<c path="String"/>
	<c path="String"/>
	<c path="funkin.options.type.TextOption"/>
</f></makeChartOption>
		<makeSongOption public="1" set="method" line="32"><f a="s">
	<t path="funkin.backend.chart.ChartMetaData"/>
	<c path="funkin.options.type.IconOption"/>
</f></makeSongOption>
		<saveSong public="1" set="method" line="67"><f a="creation:?callback">
	<t path="funkin.editors.charter.SongCreationData"/>
	<f a=":">
		<c path="String"/>
		<t path="funkin.editors.charter.SongCreationData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></saveSong>
		<saveChart public="1" set="method" line="100"><f a="name:data">
	<c path="String"/>
	<t path="funkin.backend.chart.ChartData"/>
	<x path="Void"/>
</f></saveChart>
		<new public="1" set="method" line="57"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterStrumLineGroup" params="" file="source/funkin/editors/charter/CharterStrumLineGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.editors.charter.CharterStrumline"/></extends>
		<__pastStrumlines><c path="Array"><c path="funkin.editors.charter.CharterStrumline"/></c></__pastStrumlines>
		<draggingObj expr="null">
			<c path="funkin.editors.charter.CharterStrumline"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</draggingObj>
		<draggingOffset expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</draggingOffset>
		<totalKeyCount public="1" get="accessor" set="null"><x path="Int"/></totalKeyCount>
		<__totalKeyCount expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</__totalKeyCount>
		<get_totalKeyCount public="1" set="method" line="13"><f a=""><x path="Int"/></f></get_totalKeyCount>
		<draggable public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</draggable>
		<isDragging public="1" get="accessor" set="null"><x path="Bool"/></isDragging>
		<get_isDragging public="1" set="method" line="24"><f a=""><x path="Bool"/></f></get_isDragging>
		<__mousePos expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</__mousePos>
		<update public="1" set="method" line="28" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<snapStrums public="1" set="method" line="79"><f a=""><x path="Void"/></f></snapStrums>
		<orderStrumline public="1" set="method" line="84"><f a="strumLine:newID">
	<c path="funkin.editors.charter.CharterStrumline"/>
	<x path="Int"/>
	<x path="Void"/>
</f></orderStrumline>
		<finishDrag public="1" set="method" line="94">
			<f a="?addToUndo" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ addToUndo : true }</e></m></meta>
		</finishDrag>
		<fixEvents public="1" get="inline" set="null" line="110"><f a=""><x path="Void"/></f></fixEvents>
		<refreshStrumlineIDs public="1" get="inline" set="null" line="125"><f a=""><x path="Void"/></f></refreshStrumlineIDs>
		<getStrumlineFromID public="1" set="method" line="131"><f a="id">
	<x path="Int"/>
	<c path="funkin.editors.charter.CharterStrumline"/>
</f></getStrumlineFromID>
		<draw public="1" set="method" line="140" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="6"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterStrumline" params="" file="source/funkin/editors/charter/CharterStrumline.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<strumLine public="1"><t path="funkin.backend.chart.ChartStrumLine"/></strumLine>
		<hitsounds public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</hitsounds>
		<draggingSprite public="1"><c path="funkin.editors.ui.UISprite"/></draggingSprite>
		<healthIcons public="1"><t path="flixel.group.FlxSpriteGroup"/></healthIcons>
		<button public="1"><c path="funkin.editors.charter.CharterStrumlineOptions"/></button>
		<draggable public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</draggable>
		<dragging public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dragging>
		<curMenu public="1" expr="null">
			<c path="funkin.editors.ui.UIContextMenu"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curMenu>
		<vocals public="1"><c path="flixel.sound.FlxSound"/></vocals>
		<keyCount public="1" expr="4">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</keyCount>
		<startingID public="1" get="accessor" set="null"><x path="Int"/></startingID>
		<__startingID expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</__startingID>
		<get_startingID public="1" set="method" line="29"><f a=""><x path="Int"/></f></get_startingID>
		<selectedWaveform public="1" set="accessor" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</selectedWaveform>
		<set_selectedWaveform public="1" set="method" line="41"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_selectedWaveform>
		<waveformShader public="1"><c path="funkin.backend.shaders.CustomShader"/></waveformShader>
		<__healthYOffset expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__healthYOffset>
		<__draggingYOffset expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__draggingYOffset>
		<update public="1" set="method" line="99" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateInfo public="1" set="method" line="119"><f a=""><x path="Void"/></f></updateInfo>
		<new public="1" set="method" line="51"><f a="strumLine">
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterStrumlineOptions" params="" file="source/funkin/editors/charter/CharterStrumline.hx" module="funkin.editors.charter.CharterStrumline">
		<extends path="funkin.editors.ui.UITopMenuButton"/>
		<strLine><c path="funkin.editors.charter.CharterStrumline"/></strLine>
		<update public="1" set="method" line="160" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<openContextMenu public="1" set="method" line="167" override="1"><f a=""><x path="Void"/></f></openContextMenu>
		<new public="1" set="method" line="154"><f a="parent">
	<c path="funkin.editors.charter.CharterStrumline"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterStrumlineButton" params="" file="source/funkin/editors/charter/CharterStrumlineButton.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<button public="1"><c path="funkin.editors.ui.UISprite"/></button>
		<text public="1"><c path="funkin.editors.ui.UIText"/></text>
		<onClick public="1"><f a=""><x path="Void"/></f></onClick>
		<animationOnClick public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</animationOnClick>
		<buttonScale expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</buttonScale>
		<buttonScaleOffset expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</buttonScaleOffset>
		<buttonYOffset expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</buttonYOffset>
		<jumpTween><c path="flixel.tweens.FlxTween"/></jumpTween>
		<scaleTween><c path="flixel.tweens.FlxTween"/></scaleTween>
		<angleTween><c path="flixel.tweens.FlxTween"/></angleTween>
		<shakeTimer expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</shakeTimer>
		<textTweenColor public="1"><c path="funkin.backend.utils.FlxInterpolateColor"/></textTweenColor>
		<textColorLerp public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</textColorLerp>
		<update public="1" set="method" line="50" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="81" override="1"><f a=""><x path="Void"/></f></destroy>
		<pressAnimation public="1" set="method" line="88">
			<f a="?extra" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ extra : false }</e></m></meta>
		</pressAnimation>
		<new public="1" set="method" line="13"><f a="imagePath:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterStrumlineScreen" params="" file="source/funkin/editors/charter/CharterStrumlineScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<strumLineID public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</strumLineID>
		<strumLine public="1"><t path="funkin.backend.chart.ChartStrumLine"/></strumLine>
		<charactersList public="1"><c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.CharacterButton"/></c></charactersList>
		<typeDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></typeDropdown>
		<vocalsSuffixDropDown public="1"><c path="funkin.editors.ui.UIDropDown"/></vocalsSuffixDropDown>
		<stagePositionDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></stagePositionDropdown>
		<hudScaleStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudScaleStepper>
		<hudXStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudXStepper>
		<hudYStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudYStepper>
		<visibleCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></visibleCheckbox>
		<scrollSpeedStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></scrollSpeedStepper>
		<usesChartScrollSpeed public="1"><c path="funkin.editors.ui.UICheckbox"/></usesChartScrollSpeed>
		<keyCountStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></keyCountStepper>
		<hudSpacingStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></hudSpacingStepper>
		<characterIcons public="1" expr="[]">
			<c path="Array"><c path="funkin.game.HealthIcon"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</characterIcons>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<strumLineCam public="1"><c path="funkin.game.HudCamera"/></strumLineCam>
		<previewStrumLine public="1"><c path="funkin.editors.charter.CharterPreviewStrumLine"/></previewStrumLine>
		<onSave expr="null">
			<f a="">
				<t path="funkin.backend.chart.ChartStrumLine"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<create public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></create>
		<saveStrumline set="method" line="195"><f a=""><x path="Void"/></f></saveStrumline>
		<update public="1" set="method" line="218" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="231" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="39"><f a="strumLineID:strumLine:?onSave">
	<x path="Int"/>
	<t path="funkin.backend.chart.ChartStrumLine"/>
	<f a="">
		<t path="funkin.backend.chart.ChartStrumLine"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharacterButton" params="" file="source/funkin/editors/charter/CharterStrumlineScreen.hx" module="funkin.editors.charter.CharterStrumlineScreen">
		<extends path="funkin.editors.ui.UIButton"/>
		<charIcon public="1"><c path="funkin.game.HealthIcon"/></charIcon>
		<textBox public="1"><c path="funkin.editors.ui.UIAutoCompleteTextBox"/></textBox>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="279" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="244"><f a="x:y:char:charsList:parent">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.charter.CharacterButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.charter.CharterWaveformHandler" params="" file="source/funkin/editors/charter/CharterWaveformHandler.hx">
		<extends path="flixel.FlxBasic"/>
		<ampsNeeded public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ampsNeeded>
		<ampSqrt public="1" get="accessor" set="null"><x path="Int"/></ampSqrt>
		<get_ampSqrt public="1" set="method" line="13"><f a=""><x path="Int"/></f></get_ampSqrt>
		<waveDatas public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="openfl.display.BitmapData"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</waveDatas>
		<waveShaders public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.backend.shaders.CustomShader"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</waveShaders>
		<sounds public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.sound.FlxSound"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sounds>
		<analyzers public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.backend.utils.AudioAnalyzer"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</analyzers>
		<waveformList public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</waveformList>
		<generateData public="1" set="method" line="30"><f a="name:sound">
	<c path="String"/>
	<c path="flixel.sound.FlxSound"/>
	<c path="openfl.display.BitmapData"/>
</f></generateData>
		<generateShader public="1" set="method" line="66"><f a="name:sound">
	<c path="String"/>
	<c path="flixel.sound.FlxSound"/>
	<c path="funkin.backend.shaders.CustomShader"/>
</f></generateShader>
		<clearWaveform public="1" set="method" line="87"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></clearWaveform>
		<clearWaveforms public="1" set="method" line="101"><f a=""><x path="Void"/></f></clearWaveforms>
		<destroy public="1" set="method" line="112" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.charter.SongCreationData" params="" file="source/funkin/editors/charter/SongCreationScreen.hx" module="funkin.editors.charter.SongCreationScreen"><a>
	<voicesBytes><c path="haxe.io.Bytes"/></voicesBytes>
	<playerVocals>
		<x path="Null"><c path="haxe.io.Bytes"/></x>
		<meta><m n=":optional"/></meta>
	</playerVocals>
	<oppVocals>
		<x path="Null"><c path="haxe.io.Bytes"/></x>
		<meta><m n=":optional"/></meta>
	</oppVocals>
	<meta><t path="funkin.backend.chart.ChartMetaData"/></meta>
	<instBytes><c path="haxe.io.Bytes"/></instBytes>
</a></typedef>
	<class path="funkin.editors.charter.SongCreationScreen" params="" file="source/funkin/editors/charter/SongCreationScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<onSave expr="null">
			<f a=":">
				<x path="Null"><t path="funkin.editors.charter.SongCreationData"/></x>
				<x path="Null"><f a=":">
	<c path="String"/>
	<t path="funkin.editors.charter.SongCreationData"/>
	<x path="Void"/>
</f></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<songNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></songNameTextBox>
		<bpmStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></bpmStepper>
		<beatsPerMeasureStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></beatsPerMeasureStepper>
		<denominatorStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></denominatorStepper>
		<instExplorer public="1"><c path="funkin.editors.ui.UIFileExplorer"/></instExplorer>
		<voicesExplorer public="1"><c path="funkin.editors.ui.UIFileExplorer"/></voicesExplorer>
		<importFrom public="1"><c path="funkin.editors.ui.UIButton"/></importFrom>
		<displayNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></displayNameTextBox>
		<iconTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></iconTextBox>
		<iconSprite public="1"><c path="funkin.game.HealthIcon"/></iconSprite>
		<opponentModeCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></opponentModeCheckbox>
		<coopAllowedCheckbox public="1"><c path="funkin.editors.ui.UICheckbox"/></coopAllowedCheckbox>
		<colorWheel public="1"><c path="funkin.editors.ui.UIColorwheel"/></colorWheel>
		<difficultiesTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></difficultiesTextBox>
		<engineDropdown public="1"><c path="funkin.editors.ui.UIDropDown"/></engineDropdown>
		<createSong public="1"><c path="funkin.editors.ui.UIButton"/></createSong>
		<importInstExplorer public="1"><c path="funkin.editors.ui.UIFileExplorer"/></importInstExplorer>
		<importVoicesExplorer public="1"><c path="funkin.editors.ui.UIFileExplorer"/></importVoicesExplorer>
		<importIdTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></importIdTextBox>
		<importChartFile public="1"><c path="funkin.editors.ui.UIFileExplorer"/></importChartFile>
		<importMetaFile public="1"><c path="funkin.editors.ui.UIFileExplorer"/></importMetaFile>
		<backButton public="1"><c path="funkin.editors.ui.UIButton"/></backButton>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<songDataGroup public="1" expr="new FlxGroup()">
			<t path="flixel.group.FlxGroup"/>
			<meta><m n=":value"><e>new FlxGroup()</e></m></meta>
		</songDataGroup>
		<menuDataGroup public="1" expr="new FlxGroup()">
			<t path="flixel.group.FlxGroup"/>
			<meta><m n=":value"><e>new FlxGroup()</e></m></meta>
		</menuDataGroup>
		<selectFormatGroup public="1" expr="new FlxGroup()">
			<t path="flixel.group.FlxGroup"/>
			<meta><m n=":value"><e>new FlxGroup()</e></m></meta>
		</selectFormatGroup>
		<importAudioGroup public="1" expr="new FlxGroup()">
			<t path="flixel.group.FlxGroup"/>
			<meta><m n=":value"><e>new FlxGroup()</e></m></meta>
		</importAudioGroup>
		<importDataGroup public="1" expr="new FlxGroup()">
			<t path="flixel.group.FlxGroup"/>
			<meta><m n=":value"><e>new FlxGroup()</e></m></meta>
		</importDataGroup>
		<pages public="1" expr="[]">
			<c path="Array"><t path="flixel.group.FlxGroup"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pages>
		<pageSizes public="1" expr="[]">
			<c path="Array"><x path="flixel.math.FlxPoint"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pageSizes>
		<importPages public="1" expr="[]">
			<c path="Array"><t path="flixel.group.FlxGroup"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</importPages>
		<importPageSizes public="1" expr="[]">
			<c path="Array"><x path="flixel.math.FlxPoint"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</importPageSizes>
		<isImporting public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isImporting>
		<curPage public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curPage>
		<translate get="inline" set="null" line="80"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></translate>
		<translateMeta get="inline" set="null" line="83"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></translateMeta>
		<create public="1" set="method" line="85" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="290" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<refreshPages set="method" line="317"><f a=""><x path="Void"/></f></refreshPages>
		<updatePagesTexts set="method" line="325"><f a=""><x path="Void"/></f></updatePagesTexts>
		<updateIcon set="method" line="347"><f a="icon">
	<c path="String"/>
	<x path="Void"/>
</f></updateIcon>
		<saveSongInfo set="method" line="358"><f a=""><x path="Void"/></f></saveSongInfo>
		<saveFromVSlice set="method" line="438"><f a="files:?name">
	<t path="Map">
		<c path="String"/>
		<x path="Any"/>
	</t>
	<c path="String"/>
	<x path="Void"/>
</f></saveFromVSlice>
		<new public="1" set="method" line="74"><f a="?onSave">
	<f a=":">
		<t path="funkin.editors.charter.SongCreationData"/>
		<x path="Null"><f a=":">
	<c path="String"/>
	<t path="funkin.editors.charter.SongCreationData"/>
	<x path="Void"/>
</f></x>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.extra.AxisGizmo" params="" file="source/funkin/editors/extra/AxisGizmo.hx">
		<extends path="flixel.FlxObject"/>
		<_worldPos expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</_worldPos>
		<draw public="1" set="method" line="6" override="1"><f a=""><x path="Void"/></f></draw>
		<destroy public="1" set="method" line="27" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="3"><f a="?x:?y:?width:?height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.extra.CameraHoverDummy" params="" file="source/funkin/editors/extra/CameraHoverDummy.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<parent><c path="flixel.FlxBasic"/></parent>
		<updateButton public="1" set="method" line="12" override="1"><f a=""><x path="Void"/></f></updateButton>
		<draw public="1" set="method" line="17" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="5"><f a="?parent:scroll">
	<c path="flixel.FlxBasic"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.extra.PropertyButton" params="" file="source/funkin/editors/extra/PropertyButton.hx">
		<extends path="funkin.editors.ui.UIButton"/>
		<propertyText public="1"><c path="funkin.editors.ui.UITextBox"/></propertyText>
		<valueText public="1"><c path="funkin.editors.ui.UITextBox"/></valueText>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<update public="1" set="method" line="29" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updatePos public="1" set="method" line="34"><f a=""><x path="Void"/></f></updatePos>
		<new public="1" set="method" line="9">
			<f a="property:value:parent:?width:?height:?nameWidth:?valueWidth:?inputHeight" v=":::280:35:100:135:25">
				<c path="String"/>
				<c path="String"/>
				<a><remove set="null"><f a="">
	<c path="funkin.editors.extra.PropertyButton"/>
	<x path="Void"/>
</f></remove></a>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inputHeight : 25, valueWidth : 135, nameWidth : 100, height : 35, width : 280 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.stage.StageCreationData" params="" file="source/funkin/editors/stage/StageCreationScreen.hx" module="funkin.editors.stage.StageCreationScreen"><a>
	<path><c path="String"/></path>
	<name><c path="String"/></name>
</a></typedef>
	<class path="funkin.editors.stage.StageCreationScreen" params="" file="source/funkin/editors/stage/StageCreationScreen.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<onSave expr="null">
			<f a="">
				<x path="Null"><t path="funkin.editors.stage.StageCreationData"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onSave>
		<stageNameTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></stageNameTextBox>
		<stagePathTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></stagePathTextBox>
		<voicesExplorer public="1"><c path="funkin.editors.ui.UIFileExplorer"/></voicesExplorer>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<translate get="inline" set="null" line="24"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<create public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></create>
		<saveStageInfo set="method" line="58"><f a=""><x path="Void"/></f></saveStageInfo>
		<new public="1" set="method" line="18"><f a="?onSave">
	<f a="">
		<t path="funkin.editors.stage.StageCreationData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.StageEditor" params="" file="source/funkin/editors/stage/StageEditor.hx">
		<extends path="funkin.editors.ui.UIState"/>
		<__stage static="1"><c path="String"/></__stage>
		<instance public="1" get="accessor" set="null" static="1"><c path="funkin.editors.stage.StageEditor"/></instance>
		<get_instance get="inline" set="null" line="33" static="1"><f a=""><c path="funkin.editors.stage.StageEditor"/></f></get_instance>
		<SPRITE_WINDOW_WIDTH public="1" get="inline" set="null" expr="400" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>400</e></m></meta>
		</SPRITE_WINDOW_WIDTH>
		<SPRITE_WINDOW_BUTTON_HEIGHT public="1" get="inline" set="null" expr="64" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>64</e></m></meta>
		</SPRITE_WINDOW_BUTTON_HEIGHT>
		<exID public="1" get="inline" set="null" line="70" static="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></exID>
		<calcSpriteBounds public="1" set="method" line="983" static="1"><f a="sprite">
	<c path="funkin.backend.FunkinSprite"/>
	<c path="Array"><x path="flixel.math.FlxPoint"/></c>
</f></calcSpriteBounds>
		<dotCheckSize public="1" expr="53" line="1194" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>53</e></m></meta>
		</dotCheckSize>
		<stage public="1"><c path="funkin.game.Stage"/></stage>
		<_point expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</_point>
		<topMenu public="1"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></topMenu>
		<topMenuSpr public="1"><c path="funkin.editors.ui.UITopMenu"/></topMenuSpr>
		<uiGroup public="1" expr="new FlxTypedGroup&lt;FlxSprite&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;FlxSprite&gt;()</e></m></meta>
		</uiGroup>
		<stageSpritesWindow public="1"><c path="funkin.editors.stage.StageSpritesWindow"/></stageSpritesWindow>
		<xmlMap public="1" expr="new Map&lt;FlxObject,Access&gt;()">
			<t path="Map">
				<c path="flixel.FlxObject"/>
				<x path="haxe.xml.Access"/>
			</t>
			<meta><m n=":value"><e>new Map&lt;FlxObject,Access&gt;()</e></m></meta>
		</xmlMap>
		<chars public="1" expr="[]">
			<c path="Array"><c path="funkin.game.Character"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</chars>
		<charMap public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.game.Character"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</charMap>
		<stageCamera public="1"><c path="flixel.FlxCamera"/></stageCamera>
		<uiCamera public="1"><c path="flixel.FlxCamera"/></uiCamera>
		<gizmosCamera public="1"><c path="flixel.FlxCamera"/></gizmosCamera>
		<axisGizmo public="1"><c path="funkin.editors.extra.AxisGizmo"/></axisGizmo>
		<selection public="1" expr="new Selection()">
			<x path="funkin.editors.stage.Selection"/>
			<meta><m n=":value"><e>new Selection()</e></m></meta>
		</selection>
		<mouseMode public="1" expr="NONE">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</mouseMode>
		<mousePoint public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</mousePoint>
		<clickPoint public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</clickPoint>
		<storedPos public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</storedPos>
		<storedScale public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</storedScale>
		<storedSkew public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</storedSkew>
		<storedAngle public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</storedAngle>
		<angleOffset public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angleOffset>
		<showCharacters public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</showCharacters>
		<undos public="1" expr="new UndoList&lt;StageChange&gt;()">
			<c path="funkin.editors.UndoList"><e path="funkin.editors.stage.StageChange"/></c>
			<meta><m n=":value"><e>new UndoList&lt;StageChange&gt;()</e></m></meta>
		</undos>
		<translate get="inline" set="null" line="75"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<create public="1" set="method" line="82" override="1"><f a=""><x path="Void"/></f></create>
		<loadStage set="method" line="283"><f a="order:orderNodes">
	<c path="Array"><d/></c>
	<c path="Array"><x path="haxe.xml.Access"/></c>
	<x path="Void"/>
</f></loadStage>
		<prepareCharacter set="method" line="358"><f a="charPos:node">
	<c path="funkin.game.StageCharPos"/>
	<x path="haxe.xml.Access"/>
	<c path="funkin.game.Character"/>
</f></prepareCharacter>
		<destroy public="1" set="method" line="410" override="1"><f a=""><x path="Void"/></f></destroy>
		<movedTillRel expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</movedTillRel>
		<nextScroll expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</nextScroll>
		<update public="1" set="method" line="426" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<_file_exit set="method" line="506"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_exit>
		<_file_save set="method" line="511"><f a="_">
	<x path="Null"><t path="funkin.editors.ui.UIContextMenuOption"/></x>
	<x path="Void"/>
</f></_file_save>
		<_file_saveas set="method" line="524"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_file_saveas>
		<_sprite_new set="method" line="532"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_sprite_new>
		<_character_new set="method" line="557"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_character_new>
		<saveToXml set="method" line="598"><f a="xml:name:value:?defaultValue">
	<c path="Xml"/>
	<c path="String"/>
	<d/>
	<d/>
	<c path="Xml"/>
</f></saveToXml>
		<savePointToXml set="method" line="603"><f a="xml:name:point:?defaultValueX:?defaultValueY">
	<c path="Xml"/>
	<c path="String"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="Xml"/>
</f></savePointToXml>
		<getBoolOfNode set="method" line="615"><f a="node:name">
	<x path="haxe.xml.Access"/>
	<c path="String"/>
	<x path="Bool"/>
</f></getBoolOfNode>
		<buildStage set="method" line="621"><f a=""><c path="String"/></f></buildStage>
		<_edit_undo set="method" line="736"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_undo>
		<_edit_redo set="method" line="762"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_edit_redo>
		<selectSprite public="1" set="method" line="788"><f a="_sprite">
	<c path="funkin.backend.FunkinSprite"/>
	<x path="Void"/>
</f></selectSprite>
		<getSprites set="method" line="801"><f a=""><c path="Array"><c path="funkin.backend.FunkinSprite"/></c></f></getSprites>
		<getRealSprites set="method" line="804"><f a=""><c path="Array"><c path="funkin.backend.FunkinSprite"/></c></f></getRealSprites>
		<updateSelection set="method" line="808"><f a=""><x path="Void"/></f></updateSelection>
		<_select_all set="method" line="829">
			<f a="_:?checkSelection" v=":true">
				<t path="funkin.editors.ui.UIContextMenuOption"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkSelection : true }</e></m></meta>
		</_select_all>
		<_select_deselect set="method" line="836">
			<f a="_:?checkSelection" v=":true">
				<x path="Null"><t path="funkin.editors.ui.UIContextMenuOption"/></x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkSelection : true }</e></m></meta>
		</_select_deselect>
		<_select_inverse set="method" line="841">
			<f a="_:?checkSelection" v=":true">
				<t path="funkin.editors.ui.UIContextMenuOption"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkSelection : true }</e></m></meta>
		</_select_inverse>
		<zoom set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</zoom>
		<__camZoom set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</__camZoom>
		<set_zoom set="method" line="852"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zoom>
		<set___camZoom set="method" line="855"><f a="val">
	<x path="Float"/>
	<x path="Float"/>
</f></set___camZoom>
		<_view_zoomin set="method" line="859"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomin>
		<_view_zoomout set="method" line="863"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomout>
		<_view_zoomreset set="method" line="867"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_zoomreset>
		<updateZoom get="inline" set="null" line="871"><f a=""><x path="Void"/></f></updateZoom>
		<calculateZoom get="inline" set="null" line="875"><f a="zoom">
	<x path="Float"/>
	<x path="Float"/>
</f></calculateZoom>
		<setZoom get="inline" set="null" line="879"><f a="_zoom">
	<x path="Float"/>
	<x path="Void"/>
</f></setZoom>
		<_view_focusdad set="method" line="883"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_focusdad>
		<_view_focusgf set="method" line="886"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_focusgf>
		<_view_focusbf set="method" line="889"><f a="_">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></_view_focusbf>
		<focusCharacter set="method" line="893"><f a="char">
	<c path="funkin.game.Character"/>
	<x path="Void"/>
</f></focusCharacter>
		<_editor_showCharacters set="method" line="900"><f a="t">
	<a><icon><x path="Int"/></icon></a>
	<x path="Void"/>
</f></_editor_showCharacters>
		<draw public="1" set="method" line="911" override="1"><f a=""><x path="Void"/></f></draw>
		<drawGuides set="method" line="918"><f a="sprite">
	<c path="funkin.backend.FunkinSprite"/>
	<x path="Void"/>
</f></drawGuides>
		<edges expr="[TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT, MIDDLE_LEFT, MIDDLE_RIGHT, BOTTOM_MIDDLE, TOP_MIDDLE, CENTER_CIRCLE, ROTATE_CIRCLE, ROTATE_CORNER]">
			<c path="Array"><x path="funkin.editors.stage.StageEditorEdge"/></c>
			<meta><m n=":value"><e>[TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT, MIDDLE_LEFT, MIDDLE_RIGHT, BOTTOM_MIDDLE, TOP_MIDDLE, CENTER_CIRCLE, ROTATE_CIRCLE, ROTATE_CORNER]</e></m></meta>
		</edges>
		<tryUpdateHitbox set="method" line="1071"><f a="sprite">
	<c path="funkin.backend.FunkinSprite"/>
	<x path="Void"/>
</f></tryUpdateHitbox>
		<handleSelection set="method" line="1075"><f a="sprite">
	<c path="funkin.backend.FunkinSprite"/>
	<x path="Void"/>
</f></handleSelection>
		<checkDot set="method" line="1196"><f a="point">
	<x path="flixel.math.FlxPoint"/>
	<x path="Bool"/>
</f></checkDot>
		<checkLine set="method" line="1204"><f a="point1:point2:dx:dy">
	<x path="flixel.math.FlxPoint"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></checkLine>
		<new public="1" set="method" line="77"><f a="stage">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>flixel.FlxSprite</e></m>
		</meta>
	</class>
	<typedef path="funkin.editors.stage.StageInfo" params="" file="source/funkin/editors/stage/StageEditor.hx" module="funkin.editors.stage.StageEditor"><a>
	<zoom><x path="Float"/></zoom>
	<startCamY><x path="Float"/></startCamY>
	<startCamX><x path="Float"/></startCamX>
	<name><c path="String"/></name>
	<folder><c path="String"/></folder>
	<attrib><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></attrib>
</a></typedef>
	<typedef path="funkin.editors.stage.StageSprInfo" params="" file="source/funkin/editors/stage/StageEditor.hx" module="funkin.editors.stage.StageEditor"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<skewY><x path="Float"/></skewY>
	<skewX><x path="Float"/></skewX>
	<scaleY><x path="Float"/></scaleY>
	<scaleX><x path="Float"/></scaleX>
	<angle><x path="Float"/></angle>
</a></typedef>
	<enum path="funkin.editors.stage.StageChange" params="" file="source/funkin/editors/stage/StageEditor.hx" module="funkin.editors.stage.StageEditor">
		<CEditInfo a="oldInfo:newInfo">
			<t path="funkin.editors.stage.StageInfo"/>
			<t path="funkin.editors.stage.StageInfo"/>
		</CEditInfo>
		<CTransform a="sprite:oldInfo:newInfo">
			<c path="funkin.backend.FunkinSprite"/>
			<t path="funkin.editors.stage.StageSprInfo"/>
			<t path="funkin.editors.stage.StageSprInfo"/>
		</CTransform>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<abstract path="funkin.editors.stage.Selection" params="" file="source/funkin/editors/stage/StageEditor.hx" module="funkin.editors.stage.StageEditor">
		<from><icast><c path="Array"><c path="funkin.backend.FunkinSprite"/></c></icast></from>
		<this><c path="Array"><c path="funkin.backend.FunkinSprite"/></c></this>
		<to><icast><c path="Array"><c path="funkin.backend.FunkinSprite"/></c></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="funkin.editors.stage._StageEditor.Selection_Impl_" params="" file="source/funkin/editors/stage/StageEditor.hx" private="1" module="funkin.editors.stage.StageEditor" final="1"><_new public="1" get="inline" set="null" line="1252" static="1">
	<f a="?array">
		<c path="Array"><c path="funkin.backend.FunkinSprite"/></c>
		<x path="funkin.editors.stage.Selection"/>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class></impl>
	</abstract>
	<class path="funkin.editors.stage._StageEditor.Selection_Impl_" params="" file="source/funkin/editors/stage/StageEditor.hx" private="1" module="funkin.editors.stage.StageEditor" final="1"><_new public="1" get="inline" set="null" line="1252" static="1">
	<f a="?array">
		<c path="Array"><c path="funkin.backend.FunkinSprite"/></c>
		<x path="funkin.editors.stage.Selection"/>
	</f>
	<meta><m n=":noCompletion"/></meta>
</_new></class>
	<abstract path="funkin.editors.stage.StageEditorMouseMode" params="" file="source/funkin/editors/stage/StageEditor.hx" module="funkin.editors.stage.StageEditor">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.editors.stage._StageEditor.StageEditorMouseMode_Impl_" params="" file="source/funkin/editors/stage/StageEditor.hx" private="1" module="funkin.editors.stage.StageEditor" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<SCALE_LEFT public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCALE_LEFT>
	<SCALE_BOTTOM public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCALE_BOTTOM>
	<SCALE_TOP public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCALE_TOP>
	<SCALE_RIGHT public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCALE_RIGHT>
	<SCALE_TOP_LEFT public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCALE_TOP_LEFT>
	<SCALE_TOP_RIGHT public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCALE_TOP_RIGHT>
	<SCALE_BOTTOM_LEFT public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCALE_BOTTOM_LEFT>
	<SCALE_BOTTOM_RIGHT public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SCALE_BOTTOM_RIGHT>
	<MOVE_CENTER public="1" get="inline" set="null" expr="cast 9" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MOVE_CENTER>
	<SKEW_TOP public="1" get="inline" set="null" expr="cast 10" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SKEW_TOP>
	<SKEW_LEFT public="1" get="inline" set="null" expr="cast 11" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SKEW_LEFT>
	<SKEW_RIGHT public="1" get="inline" set="null" expr="cast 12" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SKEW_RIGHT>
	<SKEW_BOTTOM public="1" get="inline" set="null" expr="cast 13" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</SKEW_BOTTOM>
	<ROTATE public="1" get="inline" set="null" expr="cast 14" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorMouseMode"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ROTATE>
	<toString public="1" set="method" line="1287" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="funkin.editors.stage._StageEditor.StageEditorMouseMode_Impl_" params="" file="source/funkin/editors/stage/StageEditor.hx" private="1" module="funkin.editors.stage.StageEditor" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<SCALE_LEFT public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCALE_LEFT>
		<SCALE_BOTTOM public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCALE_BOTTOM>
		<SCALE_TOP public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCALE_TOP>
		<SCALE_RIGHT public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCALE_RIGHT>
		<SCALE_TOP_LEFT public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCALE_TOP_LEFT>
		<SCALE_TOP_RIGHT public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCALE_TOP_RIGHT>
		<SCALE_BOTTOM_LEFT public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCALE_BOTTOM_LEFT>
		<SCALE_BOTTOM_RIGHT public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SCALE_BOTTOM_RIGHT>
		<MOVE_CENTER public="1" get="inline" set="null" expr="cast 9" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MOVE_CENTER>
		<SKEW_TOP public="1" get="inline" set="null" expr="cast 10" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SKEW_TOP>
		<SKEW_LEFT public="1" get="inline" set="null" expr="cast 11" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SKEW_LEFT>
		<SKEW_RIGHT public="1" get="inline" set="null" expr="cast 12" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SKEW_RIGHT>
		<SKEW_BOTTOM public="1" get="inline" set="null" expr="cast 13" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</SKEW_BOTTOM>
		<ROTATE public="1" get="inline" set="null" expr="cast 14" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorMouseMode"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ROTATE>
		<toString public="1" set="method" line="1287" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="funkin.editors.stage.StageEditorEdge" params="" file="source/funkin/editors/stage/StageEditor.hx" module="funkin.editors.stage.StageEditor">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.editors.stage._StageEditor.StageEditorEdge_Impl_" params="" file="source/funkin/editors/stage/StageEditor.hx" private="1" module="funkin.editors.stage.StageEditor" final="1">
	<NONE public="1" get="inline" set="null" expr="cast -1" line="1309" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<TOP_LEFT public="1" get="inline" set="null" expr="cast 0" line="1311" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TOP_LEFT>
	<TOP_MIDDLE public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TOP_MIDDLE>
	<TOP_RIGHT public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TOP_RIGHT>
	<MIDDLE_LEFT public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MIDDLE_LEFT>
	<MIDDLE_RIGHT public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MIDDLE_RIGHT>
	<BOTTOM_LEFT public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BOTTOM_LEFT>
	<BOTTOM_MIDDLE public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BOTTOM_MIDDLE>
	<BOTTOM_RIGHT public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BOTTOM_RIGHT>
	<CENTER_CIRCLE public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CENTER_CIRCLE>
	<ROTATE_CIRCLE public="1" get="inline" set="null" expr="cast 9" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ROTATE_CIRCLE>
	<ROTATE_CORNER public="1" get="inline" set="null" expr="cast 10" line="1" static="1">
		<x path="funkin.editors.stage.StageEditorEdge"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ROTATE_CORNER>
	<toString public="1" set="method" line="1325" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
	<toInt public="1" set="method" line="1343" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="funkin.editors.stage._StageEditor.StageEditorEdge_Impl_" params="" file="source/funkin/editors/stage/StageEditor.hx" private="1" module="funkin.editors.stage.StageEditor" final="1">
		<NONE public="1" get="inline" set="null" expr="cast -1" line="1309" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<TOP_LEFT public="1" get="inline" set="null" expr="cast 0" line="1311" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TOP_LEFT>
		<TOP_MIDDLE public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TOP_MIDDLE>
		<TOP_RIGHT public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TOP_RIGHT>
		<MIDDLE_LEFT public="1" get="inline" set="null" expr="cast 3" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MIDDLE_LEFT>
		<MIDDLE_RIGHT public="1" get="inline" set="null" expr="cast 4" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MIDDLE_RIGHT>
		<BOTTOM_LEFT public="1" get="inline" set="null" expr="cast 5" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BOTTOM_LEFT>
		<BOTTOM_MIDDLE public="1" get="inline" set="null" expr="cast 6" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BOTTOM_MIDDLE>
		<BOTTOM_RIGHT public="1" get="inline" set="null" expr="cast 7" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BOTTOM_RIGHT>
		<CENTER_CIRCLE public="1" get="inline" set="null" expr="cast 8" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CENTER_CIRCLE>
		<ROTATE_CIRCLE public="1" get="inline" set="null" expr="cast 9" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ROTATE_CIRCLE>
		<ROTATE_CORNER public="1" get="inline" set="null" expr="cast 10" line="1" static="1">
			<x path="funkin.editors.stage.StageEditorEdge"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ROTATE_CORNER>
		<toString public="1" set="method" line="1325" static="1"><f a="this">
	<x path="Int"/>
	<c path="String"/>
</f></toString>
		<toInt public="1" set="method" line="1343" static="1"><f a="this">
	<x path="Int"/>
	<x path="Int"/>
</f></toInt>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="funkin.editors.ui.UISoftcodedWindow" params="" file="source/funkin/editors/ui/UISoftcodedWindow.hx">
		<extends path="funkin.editors.ui.UISubstateWindow"/>
		<saveButton public="1"><c path="funkin.editors.ui.UIButton"/></saveButton>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<elementMap expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.editors.ui.UISprite"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</elementMap>
		<xmlPath><c path="String"/></xmlPath>
		<filename><c path="String"/></filename>
		<customVariables><t path="Map">
	<c path="String"/>
	<d/>
</t></customVariables>
		<parser expr="HScript.initParser()">
			<c path="hscript.Parser"/>
			<meta><m n=":value"><e>HScript.initParser()</e></m></meta>
		</parser>
		<interp expr="new Interp()">
			<c path="hscript.Interp"/>
			<meta><m n=":value"><e>new Interp()</e></m></meta>
		</interp>
		<set set="method" line="39"><f a="name:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<get set="method" line="43"><f a="name">
	<c path="String"/>
	<d/>
</f></get>
		<varExists set="method" line="46"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></varExists>
		<execString set="method" line="50"><f a="input">
	<c path="String"/>
	<c path="String"/>
</f></execString>
		<execDefault set="method" line="73"><f a="code:defaultValue">
	<c path="String"/>
	<d/>
	<d/>
</f></execDefault>
		<execAtt set="method" line="77"><f a="el:key:?defaultValue">
	<x path="haxe.xml.Access"/>
	<c path="String"/>
	<d/>
	<d/>
</f></execAtt>
		<exec set="method" line="81"><f a="code">
	<c path="String"/>
	<d/>
</f></exec>
		<_errorHandler set="method" line="93"><f a="error">
	<c path="hscript.Error"/>
	<x path="Void"/>
</f></_errorHandler>
		<create public="1" set="method" line="105" override="1"><f a=""><x path="Void"/></f></create>
		<getElement set="method" line="310"><f a="name">
	<c path="String"/>
	<c path="funkin.editors.ui.UISprite"/>
</f></getElement>
		<callFunc set="method" line="314"><f a="name:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Null"><d/></x>
</f></callFunc>
		<update public="1" set="method" line="325" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<saveData public="1" set="method" line="330"><f a=""><x path="Void"/></f></saveData>
		<new public="1" set="method" line="29">
			<f a="xmlPath:?customVariables" v=":null">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ customVariables : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.StageXMLEditScreen" params="" file="source/funkin/editors/stage/StageEditor.hx" module="funkin.editors.stage.StageEditor">
		<extends path="funkin.editors.ui.UISoftcodedWindow"/>
		<xml public="1"><x path="haxe.xml.Access"/></xml>
		<saveCallback public="1"><f a=""><x path="Void"/></f></saveCallback>
		<translate get="inline" set="null" line="1367"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<saveData public="1" set="method" line="1381" override="1"><f a=""><x path="Void"/></f></saveData>
		<new public="1" set="method" line="1369">
			<f a="xml:saveCallback:?type" v="::&quot;Unknown&quot;">
				<x path="haxe.xml.Access"/>
				<f a=""><x path="Void"/></f>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ type : "Unknown" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.StageSelection" params="" file="source/funkin/editors/stage/StageSelection.hx">
		<extends path="funkin.editors.EditorTreeMenu"/>
		<create public="1" set="method" line="13" override="1"><f a=""><x path="Void"/></f></create>
		<new public="1" set="method" line="12"><f a="?exitCallback:?scriptsAllowed:?scriptName">
	<f a="">
		<c path="funkin.options.TreeMenu"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.StageSelectionScreen" params="" file="source/funkin/editors/stage/StageSelection.hx" module="funkin.editors.stage.StageSelection">
		<extends path="funkin.editors.EditorTreeMenuScreen"/>
		<stages public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</stages>
		<makeStageOption public="1" set="method" line="23"><f a="stage">
	<c path="String"/>
	<c path="funkin.options.type.TextOption"/>
</f></makeStageOption>
		<saveStage public="1" set="method" line="41"><f a="creation">
	<t path="funkin.editors.stage.StageCreationData"/>
	<x path="Void"/>
</f></saveStage>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.StageSpritesWindow" params="" file="source/funkin/editors/stage/StageSpritesWindow.hx">
		<extends path="funkin.editors.ui.UIButtonList"><c path="funkin.editors.stage.elements.StageElementButton"/></extends>
		<translate get="inline" set="null" line="9"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<new public="1" set="method" line="11"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.elements.StageElementButton" params="" file="source/funkin/editors/stage/elements/StageElementButton.hx">
		<extends path="funkin.editors.ui.UIButton"/>
		<xml public="1"><x path="haxe.xml.Access"/></xml>
		<editButton public="1"><c path="funkin.editors.ui.UIButton"/></editButton>
		<editIcon public="1"><c path="flixel.FlxSprite"/></editIcon>
		<visibilityButton public="1"><c path="funkin.editors.ui.UIButton"/></visibilityButton>
		<visibilityIcon public="1"><c path="flixel.FlxSprite"/></visibilityIcon>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<isHidden public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isHidden>
		<hasAdvancedEdit public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasAdvancedEdit>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<tagColor public="1"><c path="funkin.editors.ui.UISliceSprite"/></tagColor>
		<setEditNormal public="1" set="method" line="86"><f a=""><x path="Void"/></f></setEditNormal>
		<setEditAdvanced public="1" set="method" line="91"><f a=""><x path="Void"/></f></setEditAdvanced>
		<_lastSelected expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_lastSelected>
		<update public="1" set="method" line="99" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="121" override="1"><f a=""><x path="Void"/></f></draw>
		<updateColorTransform public="1" set="method" line="136" override="1"><f a=""><x path="Void"/></f></updateColorTransform>
		<updateInfo public="1" set="method" line="147"><f a=""><x path="Void"/></f></updateInfo>
		<updatePos public="1" set="method" line="154"><f a=""><x path="Void"/></f></updatePos>
		<getSprite public="1" set="method" line="175"><f a=""><c path="funkin.backend.FunkinSprite"/></f></getSprite>
		<canRender public="1" set="method" line="179"><f a=""><x path="Bool"/></f></canRender>
		<getName public="1" set="method" line="183"><f a=""><c path="String"/></f></getName>
		<onSelect public="1" set="method" line="187"><f a=""><x path="Void"/></f></onSelect>
		<onVisiblityToggle public="1" set="method" line="191"><f a=""><x path="Void"/></f></onVisiblityToggle>
		<onEdit public="1" set="method" line="195"><f a=""><x path="Void"/></f></onEdit>
		<onDelete public="1" set="method" line="199"><f a=""><x path="Void"/></f></onDelete>
		<getPos public="1" set="method" line="203"><f a=""><x path="flixel.math.FlxPoint"/></f></getPos>
		<getInfoText public="1" set="method" line="207"><f a=""><c path="String"/></f></getInfoText>
		<new public="1" set="method" line="27"><f a="x:y:xml">
	<x path="Float"/>
	<x path="Float"/>
	<x path="haxe.xml.Access"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.elements.StageCharacterButton" params="" file="source/funkin/editors/stage/elements/StageCharacterButton.hx">
		<extends path="funkin.editors.stage.elements.StageElementButton"/>
		<char public="1"><c path="funkin.game.Character"/></char>
		<charScale public="1" get="accessor" set="null"><x path="Float"/></charScale>
		<translate get="inline" set="null" line="16"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<update public="1" set="method" line="29" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateInfo public="1" set="method" line="33" override="1"><f a=""><x path="Void"/></f></updateInfo>
		<getSprite public="1" set="method" line="40" override="1"><f a=""><c path="funkin.backend.FunkinSprite"/></f></getSprite>
		<onSelect public="1" set="method" line="44" override="1"><f a=""><x path="Void"/></f></onSelect>
		<onEdit public="1" set="method" line="53" override="1"><f a=""><x path="Void"/></f></onEdit>
		<onDelete public="1" set="method" line="65" override="1"><f a=""><x path="Void"/></f></onDelete>
		<onVisiblityToggle public="1" set="method" line="80" override="1"><f a=""><x path="Void"/></f></onVisiblityToggle>
		<getName public="1" set="method" line="85" override="1"><f a=""><c path="String"/></f></getName>
		<getPos public="1" set="method" line="89" override="1"><f a=""><x path="flixel.math.FlxPoint"/></f></getPos>
		<updatePos public="1" set="method" line="93" override="1"><f a=""><x path="Void"/></f></updatePos>
		<get_charScale set="method" line="97"><f a=""><x path="Float"/></f></get_charScale>
		<new public="1" set="method" line="18"><f a="x:y:char:xml">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.game.Character"/>
	<x path="haxe.xml.Access"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.elements.StageCharacterEditScreen" params="" file="source/funkin/editors/stage/elements/StageCharacterButton.hx" module="funkin.editors.stage.elements.StageCharacterButton">
		<extends path="funkin.editors.ui.UISoftcodedWindow"/>
		<button public="1"><c path="funkin.editors.stage.elements.StageCharacterButton"/></button>
		<char public="1"><c path="funkin.game.Character"/></char>
		<translate get="inline" set="null" line="107"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<create public="1" set="method" line="130" override="1"><f a=""><x path="Void"/></f></create>
		<saveData public="1" set="method" line="134" override="1"><f a=""><x path="Void"/></f></saveData>
		<new public="1" set="method" line="109"><f a="button">
	<c path="funkin.editors.stage.elements.StageCharacterButton"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.elements.StageSpriteButton" params="" file="source/funkin/editors/stage/elements/StageSpriteButton.hx">
		<extends path="funkin.editors.stage.elements.StageElementButton"/>
		<sprite public="1"><c path="funkin.backend.FunkinSprite"/></sprite>
		<update public="1" set="method" line="22" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateInfo public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></updateInfo>
		<getSprite public="1" set="method" line="31" override="1"><f a=""><c path="funkin.backend.FunkinSprite"/></f></getSprite>
		<onSelect public="1" set="method" line="35" override="1"><f a=""><x path="Void"/></f></onSelect>
		<onVisiblityToggle public="1" set="method" line="39" override="1"><f a=""><x path="Void"/></f></onVisiblityToggle>
		<onEdit public="1" set="method" line="44" override="1"><f a=""><x path="Void"/></f></onEdit>
		<onDelete public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></onDelete>
		<getName public="1" set="method" line="60" override="1"><f a=""><c path="String"/></f></getName>
		<getPos public="1" set="method" line="64" override="1"><f a=""><x path="flixel.math.FlxPoint"/></f></getPos>
		<updatePos public="1" set="method" line="68" override="1"><f a=""><x path="Void"/></f></updatePos>
		<new public="1" set="method" line="11"><f a="x:y:sprite:xml">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.backend.FunkinSprite"/>
	<x path="haxe.xml.Access"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.elements.StageSolidButton" params="" file="source/funkin/editors/stage/elements/StageSolidButton.hx">
		<extends path="funkin.editors.stage.elements.StageSpriteButton"/>
		<onEdit public="1" set="method" line="13" override="1"><f a=""><x path="Void"/></f></onEdit>
		<new public="1" set="method" line="8"><f a="x:y:sprite:xml">
	<x path="Float"/>
	<x path="Float"/>
	<c path="funkin.backend.FunkinSprite"/>
	<x path="haxe.xml.Access"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.elements.StageSpriteEditScreen" params="" file="source/funkin/editors/stage/elements/StageSpriteButton.hx" module="funkin.editors.stage.elements.StageSpriteButton">
		<extends path="funkin.editors.ui.UISoftcodedWindow"/>
		<newSprite public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</newSprite>
		<button public="1"><c path="funkin.editors.stage.elements.StageSpriteButton"/></button>
		<sprite public="1"><c path="funkin.backend.FunkinSprite"/></sprite>
		<isSaving expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isSaving>
		<translate get="inline" set="null" line="80"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<create public="1" set="method" line="101" override="1"><f a=""><x path="Void"/></f></create>
		<saveData public="1" set="method" line="105" override="1"><f a=""><x path="Void"/></f></saveData>
		<close public="1" set="method" line="111" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="82"><f a="button">
	<c path="funkin.editors.stage.elements.StageSpriteButton"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.elements.StageUnknownButton" params="" file="source/funkin/editors/stage/elements/StageUnknownButton.hx">
		<extends path="funkin.editors.stage.elements.StageElementButton"/>
		<lowMemory public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lowMemory>
		<highMemory public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</highMemory>
		<basic public="1"><c path="flixel.FlxBasic"/></basic>
		<update public="1" set="method" line="34" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateInfo public="1" set="method" line="38" override="1"><f a=""><x path="Void"/></f></updateInfo>
		<getSprite public="1" set="method" line="42" override="1"><f a=""><c path="funkin.backend.FunkinSprite"/></f></getSprite>
		<canRender public="1" set="method" line="50" override="1"><f a=""><x path="Bool"/></f></canRender>
		<onSelect public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></onSelect>
		<onEdit public="1" set="method" line="57" override="1"><f a=""><x path="Void"/></f></onEdit>
		<onVisiblityToggle public="1" set="method" line="66" override="1"><f a=""><x path="Void"/></f></onVisiblityToggle>
		<getName public="1" set="method" line="69" override="1"><f a=""><c path="String"/></f></getName>
		<getPos public="1" set="method" line="73" override="1"><f a=""><x path="flixel.math.FlxPoint"/></f></getPos>
		<getInfoText public="1" set="method" line="77" override="1"><f a=""><c path="String"/></f></getInfoText>
		<updatePos public="1" set="method" line="81" override="1"><f a=""><x path="Void"/></f></updatePos>
		<new public="1" set="method" line="12"><f a="x:y:basic:xml">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.FlxBasic"/>
	<x path="haxe.xml.Access"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.stage.elements.StageUnknownEditScreen" params="" file="source/funkin/editors/stage/elements/StageUnknownButton.hx" module="funkin.editors.stage.elements.StageUnknownButton">
		<extends path="funkin.editors.ui.UISoftcodedWindow"/>
		<button public="1"><c path="funkin.editors.stage.elements.StageUnknownButton"/></button>
		<translate get="inline" set="null" line="90"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<create public="1" set="method" line="103" override="1"><f a=""><x path="Void"/></f></create>
		<saveData public="1" set="method" line="107" override="1"><f a=""><x path="Void"/></f></saveData>
		<new public="1" set="method" line="92"><f a="button">
	<c path="funkin.editors.stage.elements.StageUnknownButton"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.IUIFocusable" params="" file="source/funkin/editors/ui/IUIFocusable.hx" interface="1">
		<onKeyDown public="1" set="method"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyDown>
		<onKeyUp public="1" set="method"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyUp>
		<onTextInput public="1" set="method"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></onTextInput>
		<onTextEdit public="1" set="method"><f a="text:start:end">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTextEdit>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIAudioPlayer" params="" file="source/funkin/editors/ui/UIAudioPlayer.hx">
		<extends path="funkin.editors.ui.UIButton"/>
		<sound public="1"><c path="flixel.sound.FlxSound"/></sound>
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<playingSprite public="1"><c path="flixel.FlxSprite"/></playingSprite>
		<timeText public="1"><c path="funkin.editors.ui.UIText"/></timeText>
		<timeBar public="1"><c path="flixel.ui.FlxBar"/></timeBar>
		<timeBarPlayer public="1"><c path="flixel.FlxSprite"/></timeBarPlayer>
		<timeBarSpr public="1"><c path="funkin.editors.ui.UISprite"/></timeBarSpr>
		<volumeIcon public="1"><c path="flixel.FlxSprite"/></volumeIcon>
		<volumeBar public="1"><c path="flixel.ui.FlxBar"/></volumeBar>
		<volumeBarSpr public="1"><c path="funkin.editors.ui.UISprite"/></volumeBarSpr>
		<draggingObj public="1" expr="null">
			<c path="flixel.ui.FlxBar"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</draggingObj>
		<wasPlaying public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</wasPlaying>
		<nextPlayerColor public="1" expr="0x440364">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0x440364</e></m></meta>
		</nextPlayerColor>
		<update public="1" set="method" line="84" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="136" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="29"><f a="x:y:bytes">
	<x path="Float"/>
	<x path="Float"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UITextBox" params="" file="source/funkin/editors/ui/UITextBox.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<implements path="funkin.editors.ui.IUIFocusable"/>
		<label public="1"><c path="funkin.editors.ui.UIText"/></label>
		<position public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</position>
		<multiline public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</multiline>
		<caretSpr public="1"><c path="flixel.FlxSprite"/></caretSpr>
		<onChange public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></onChange>
		<__wasFocused expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__wasFocused>
		<cacheRect expr="new Rectangle()">
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":value"><e>new Rectangle()</e></m></meta>
		</cacheRect>
		<update public="1" set="method" line="39" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onKeyDown public="1" set="method" line="103"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyDown>
		<changeSelection public="1" set="method" line="145"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<onKeyUp public="1" set="method" line="148"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyUp>
		<onTextInput public="1" set="method" line="150"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></onTextInput>
		<onTextEdit public="1" set="method" line="155"><f a="text:start:end">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTextEdit>
		<new public="1" set="method" line="20">
			<f a="x:y:?text:?width:?height:?multiline:?small" v="::&quot;&quot;:320:32:false:false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ small : false, multiline : false, height : 32, width : 320, text : "" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIAutoCompleteTextBox" params="" file="source/funkin/editors/ui/UIAutoCompleteTextBox.hx">
		<extends path="funkin.editors.ui.UITextBox"/>
		<suggestionText public="1"><c path="funkin.editors.ui.UIText"/></suggestionText>
		<suggestItems public="1" set="accessor" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</suggestItems>
		<suggestIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</suggestIndex>
		<update public="1" set="method" line="21" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onKeyDown public="1" set="method" line="27" override="1"><f a="e:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyDown>
		<_suggestions expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_suggestions>
		<updateSuggestion public="1" set="method" line="53">
			<f a="?refreshSuggestions" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ refreshSuggestions : true }</e></m></meta>
		</updateSuggestion>
		<onTextInput public="1" set="method" line="76" override="1"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></onTextInput>
		<onTextEdit public="1" set="method" line="82" override="1"><f a="text:start:end">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTextEdit>
		<set_suggestItems set="method" line="88"><f a="v">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></set_suggestItems>
		<new public="1" set="method" line="12">
			<f a="x:y:?text:?width:?height:?multiline:?small" v="::&quot;&quot;:320:32:false:false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ small : false, multiline : false, height : 32, width : 320, text : "" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIBackdrop" params="" file="source/funkin/editors/ui/UIBackdrop.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<draw public="1" set="method" line="6" override="1"><f a=""><x path="Void"/></f></draw>
		<destroy public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="5"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="funkin.editors.ui.UICheckbox" params="" file="source/funkin/editors/ui/UICheckbox.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<checked public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</checked>
		<small public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</small>
		<onChecked public="1" expr="null">
			<f a="">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onChecked>
		<field public="1"><c path="funkin.editors.ui.UIText"/></field>
		<check public="1"><c path="flixel.FlxSprite"/></check>
		<update public="1" set="method" line="30" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updatePositions public="1" get="inline" set="null" line="46"><f a=""><x path="Void"/></f></updatePositions>
		<draw public="1" set="method" line="51" override="1"><f a=""><x path="Void"/></f></draw>
		<onHovered public="1" set="method" line="56" override="1"><f a=""><x path="Void"/></f></onHovered>
		<updateButton public="1" set="method" line="70" override="1"><f a=""><x path="Void"/></f></updateButton>
		<new public="1" set="method" line="11">
			<f a="x:y:text:?checked:?w:?small" v=":::false:0:false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ small : false, w : 0, checked : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIColorwheel" params="" file="source/funkin/editors/ui/UIColorwheel.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<hitBoxExtension get="inline" set="null" expr="8" line="127" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</hitBoxExtension>
		<colorPicker><c path="flixel.FlxSprite"/></colorPicker>
		<colorPickerShader><c path="funkin.backend.shaders.CustomShader"/></colorPickerShader>
		<colorPickerSelector><c path="funkin.editors.ui.UIColorWheelSelector"/></colorPickerSelector>
		<colorSlider><c path="flixel.FlxSprite"/></colorSlider>
		<colorSliderSelector><c path="funkin.editors.ui.UIColorWheelSelector"/></colorSliderSelector>
		<colorHexTextBox><c path="funkin.editors.ui.UITextBox"/></colorHexTextBox>
		<rgbNumSteppers expr="[]">
			<c path="Array"><c path="funkin.editors.ui.UINumericStepper"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</rgbNumSteppers>
		<curColor public="1"><x path="Null"><x path="flixel.util.FlxColor"/></x></curColor>
		<curColorString public="1" expr="&quot;#FFFFFF&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"#FFFFFF"</e></m></meta>
		</curColorString>
		<saturation public="1"><x path="Float"/></saturation>
		<brightness public="1"><x path="Float"/></brightness>
		<hue public="1"><x path="Float"/></hue>
		<updateColorPickerSelector get="inline" set="null" line="95"><f a=""><x path="Void"/></f></updateColorPickerSelector>
		<updateColorPickerMouse get="inline" set="null" line="97"><f a="mousePos">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></updateColorPickerMouse>
		<updateColorSliderPickerSelector get="inline" set="null" line="102"><f a=""><x path="Void"/></f></updateColorSliderPickerSelector>
		<updateColorSliderMouse get="inline" set="null" line="105"><f a="mousePos">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></updateColorSliderMouse>
		<updateWheel public="1" set="method" line="107">
			<f a="?checkChanged" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkChanged : true }</e></m></meta>
		</updateWheel>
		<colorChanged public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</colorChanged>
		<selectedSprite expr="null">
			<x path="Null"><c path="flixel.FlxSprite"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</selectedSprite>
		<update public="1" set="method" line="131" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="27"><f a="x:y:?color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIColorWheelSelector" params="" file="source/funkin/editors/ui/UIColorwheel.hx" module="funkin.editors.ui.UIColorwheel">
		<extends path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></extends>
		<curColor public="1" expr="FlxColor.WHITE">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>FlxColor.WHITE</e></m></meta>
		</curColor>
		<selector public="1"><c path="flixel.FlxSprite"/></selector>
		<colorCircle public="1"><c path="flixel.FlxSprite"/></colorCircle>
		<update public="1" set="method" line="177" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="166"><f a="x:y:?color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UICompactColorwheel" params="" file="source/funkin/editors/ui/UICompactColorwheel.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<hitBoxExtenstion get="inline" set="null" expr="8" line="74" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</hitBoxExtenstion>
		<colorSlider><c path="flixel.FlxSprite"/></colorSlider>
		<colorSliderSelector><c path="funkin.editors.ui.UIColorWheelSelector"/></colorSliderSelector>
		<whiteColorButton><c path="funkin.editors.ui.UIButton"/></whiteColorButton>
		<curColor public="1"><x path="Null"><x path="flixel.util.FlxColor"/></x></curColor>
		<curColorString public="1" expr="&quot;#FFFFFF&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"#FFFFFF"</e></m></meta>
		</curColorString>
		<hue public="1"><x path="Float"/></hue>
		<updateColorSliderPickerSelector get="inline" set="null" line="53"><f a=""><x path="Void"/></f></updateColorSliderPickerSelector>
		<updateColorSliderMouse get="inline" set="null" line="56"><f a="mousePos">
	<x path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></updateColorSliderMouse>
		<setColor set="method" line="58"><f a="newColor">
	<x path="flixel.util.FlxColor"/>
	<x path="Void"/>
</f></setColor>
		<updateColor public="1" set="method" line="62">
			<f a="?checkChanged" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkChanged : true }</e></m></meta>
		</updateColor>
		<colorChanged public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</colorChanged>
		<selectedSprite expr="null">
			<x path="Null"><c path="flixel.FlxSprite"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</selectedSprite>
		<update public="1" set="method" line="77" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="20"><f a="x:y:?color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIContextMenu" params="" file="source/funkin/editors/ui/UIContextMenu.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<options public="1"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></options>
		<x><x path="Float"/></x>
		<y><x path="Float"/></y>
		<w expr="100">
			<x path="Int"/>
			<meta><m n=":value"><e>100</e></m></meta>
		</w>
		<contextCam><c path="flixel.FlxCamera"/></contextCam>
		<bg><c path="funkin.editors.ui.UISliceSprite"/></bg>
		<callback><t path="funkin.editors.ui.UIContextMenuCallback"/></callback>
		<contextMenuOptions public="1" expr="[]">
			<c path="Array"><c path="funkin.editors.ui.UIContextMenuOptionSpr"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</contextMenuOptions>
		<separators public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxSprite"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</separators>
		<scroll expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</scroll>
		<flipped expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</flipped>
		<__oobDeletion expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__oobDeletion>
		<preventOutOfBoxClickDeletion public="1" get="inline" set="null" line="24"><f a=""><x path="Void"/></f></preventOutOfBoxClickDeletion>
		<create public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></create>
		<select public="1" set="method" line="101"><f a="option">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></select>
		<update public="1" set="method" line="111" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method" line="126" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="28">
			<f a="options:callback:x:y:?w" v="::::100">
				<c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c>
				<t path="funkin.editors.ui.UIContextMenuCallback"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 100 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.ui.UIContextMenuCallback" params="" file="source/funkin/editors/ui/UIContextMenu.hx" module="funkin.editors.ui.UIContextMenu"><f a="::">
	<c path="funkin.editors.ui.UIContextMenu"/>
	<x path="Int"/>
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></typedef>
	<typedef path="funkin.editors.ui.UIContextMenuOption" params="" file="source/funkin/editors/ui/UIContextMenu.hx" module="funkin.editors.ui.UIContextMenu"><a>
	<onSelect>
		<x path="Null"><f a="">
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</onSelect>
	<onCreate>
		<x path="Null"><f a="">
	<c path="funkin.editors.ui.UIContextMenuOptionSpr"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</onCreate>
	<label><c path="String"/></label>
	<keybinds>
		<x path="Null"><c path="Array"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></c></x>
		<meta><m n=":optional"/></meta>
	</keybinds>
	<keybindText>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</keybindText>
	<keybind>
		<x path="Null"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></x>
		<meta><m n=":optional"/></meta>
	</keybind>
	<icon>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</icon>
	<color>
		<x path="Null"><x path="flixel.util.FlxColor"/></x>
		<meta><m n=":optional"/></meta>
	</color>
	<closeOnSelect>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</closeOnSelect>
	<childs>
		<x path="Null"><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></x>
		<meta><m n=":optional"/></meta>
	</childs>
	<button>
		<x path="Null"><c path="funkin.editors.ui.UIContextMenuOptionSpr"/></x>
		<meta><m n=":optional"/></meta>
	</button>
</a></typedef>
	<class path="funkin.editors.ui.UIContextMenuOptionSpr" params="" file="source/funkin/editors/ui/UIContextMenu.hx" module="funkin.editors.ui.UIContextMenu">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<label public="1"><c path="funkin.editors.ui.UIText"/></label>
		<labelKeybind public="1"><c path="funkin.editors.ui.UIText"/></labelKeybind>
		<icon public="1"><c path="flixel.FlxSprite"/></icon>
		<option public="1"><t path="funkin.editors.ui.UIContextMenuOption"/></option>
		<parent><c path="funkin.editors.ui.UIContextMenu"/></parent>
		<draw public="1" set="method" line="199" override="1"><f a=""><x path="Void"/></f></draw>
		<onHovered public="1" set="method" line="211" override="1"><f a=""><x path="Void"/></f></onHovered>
		<new public="1" set="method" line="157"><f a="x:y:option:parent">
	<x path="Float"/>
	<x path="Float"/>
	<t path="funkin.editors.ui.UIContextMenuOption"/>
	<c path="funkin.editors.ui.UIContextMenu"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIDropDown" params="" file="source/funkin/editors/ui/UIDropDown.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<getItems public="1" set="method" line="26" static="1"><f a="options">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><t path="funkin.editors.ui.DropDownItem"/></c>
</f></getItems>
		<indexOfItemValue public="1" set="method" line="60" static="1"><f a="items:value">
	<c path="Array"><t path="funkin.editors.ui.DropDownItem"/></c>
	<d/>
	<x path="Int"/>
</f></indexOfItemValue>
		<indexOfItemLabel public="1" set="method" line="64" static="1"><f a="items:str">
	<c path="Array"><t path="funkin.editors.ui.DropDownItem"/></c>
	<c path="String"/>
	<x path="Int"/>
</f></indexOfItemLabel>
		<dropButton public="1"><c path="funkin.editors.ui.UIButton"/></dropButton>
		<dropIcon public="1"><c path="flixel.FlxSprite"/></dropIcon>
		<label public="1"><c path="funkin.editors.ui.UIText"/></label>
		<index public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</index>
		<options public="1"><c path="Array"><c path="String"/></c></options>
		<items public="1"><c path="Array"><t path="funkin.editors.ui.DropDownItem"/></c></items>
		<key public="1" get="accessor" set="null"><c path="String"/></key>
		<get_key get="inline" set="null" line="14"><f a=""><c path="String"/></f></get_key>
		<value public="1" get="accessor" set="null"><d/></value>
		<get_value get="inline" set="null" line="18"><f a=""><d/></f></get_value>
		<onChange public="1"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></onChange>
		<curMenu expr="null">
			<c path="funkin.editors.ui.UIContextMenu"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curMenu>
		<setOption public="1" set="method" line="68"><f a="newIndex">
	<x path="Int"/>
	<x path="Void"/>
</f></setOption>
		<update public="1" set="method" line="76" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<openContextMenu public="1" set="method" line="89"><f a=""><x path="Void"/></f></openContextMenu>
		<new public="1" set="method" line="30">
			<f a="x:y:?width:?height:_options:?index" v="::320:32::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.util.typeLimit.OneOfTwo">
	<t path="funkin.editors.ui.DropDownItem"/>
	<c path="String"/>
</x></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ index : 0, height : 32, width : 320 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.ui.DropDownItem" params="" file="source/funkin/editors/ui/UIDropDown.hx" module="funkin.editors.ui.UIDropDown"><a>
	<value><d/></value>
	<label><c path="String"/></label>
</a></typedef>
	<class path="funkin.editors.ui.UIFileExplorer" params="" file="source/funkin/editors/ui/UIFileExplorer.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<uploadButton public="1"><c path="funkin.editors.ui.UIButton"/></uploadButton>
		<uploadIcon public="1"><c path="flixel.FlxSprite"/></uploadIcon>
		<deleteButton public="1"><c path="funkin.editors.ui.UIButton"/></deleteButton>
		<deleteIcon public="1"><c path="flixel.FlxSprite"/></deleteIcon>
		<file public="1" expr="null">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</file>
		<filePath public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</filePath>
		<onFile public="1"><f a=":">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></onFile>
		<uiElement public="1"><c path="flixel.FlxSprite"/></uiElement>
		<fileType public="1" expr="&quot;txt&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"txt"</e></m></meta>
		</fileType>
		<update public="1" set="method" line="49" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<loadFile public="1" set="method" line="64"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></loadFile>
		<removeFile public="1" set="method" line="71"><f a=""><x path="Void"/></f></removeFile>
		<new public="1" set="method" line="21">
			<f a="x:y:?w:?h:?fileType:?onFile" v="::::&quot;txt&quot;:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<f a=":">
					<c path="String"/>
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fileType : "txt" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIIconColorPicker" params="" file="source/funkin/editors/ui/UIIconColorPicker.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<colorWheel public="1"><c path="funkin.editors.ui.UIColorwheel"/></colorWheel>
		<iconSprite public="1"><c path="flixel.FlxSprite"/></iconSprite>
		<iconTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></iconTextBox>
		<pickerButton public="1"><c path="funkin.editors.ui.UIButton"/></pickerButton>
		<pickerIcon public="1"><c path="flixel.FlxSprite"/></pickerIcon>
		<__path expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</__path>
		<updateIcon public="1" set="method" line="40"><f a="icon">
	<c path="String"/>
	<x path="Void"/>
</f></updateIcon>
		<__cachedColor expr="null">
			<x path="Null"><x path="flixel.util.FlxColor"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</__cachedColor>
		<colorPick public="1" set="method" line="64"><f a=""><x path="Void"/></f></colorPick>
		<new public="1" set="method" line="17"><f a="x:y:icon:antialaising:colorWheel">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="funkin.editors.ui.UIColorwheel"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.ui.ImageSaveData" params="" file="source/funkin/editors/ui/UIImageExplorer.hx" module="funkin.editors.ui.UIImageExplorer"><a>
	<isAtlas><x path="Bool"/></isAtlas>
	<imageName><c path="String"/></imageName>
	<imageFiles><t path="Map">
	<c path="String"/>
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<c path="haxe.io.Bytes"/>
	</x>
</t></imageFiles>
	<directory><c path="String"/></directory>
</a></typedef>
	<class path="funkin.editors.ui.UIImageExplorer" params="" file="source/funkin/editors/ui/UIImageExplorer.hx">
		<extends path="funkin.editors.ui.UIFileExplorer"/>
		<ANIMATE_ATLAS_REGEX expr="~/^(?:Animation\.json|spritemap(?:\d+)?\.json)$/" line="78" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^(?:Animation\.json|spritemap(?:\d+)?\.json)$/</e></m></meta>
		</ANIMATE_ATLAS_REGEX>
		<SPRITEMAP_JSON_REGEX expr="~/^(?:spritemap(?:\d+)?\.json)$/" line="79" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^(?:spritemap(?:\d+)?\.json)$/</e></m></meta>
		</SPRITEMAP_JSON_REGEX>
		<SPRITEMAP_PNG_REGEX expr="~/^(?:spritemap(?:\d+)?\.png)$/" line="80" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^(?:spritemap(?:\d+)?\.png)$/</e></m></meta>
		</SPRITEMAP_PNG_REGEX>
		<serializeSaveDataGlobal public="1" set="method" line="313" static="1"><f a="data">
	<t path="funkin.editors.ui.ImageSaveData"/>
	<c path="String"/>
</f></serializeSaveDataGlobal>
		<deserializeSaveDataGlobal public="1" set="method" line="316" static="1"><f a="data">
	<c path="String"/>
	<t path="funkin.editors.ui.ImageSaveData"/>
</f></deserializeSaveDataGlobal>
		<saveFilesGlobal public="1" set="method" line="318" static="1">
			<f a="imageData:directory:?onFinishSaving:?checkExisting" v=":::true">
				<t path="funkin.editors.ui.ImageSaveData"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkExisting : true }</e></m></meta>
		</saveFilesGlobal>
		<allowAtlases expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowAtlases>
		<allowDirectories expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowDirectories>
		<directoryButton public="1"><c path="funkin.editors.ui.UIButton"/></directoryButton>
		<directoryIcon public="1"><c path="funkin.editors.ui.UIText"/></directoryIcon>
		<directoryBG public="1"><c path="funkin.editors.ui.UISliceSprite"/></directoryBG>
		<directoryTextBoxLabel public="1"><c path="funkin.editors.ui.UIText"/></directoryTextBoxLabel>
		<directoryTextBox public="1"><c path="funkin.editors.ui.UITextBox"/></directoryTextBox>
		<translate get="inline" set="null" line="39"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<isAtlas public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isAtlas>
		<imageName public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</imageName>
		<imageFiles public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<c path="String"/>
					<c path="haxe.io.Bytes"/>
				</x>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</imageFiles>
		<animationList public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</animationList>
		<fileText public="1"><c path="funkin.editors.ui.UIText"/></fileText>
		<maxSize public="1" expr="FlxPoint.get(700, 500)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(700, 500)</e></m></meta>
		</maxSize>
		<__firstLoad expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__firstLoad>
		<uploadImage public="1" set="method" line="91"><f a="filePath:file">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></uploadImage>
		<saveData public="1" expr="null">
			<t path="funkin.editors.ui.ImageSaveData"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</saveData>
		<getSaveData public="1" get="inline" set="null" line="299"><f a=""><t path="funkin.editors.ui.ImageSaveData"/></f></getSaveData>
		<saveFiles public="1" get="inline" set="null" line="308">
			<f a="directory:?onFinishSaving:?checkExisting" v="::true">
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkExisting : true }</e></m></meta>
		</saveFiles>
		<removeFile public="1" set="method" line="363" override="1"><f a=""><x path="Void"/></f></removeFile>
		<__resetData get="inline" set="null" line="376">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__resetData>
		<destroy public="1" set="method" line="380" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="41">
			<f a="x:y:image:?w:?h:?onFile:?directory" v="::::::&quot;images&quot;">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<f a=":">
					<c path="String"/>
					<c path="haxe.io.Bytes"/>
					<x path="Void"/>
				</f>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ directory : "images" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UINumericStepper" params="" file="source/funkin/editors/ui/UINumericStepper.hx">
		<extends path="funkin.editors.ui.UITextBox"/>
		<value public="1" set="accessor"><x path="Float"/></value>
		<precision public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</precision>
		<min public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</min>
		<max public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</max>
		<step public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</step>
		<__onChange set="method" line="25"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></__onChange>
		<set_value set="method" line="32"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_value>
		<new public="1" set="method" line="10">
			<f a="x:y:?value:?step:?precision:?min:?max:?w:?h:?small" v="::0:1:0:::180:32:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ small : false, h : 32, w : 180, precision : 0, step : 1, value : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIRadioButton" params="" file="source/funkin/editors/ui/UIRadioButton.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<checked public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</checked>
		<onChecked public="1" expr="null">
			<f a="">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onChecked>
		<field public="1"><c path="funkin.editors.ui.UIText"/></field>
		<check public="1"><c path="flixel.FlxSprite"/></check>
		<parent public="1" expr="null">
			<x path="flixel.util.typeLimit.OneOfTwo">
				<c path="funkin.editors.ui.UIWindow"/>
				<c path="funkin.editors.ui.UISubstateWindow"/>
			</x>
			<meta><m n=":value"><e>null</e></m></meta>
		</parent>
		<forID public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</forID>
		<targetScale public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</targetScale>
		<update public="1" set="method" line="40" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updatePositions public="1" get="inline" set="null" line="56"><f a=""><x path="Void"/></f></updatePositions>
		<draw public="1" set="method" line="61" override="1"><f a=""><x path="Void"/></f></draw>
		<onHovered public="1" set="method" line="66" override="1"><f a=""><x path="Void"/></f></onHovered>
		<updateButton public="1" set="method" line="94" override="1"><f a=""><x path="Void"/></f></updateButton>
		<toString public="1" set="method" line="99" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="15">
			<f a="x:y:text:?checked:?forID:?w" v=":::false:null:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 0, forID : null, checked : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIScrollBar" params="" file="source/funkin/editors/ui/UIScrollBar.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<length public="1"><x path="Float"/></length>
		<start public="1"><x path="Float"/></start>
		<size public="1"><x path="Float"/></size>
		<thumb public="1"><c path="funkin.editors.ui.UISliceSprite"/></thumb>
		<thumbIcon public="1"><c path="flixel.FlxSprite"/></thumbIcon>
		<value public="1"><x path="Float"/></value>
		<onChange public="1"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></onChange>
		<isScrolling public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isScrolling>
		<update public="1" set="method" line="36" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="17">
			<f a="x:y:length:start:size:?w:?h" v=":::::20:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 20 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.ui.SliderSegment" params="" file="source/funkin/editors/ui/UISlider.hx" module="funkin.editors.ui.UISlider"><a>
	<start><x path="Float"/></start>
	<size><x path="Float"/></size>
	<end><x path="Float"/></end>
</a></typedef>
	<class path="funkin.editors.ui.UISlider" params="" file="source/funkin/editors/ui/UISlider.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<segments public="1" expr="[]">
			<c path="Array"><t path="funkin.editors.ui.SliderSegment"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</segments>
		<barWidth public="1" expr="120">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</barWidth>
		<progressbar public="1"><c path="funkin.editors.ui.UISprite"/></progressbar>
		<progressCentered public="1"><x path="Bool"/></progressCentered>
		<startText public="1"><c path="funkin.editors.ui.UIText"/></startText>
		<endText public="1"><c path="funkin.editors.ui.UIText"/></endText>
		<selectableBar public="1"><c path="funkin.editors.ui.UISprite"/></selectableBar>
		<selectableBarHighlight public="1"><c path="funkin.editors.ui.UISprite"/></selectableBarHighlight>
		<selectableHitbox public="1"><c path="funkin.editors.ui.UISprite"/></selectableHitbox>
		<value public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</value>
		<set_value public="1" set="method" line="29"><f a="newVal">
	<x path="Float"/>
	<x path="Float"/>
</f></set_value>
		<valueStepper public="1"><c path="funkin.editors.ui.UINumericStepper"/></valueStepper>
		<onChange public="1"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></onChange>
		<__barProgress expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__barProgress>
		<visualProgress expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</visualProgress>
		<__stepperWidth expr="25">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</__stepperWidth>
		<isSliding public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isSliding>
		<update public="1" set="method" line="99" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<__calcValue set="method" line="137"><f a="progress">
	<x path="Float"/>
	<x path="Float"/>
</f></__calcValue>
		<__calcProgress set="method" line="149"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></__calcProgress>
		<new public="1" set="method" line="39">
			<f a="x:y:?width:value:segments:centered" v="::120:::">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="Array"><t path="funkin.editors.ui.SliderSegment"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ width : 120 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIText" params="" file="source/funkin/editors/ui/UIText.hx">
		<extends path="funkin.backend.FunkinText"/>
		<optimized public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</optimized>
		<applyBorderStyle public="1" set="method" line="25" override="1"><f a=""><x path="Void"/></f></applyBorderStyle>
		<new public="1" set="method" line="9">
			<f a="x:y:w:text:?size:?color:?outline" v="::::15:0xFFFFFFFF:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Null"><c path="String"/></x>
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ outline : true, color : 0xFFFFFFFF, size : 15 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UITopMenu" params="" file="source/funkin/editors/ui/UITopMenu.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<options><c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c></options>
		<anyMenuOpened public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</anyMenuOpened>
		<update public="1" set="method" line="22" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="7"><f a="options">
	<c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.UIUtil" params="" file="source/funkin/editors/ui/UIUtil.hx">
		<follow public="1" set="method" line="11" static="1">
			<f a="spr:target:?x:?y" v="::0:0">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</follow>
		<contextMenuOpened public="1" set="method" line="18" static="1"><f a="contextMenu">
	<c path="funkin.editors.ui.UIContextMenu"/>
	<x path="Bool"/>
</f></contextMenuOpened>
		<fixKey public="1" set="method" line="22" static="1">
			<f a="key">
				<x path="flixel.input.keyboard.FlxKey"/>
				<x path="flixel.input.keyboard.FlxKey"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</fixKey>
		<getKeyState public="1" set="method" line="31" static="1"><f a="key:Status">
	<x path="flixel.input.keyboard.FlxKey"/>
	<x path="flixel.input.FlxInputState"/>
	<x path="Bool"/>
</f></getKeyState>
		<processShortcuts public="1" set="method" line="39" static="1">
			<f a="topMenuOptions">
				<c path="Array"><t path="funkin.editors.ui.UIContextMenuOption"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Process all options with shortcuts present in a `Array&lt;UIContextMenuOption&gt;`. Also checks children.
	 * @param topMenuOptions</haxe_doc>
		</processShortcuts>
		<toUIString public="1" set="method" line="92" static="1"><f a="key">
	<x path="flixel.input.keyboard.FlxKey"/>
	<c path="String"/>
</f></toUIString>
		<prettify public="1" get="inline" set="null" line="127" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></prettify>
		<confirmUISelections public="1" set="method" line="135" static="1">
			<f a="ui">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* For when the user closes out before confriming all ui selections
	 * @param ui the thingy you wanna check</haxe_doc>
		</confirmUISelections>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>flixel.FlxSprite</e></m>
		</meta>
	</class>
	<class path="funkin.editors.ui.UIWarningSubstate" params="" file="source/funkin/editors/ui/UIWarningSubstate.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<camShaders expr="[]">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</camShaders>
		<blurShader expr="{  var _ = new CustomShader(Options.intensiveBlur ? &quot;engine/editorBlur&quot; : &quot;engine/editorBlurFast&quot;);  if (!Options.intensiveBlur) {   var noiseTexture:ShaderInput&lt;openfl.display.BitmapData&gt; = _.data.noiseTexture;   noiseTexture.input = Assets.getBitmapData(&quot;assets/shaders/noise256.png&quot;);   noiseTexture.wrap = REPEAT;   var noiseTextureSize:ShaderParameter&lt;Float&gt; = _.data.noiseTextureSize;   noiseTextureSize.value = [noiseTexture.input.width, noiseTexture.input.height];  };  _; }">
			<c path="funkin.backend.shaders.CustomShader"/>
			<meta><m n=":value"><e>{
	var _ = new CustomShader(Options.intensiveBlur ? "engine/editorBlur" : "engine/editorBlurFast");
	if (!Options.intensiveBlur) {
		var noiseTexture:ShaderInput&lt;openfl.display.BitmapData&gt; = _.data.noiseTexture;
		noiseTexture.input = Assets.getBitmapData("assets/shaders/noise256.png");
		noiseTexture.wrap = REPEAT;
		var noiseTextureSize:ShaderParameter&lt;Float&gt; = _.data.noiseTextureSize;
		noiseTextureSize.value = [noiseTexture.input.width, noiseTexture.input.height];
	};
	_;
}</e></m></meta>
		</blurShader>
		<bHeight public="1" expr="232">
			<x path="Int"/>
			<meta><m n=":value"><e>232</e></m></meta>
		</bHeight>
		<title><c path="String"/></title>
		<message><c path="String"/></message>
		<buttons><c path="Array"><t path="funkin.editors.ui.WarningButton"/></c></buttons>
		<isError expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</isError>
		<titleSpr><c path="funkin.editors.ui.UIText"/></titleSpr>
		<messageSpr><c path="funkin.editors.ui.UIText"/></messageSpr>
		<warnCam><c path="flixel.FlxCamera"/></warnCam>
		<onSubstateOpen public="1" set="method" line="37" override="1"><f a=""><x path="Void"/></f></onSubstateOpen>
		<create public="1" set="method" line="43" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="123" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="132">
			<f a="title:message:buttons:?isError" v=":::true">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><t path="funkin.editors.ui.WarningButton"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isError : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.editors.ui.WarningButton" params="" file="source/funkin/editors/ui/UIWarningSubstate.hx" module="funkin.editors.ui.UIWarningSubstate"><a>
	<onClick><f a="">
	<c path="funkin.editors.ui.UIWarningSubstate"/>
	<x path="Void"/>
</f></onClick>
	<label><c path="String"/></label>
	<color>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</color>
</a></typedef>
	<class path="funkin.editors.ui.notifications.UIBaseNotification" params="" file="source/funkin/editors/ui/notifications/UIBaseNotification.hx">
		<extends path="funkin.editors.ui.UISliceSprite"/>
		<textField public="1"><c path="funkin.editors.ui.UIText"/></textField>
		<closeButton public="1"><c path="funkin.editors.ui.UIButton"/></closeButton>
		<onRemove public="1" expr="null">
			<f a="notif">
				<c path="funkin.editors.ui.notifications.UIBaseNotification"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onRemove>
		<showedAnimation public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</showedAnimation>
		<closed public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</closed>
		<defaultX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</defaultX>
		<defaultY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</defaultY>
		<closingX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</closingX>
		<closingY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</closingY>
		<showingTimer public="1" expr="5">
			<x path="Float"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</showingTimer>
		<timerActive public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</timerActive>
		<progress public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</progress>
		<update public="1" set="method" line="94" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<appearAnimation public="1" set="method" line="114"><f a=""><x path="Void"/></f></appearAnimation>
		<isClosing public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isClosing>
		<disappearAnimation public="1" set="method" line="126"><f a=""><x path="Void"/></f></disappearAnimation>
		<idleDisappearAnimation public="1" set="method" line="146"><f a=""><x path="Void"/></f></idleDisappearAnimation>
		<new public="1" set="method" line="19">
			<f a="text:?showTimer:?corner" v=":5:BOTTOM_LEFT">
				<c path="String"/>
				<x path="Float"/>
				<x path="funkin.editors.ui.notifications.Corner"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ corner : BOTTOM_LEFT, showTimer : 5 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.editors.ui.notifications.Corner" params="" file="source/funkin/editors/ui/notifications/UIBaseNotification.hx" module="funkin.editors.ui.notifications.UIBaseNotification">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.editors.ui.notifications._UIBaseNotification.Corner_Impl_" params="" file="source/funkin/editors/ui/notifications/UIBaseNotification.hx" private="1" module="funkin.editors.ui.notifications.UIBaseNotification" extern="1" final="1">
	<TOP_LEFT public="1" get="inline" set="null" expr="cast 0" line="162" static="1">
		<x path="funkin.editors.ui.notifications.Corner"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TOP_LEFT>
	<TOP_RIGHT public="1" get="inline" set="null" expr="cast 1" line="163" static="1">
		<x path="funkin.editors.ui.notifications.Corner"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TOP_RIGHT>
	<BOTTOM_LEFT public="1" get="inline" set="null" expr="cast 2" line="164" static="1">
		<x path="funkin.editors.ui.notifications.Corner"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BOTTOM_LEFT>
	<BOTTOM_RIGHT public="1" get="inline" set="null" expr="cast 3" line="165" static="1">
		<x path="funkin.editors.ui.notifications.Corner"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</BOTTOM_RIGHT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.editors.ui.notifications._UIBaseNotification.Corner_Impl_" params="" file="source/funkin/editors/ui/notifications/UIBaseNotification.hx" private="1" module="funkin.editors.ui.notifications.UIBaseNotification" extern="1" final="1">
		<TOP_LEFT public="1" get="inline" set="null" expr="cast 0" line="162" static="1">
			<x path="funkin.editors.ui.notifications.Corner"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TOP_LEFT>
		<TOP_RIGHT public="1" get="inline" set="null" expr="cast 1" line="163" static="1">
			<x path="funkin.editors.ui.notifications.Corner"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TOP_RIGHT>
		<BOTTOM_LEFT public="1" get="inline" set="null" expr="cast 2" line="164" static="1">
			<x path="funkin.editors.ui.notifications.Corner"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BOTTOM_LEFT>
		<BOTTOM_RIGHT public="1" get="inline" set="null" expr="cast 3" line="165" static="1">
			<x path="funkin.editors.ui.notifications.Corner"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</BOTTOM_RIGHT>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.editors.ui.old.OldUISliceSpriteTri" params="" file="source/funkin/editors/ui/old/OldUISliceSpriteTri.hx">
		<extends path="funkin.editors.ui.UISprite"/>
		<getFixedSize get="inline" set="null" line="171" static="1"><f a="value:total">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getFixedSize>
		<bWidth public="1" set="accessor" expr="120">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</bWidth>
		<bHeight public="1" set="accessor" expr="20">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</bHeight>
		<framesOffset public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</framesOffset>
		<incorporeal public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</incorporeal>
		<updateButton public="1" set="method" line="25" override="1"><f a=""><x path="Void"/></f></updateButton>
		<resize public="1" set="method" line="31"><f a="w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<topAlpha public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":deprecated"/>
			</meta>
		</topAlpha>
		<middleAlpha public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":deprecated"/>
			</meta>
		</middleAlpha>
		<bottomAlpha public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":deprecated"/>
			</meta>
		</bottomAlpha>
		<drawTop public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</drawTop>
		<drawMiddle public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</drawMiddle>
		<drawBottom public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</drawBottom>
		<set_drawTop set="method" line="44"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_drawTop>
		<set_drawMiddle set="method" line="52"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_drawMiddle>
		<set_drawBottom set="method" line="60"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_drawBottom>
		<topleft expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</topleft>
		<top expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</top>
		<topright expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</topright>
		<middleleft expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</middleleft>
		<middle expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</middle>
		<middleright expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</middleright>
		<bottomleft expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bottomleft>
		<bottom expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bottom>
		<bottomright expr="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</bottomright>
		<topHeight public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</topHeight>
		<bottomHeight public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bottomHeight>
		<leftWidth public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</leftWidth>
		<rightWidth public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</rightWidth>
		<set_frames set="method" line="83" override="1"><f a="val">
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
</f></set_frames>
		<set_framesOffset set="method" line="89"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_framesOffset>
		<calculateFrames set="method" line="97"><f a=""><x path="Void"/></f></calculateFrames>
		<draw public="1" set="method" line="117" override="1"><f a=""><x path="Void"/></f></draw>
		<vertices expr="new DrawData&lt;Float&gt;()">
			<t path="flixel.graphics.tile.DrawData"><x path="Float"/></t>
			<meta><m n=":value"><e>new DrawData&lt;Float&gt;()</e></m></meta>
		</vertices>
		<indices expr="new DrawData&lt;Int&gt;()">
			<t path="flixel.graphics.tile.DrawData"><x path="Int"/></t>
			<meta><m n=":value"><e>new DrawData&lt;Int&gt;()</e></m></meta>
		</indices>
		<uvtData expr="new DrawData&lt;Float&gt;()">
			<t path="flixel.graphics.tile.DrawData"><x path="Float"/></t>
			<meta><m n=":value"><e>new DrawData&lt;Float&gt;()</e></m></meta>
		</uvtData>
		<colors expr="new DrawData&lt;Int&gt;()">
			<t path="flixel.graphics.tile.DrawData"><x path="Int"/></t>
			<meta><m n=":value"><e>new DrawData&lt;Int&gt;()</e></m></meta>
		</colors>
		<__framesDirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__framesDirty>
		<__meshDirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__meshDirty>
		<set_bWidth set="method" line="155"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_bWidth>
		<set_bHeight set="method" line="163"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_bHeight>
		<__genMesh set="method" line="175"><f a=""><x path="Void"/></f></__genMesh>
		<__genSliceQuad set="method" line="290"><f a="x:y:width:height:frame:leftSlice:topSlice">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="funkin.editors.ui.old.Quad"/>
	<c path="funkin.editors.ui.old.Quad"/>
	<c path="funkin.editors.ui.old.Quad"/>
</f></__genSliceQuad>
		<getBoundingBox set="method" line="399" override="1">
			<f a="camera">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<meta><m n=":access"><e>flixel.FlxCamera</e></m></meta>
		</getBoundingBox>
		<destroy public="1" set="method" line="412" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="15"><f a="x:y:w:h:path">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.editors.ui.old.Quad" params="" file="source/funkin/editors/ui/old/OldUISliceSpriteTri.hx" module="funkin.editors.ui.old.OldUISliceSpriteTri" final="1">
		<tl public="1"><x path="Int"/></tl>
		<tr public="1"><x path="Int"/></tr>
		<br public="1"><x path="Int"/></br>
		<bl public="1"><x path="Int"/></bl>
		<new public="1" set="method" line="428"><f a="tl:tr:br:bl">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.GameOverSubstate" params="" file="source/funkin/game/GameOverSubstate.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<script public="1" expr="Flags.DEFAULT_GAMEOVER_SCRIPT" line="27" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_GAMEOVER_SCRIPT</e></m></meta>
		</script>
		<instance public="1" expr="null" line="31" static="1">
			<c path="funkin.game.GameOverSubstate"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</instance>
		<character><c path="funkin.game.Character"/></character>
		<characterName public="1"><c path="String"/></characterName>
		<gameOverSong public="1"><c path="String"/></gameOverSong>
		<gameOverSongBPM public="1"><x path="Float"/></gameOverSongBPM>
		<lossSFXName public="1"><c path="String"/></lossSFXName>
		<retrySFX public="1"><c path="String"/></retrySFX>
		<player public="1"><x path="Bool"/></player>
		<camFollow><c path="flixel.FlxObject"/></camFollow>
		<gameoverScript public="1"><c path="funkin.backend.scripting.Script"/></gameoverScript>
		<game public="1" expr="PlayState.instance">
			<c path="funkin.game.PlayState"/>
			<meta><m n=":value"><e>PlayState.instance</e></m></meta>
		</game>
		<__cancelDefault expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__cancelDefault>
		<x expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<lossSFX public="1"><c path="flixel.sound.FlxSound"/></lossSFX>
		<create public="1" set="method" line="53" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="96" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<beatHit public="1" set="method" line="115" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="128" override="1"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<isEnding expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isEnding>
		<endBullshit set="method" line="136"><f a=""><x path="Void"/></f></endBullshit>
		<exit set="method" line="175"><f a=""><x path="Void"/></f></exit>
		<destroy public="1" set="method" line="194" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="40">
			<f a="x:y:?character:?player:?gameOverSong:?lossSFX:?retrySFX" v=":::true:::">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ player : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.HealthIcon" params="" file="source/funkin/game/HealthIcon.hx">
		<extends path="funkin.backend.FunkinSprite"/>
		<sprTracker public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Attaches the icon to a sprite, following it's position</haxe_doc>
		</sprTracker>
		<sprTrackerAlignment public="1" expr="RIGHT">
			<x path="funkin.game.TrackerAlignment"/>
			<meta><m n=":value"><e>RIGHT</e></m></meta>
			<haxe_doc>* Where to place the icon in relation to the sprite
	 *
	 * LEFT: Left of the sprite
	 *
	 * CENTER: Center of the sprite
	 *
	 * RIGHT: Right of the sprite</haxe_doc>
		</sprTrackerAlignment>
		<sprTrackerOffset public="1" expr="new FlxPoint(10, -30)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint(10, -30)</e></m></meta>
			<haxe_doc>* Offset of the icon in relation to the sprite
	 *
	 * By default it is set to (10, -30) and is intended to be used with Alphabet</haxe_doc>
		</sprTrackerOffset>
		<curCharacter public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The currently showing icon</haxe_doc>
		</curCharacter>
		<isPlayer public="1">
			<x path="Bool"/>
			<haxe_doc>* If the character is for the player</haxe_doc>
		</isPlayer>
		<healthSteps public="1" expr="null">
			<t path="Map">
				<x path="Int"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<c path="String"/>
					<x path="Int"/>
				</x>
			</t>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Health steps in this format:
	 *
	 * Min Percentage =&gt; Frame Index / Animation Name</haxe_doc>
		</healthSteps>
		<curAnimState public="1" expr="-1">
			<x path="flixel.util.typeLimit.OneOfTwo">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* Current animation state</haxe_doc>
		</curAnimState>
		<defaultScale public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The Default Scale For The Icon
	 *
	 * This is what scale the icon should return to when its bump animation is finished</haxe_doc>
		</defaultScale>
		<animated public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever or not the icon is animated or not</haxe_doc>
		</animated>
		<xmlData public="1">
			<c path="Xml"/>
			<haxe_doc>* XML Animated Icon data
	 *
	 * `null` if the icon is not animated or its invalid</haxe_doc>
		</xmlData>
		<extraOffsets public="1" expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Extra offsets to add when updating the hitbox</haxe_doc>
		</extraOffsets>
		<setHealthSteps public="1" set="method" line="87">
			<f a="steps">
				<c path="Array"><c path="Array"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<x path="Int"/>
</x></c></c>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":deprecated"><e>"use healthSteps instead"</e></m>
			</meta>
			<haxe_doc>* Helper for HScript who can't make maps
	 *
	 * THIS IS DEPRECATED AND WILL BE REMOVED IN THE FUTURE
	 *
	 * Please set the healthSteps directly in the script instead, hscript does support maps
	 *
	 * @param steps Something like this: `[[0, 1], [20, 0]]` or `[[0, "losing"], [20, "neutral"]]` for animated icons</haxe_doc>
		</setHealthSteps>
		<bump public="1" set="dynamic" line="113">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called every beat, and causes the icon to become bigger</haxe_doc>
		</bump>
		<updateBump public="1" set="dynamic" line="122">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called every frame and causes the icon to become smaller</haxe_doc>
		</updateBump>
		<setIcon public="1" set="method" line="133">
			<f a="char:?allowAnimated" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ allowAnimated : true }</e></m></meta>
			<haxe_doc>* Sets the icon to the specified character
	 * @param char Character to set the icon to
	 * @param allowAnimated Whenever the icon can be animated</haxe_doc>
		</setIcon>
		<normalizedNames expr="[&quot;neutral&quot;, &quot;losing&quot;, &quot;winning&quot;]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["neutral", "losing", "winning"]</e></m></meta>
		</normalizedNames>
		<normalizeAnim set="method" line="343"><f a="anim">
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<x path="Int"/>
	</x>
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<x path="Int"/>
	</x>
</f></normalizeAnim>
		<getIconAnim public="1" set="dynamic" line="365">
			<f a="health">
				<x path="Float"/>
				<c path="funkin.game.IconAnimData"/>
			</f>
			<haxe_doc>* Gets the animation data for a specific health percentage
	 * @param health Health percentage
	 * @return Animation data (-1 if invalid)</haxe_doc>
		</getIconAnim>
		<update public="1" set="method" line="380" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<animFinishCallback set="method" line="413"><f a="anim">
	<c path="String"/>
	<x path="Void"/>
</f></animFinishCallback>
		<updateHitbox public="1" set="method" line="419" override="1"><f a=""><x path="Void"/></f></updateHitbox>
		<new public="1" set="method" line="100">
			<f a="?char:?isPlayer" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isPlayer : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.IconAnimData" params="" file="source/funkin/game/HealthIcon.hx" module="funkin.game.HealthIcon">
		<animState public="1"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<x path="Int"/>
</x></animState>
		<isValid public="1"><x path="Bool"/></isValid>
		<toString public="1" set="method" line="435"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="430"><f a="animState:isValid">
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<x path="Int"/>
	</x>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<abstract path="funkin.game.TrackerAlignment" params="" file="source/funkin/game/HealthIcon.hx" module="funkin.game.HealthIcon">
		<this><x path="Int"/></this>
		<haxe_doc>* Used for `funkin.game.HealthIcon.sprTrackerAlignment`.
 * This determines the position of the icon in relation to the sprite tracker.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.game._HealthIcon.TrackerAlignment_Impl_" params="" file="source/funkin/game/HealthIcon.hx" private="1" module="funkin.game.HealthIcon" extern="1" final="1">
	<LEFT public="1" get="inline" set="null" expr="cast 0" line="450" static="1">
		<x path="funkin.game.TrackerAlignment"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Left of the sprite tracker
	 *
	 * Mathematically: `tracker.x - icon.width`</haxe_doc>
	</LEFT>
	<CENTER public="1" get="inline" set="null" expr="cast 1" line="456" static="1">
		<x path="funkin.game.TrackerAlignment"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Center of the sprite tracker
	 *
	 * Mathematically: `tracker.x + (tracker.width - icon.width) / 2`</haxe_doc>
	</CENTER>
	<RIGHT public="1" get="inline" set="null" expr="cast 2" line="462" static="1">
		<x path="funkin.game.TrackerAlignment"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>* Right of the sprite tracker
	 *
	 * Mathematically: `tracker.x + tracker.width`</haxe_doc>
	</RIGHT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.game._HealthIcon.TrackerAlignment_Impl_" params="" file="source/funkin/game/HealthIcon.hx" private="1" module="funkin.game.HealthIcon" extern="1" final="1">
		<LEFT public="1" get="inline" set="null" expr="cast 0" line="450" static="1">
			<x path="funkin.game.TrackerAlignment"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Left of the sprite tracker
	 *
	 * Mathematically: `tracker.x - icon.width`</haxe_doc>
		</LEFT>
		<CENTER public="1" get="inline" set="null" expr="cast 1" line="456" static="1">
			<x path="funkin.game.TrackerAlignment"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Center of the sprite tracker
	 *
	 * Mathematically: `tracker.x + (tracker.width - icon.width) / 2`</haxe_doc>
		</CENTER>
		<RIGHT public="1" get="inline" set="null" expr="cast 2" line="462" static="1">
			<x path="funkin.game.TrackerAlignment"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>* Right of the sprite tracker
	 *
	 * Mathematically: `tracker.x + tracker.width`</haxe_doc>
		</RIGHT>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.game.HudCamera" params="" file="source/funkin/game/HudCamera.hx">
		<extends path="flixel.FlxCamera"/>
		<downscroll public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the camera should flip the y axis.
	 * Keeps the sprites not flipped, but the positions are flipped.</haxe_doc>
		</downscroll>
		<alterScreenPosition public="1" set="method" line="31" override="1"><f a="spr:pos">
	<c path="flixel.FlxObject"/>
	<x path="flixel.math.FlxPoint"/>
	<x path="flixel.math.FlxPoint"/>
</f></alterScreenPosition>
		<new public="1" set="method" line="8"><f a="?X:?Y:?Width:?Height:?Zoom">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Camera meant for PlayState hud, allows for flipping the camera.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.Note" params="" file="source/funkin/game/Note.hx">
		<extends path="flixel.FlxSprite"/>
		<swagWidth public="1" expr="160 * 0.7" line="94" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>160 * 0.7</e></m></meta>
		</swagWidth>
		<__customNoteTypeExists expr="[]" line="96" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__customNoteTypeExists>
		<customTypePathExists set="method" line="101" static="1"><f a="path">
	<c path="String"/>
	<x path="Null"><x path="Bool"/></x>
</f></customTypePathExists>
		<DEFAULT_FIELDS expr="[&quot;time&quot;, &quot;id&quot;, &quot;type&quot;, &quot;sLen&quot;]" line="107" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["time", "id", "type", "sLen"]</e></m></meta>
		</DEFAULT_FIELDS>
		<__notePosFrameOffset expr="new FlxPoint()" line="230" static="1">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</__notePosFrameOffset>
		<__posPoint expr="new FlxPoint()" line="231" static="1">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</__posPoint>
		<extra public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extra>
		<strumTime public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</strumTime>
		<mustPress public="1" get="accessor" set="null"><x path="Bool"/></mustPress>
		<strumLine public="1" set="accessor"><c path="funkin.game.StrumLine"/></strumLine>
		<set_strumLine set="method" line="20"><f a="strLine">
	<c path="funkin.game.StrumLine"/>
	<c path="funkin.game.StrumLine"/>
</f></set_strumLine>
		<get_mustPress get="inline" set="null" line="30"><f a=""><x path="Bool"/></f></get_mustPress>
		<noteData public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</noteData>
		<canBeHit public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</canBeHit>
		<tooLate public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</tooLate>
		<wasGoodHit public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</wasGoodHit>
		<avoid public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever that note should be avoided by Botplay.</haxe_doc>
		</avoid>
		<prevNote public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* The note that comes before this one (sustain and not)</haxe_doc>
		</prevNote>
		<nextNote public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* The note that comes after this one (sustain and not)</haxe_doc>
		</nextNote>
		<nextSustain public="1">
			<c path="funkin.game.Note"/>
			<haxe_doc>* The next sustain after this one</haxe_doc>
		</nextSustain>
		<splash public="1" expr="&quot;default&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"default"</e></m></meta>
			<haxe_doc>* Name of the splash.</haxe_doc>
		</splash>
		<strumID public="1" get="accessor" set="null"><x path="Int"/></strumID>
		<get_strumID set="method" line="62"><f a=""><x path="Int"/></f></get_strumID>
		<sustainLength public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</sustainLength>
		<isSustainNote public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isSustainNote>
		<flipSustain public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</flipSustain>
		<noteTypeID public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</noteTypeID>
		<scrollSpeed public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</scrollSpeed>
		<noteAngle public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</noteAngle>
		<copyStrumAngle public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</copyStrumAngle>
		<updateNotesPosX public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</updateNotesPosX>
		<updateNotesPosY public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</updateNotesPosY>
		<updateFlipY public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</updateFlipY>
		<noteType public="1" get="accessor" set="null"><c path="String"/></noteType>
		<__strumCameras public="1" expr="null">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__strumCameras>
		<__strum public="1" expr="null">
			<c path="funkin.game.Strum"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__strum>
		<__noteAngle public="1" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__noteAngle>
		<get_noteType set="method" line="89"><f a=""><c path="String"/></f></get_noteType>
		<animSuffix public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</animSuffix>
		<lastScrollSpeed public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastScrollSpeed>
		<gapFix public="1" expr="0">
			<t path="funkin.SingleOrFloat"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</gapFix>
		<useAntialiasingFix public="1" get="accessor" set="accessor"><x path="Bool"/></useAntialiasingFix>
		<set_useAntialiasingFix get="inline" set="null" line="203"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useAntialiasingFix>
		<get_useAntialiasingFix get="inline" set="null" line="209"><f a=""><x path="Bool"/></f></get_useAntialiasingFix>
		<strumRelativePos public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the position of the note should be relative to the strum position or not.
	 * For example, if this is true, a note at the position 0; 0 will be on the strum, instead of at the top left of the screen.</haxe_doc>
		</strumRelativePos>
		<drawComplex set="method" line="219" override="1"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawComplex>
		<draw public="1" set="method" line="233" override="1"><f a=""><x path="Void"/></f></draw>
		<earlyPressWindow public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</earlyPressWindow>
		<latePressWindow public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</latePressWindow>
		<updateSustain public="1" set="method" line="274"><f a="strum">
	<c path="funkin.game.Strum"/>
	<x path="Void"/>
</f></updateSustain>
		<updateSustainClip public="1" set="method" line="289"><f a=""><x path="Void"/></f></updateSustainClip>
		<set_clipRect set="method" line="297" override="1">
			<f a="rect">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_clipRect>
		<destroy public="1" set="method" line="306" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="109">
			<f a="strumLine:noteData:?sustain:?sustainLength:?sustainOffset:?prev" v="::false:0:0:">
				<c path="funkin.game.StrumLine"/>
				<t path="funkin.backend.chart.ChartNote"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="funkin.game.Note"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sustainOffset : 0, sustainLength : 0, sustain : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.game.PlayState</e></m>
		</meta>
	</class>
	<class path="funkin.game.NoteGroup" params="" file="source/funkin/game/NoteGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.game.Note"/></extends>
		<__loopSprite><c path="funkin.game.Note"/></__loopSprite>
		<i expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</i>
		<__currentlyLooping expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__currentlyLooping>
		<__time expr="-1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.0</e></m></meta>
		</__time>
		<limit public="1" expr="Flags.DEFAULT_NOTE_MS_LIMIT">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.DEFAULT_NOTE_MS_LIMIT</e></m></meta>
			<haxe_doc>* How many milliseconds it should show a note before it should be hit</haxe_doc>
		</limit>
		<preallocate public="1" get="inline" set="null" line="24">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Preallocates the members array with nulls, but if theres anything in the array already it clears it</haxe_doc>
		</preallocate>
		<addNotes public="1" get="inline" set="null" line="32">
			<f a="notes">
				<c path="Array"><c path="funkin.game.Note"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds an array of notes to the group, and sorts them.</haxe_doc>
		</addNotes>
		<sortNotes public="1" get="inline" set="null" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sorts the notes in the group.</haxe_doc>
		</sortNotes>
		<__forcedSongPos public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__forcedSongPos>
		<__getSongPos get="inline" set="null" line="51">
			<f a=""><x path="Null"><x path="Float"/></x></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</__getSongPos>
		<update public="1" set="method" line="53" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="68" override="1"><f a=""><x path="Void"/></f></draw>
		<get public="1" set="method" line="93">
			<f a="id">
				<x path="Int"/>
				<c path="funkin.game.Note"/>
			</f>
			<haxe_doc>* Gets the correct order of notes</haxe_doc>
		</get>
		<forEach public="1" set="method" line="97" override="1">
			<f a="noteFunc:?recursive" v=":false">
				<f a="">
					<c path="funkin.game.Note"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
		</forEach>
		<forEachAlive public="1" set="method" line="114" override="1">
			<f a="noteFunc:?recursive" v=":false">
				<f a="">
					<c path="funkin.game.Note"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
		</forEachAlive>
		<remove public="1" set="method" line="121" override="1">
			<f a="Object:?Splice" v=":false">
				<c path="funkin.game.Note"/>
				<x path="Bool"/>
				<c path="funkin.game.Note"/>
			</f>
			<meta><m n=":value"><e>{ Splice : false }</e></m></meta>
		</remove>
		<new public="1" set="method" line="10"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Group of notes, that handles updating and rendering only the visible notes.
 * To only get the visible notes you gotta do `group.forEach()` or `group.forEachAlive()` instead of `group.members`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.PlayState" params="" file="source/funkin/game/PlayState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<instance public="1" expr="null" line="46" static="1">
			<c path="funkin.game.PlayState"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Current PlayState instance.</haxe_doc>
		</instance>
		<SONG public="1" static="1">
			<t path="funkin.backend.chart.ChartData"/>
			<haxe_doc>* SONG DATA (Chart, Metadata).</haxe_doc>
		</SONG>
		<isStoryMode public="1" expr="false" line="55" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the song is being played in Story Mode.</haxe_doc>
		</isStoryMode>
		<storyWeek public="1" expr="null" line="59" static="1">
			<t path="funkin.backend.week.WeekData"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The week data of the current week</haxe_doc>
		</storyWeek>
		<storyPlaylist public="1" expr="[]" line="63" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The remaining songs in the Story Mode playlist.</haxe_doc>
		</storyPlaylist>
		<difficulty public="1" expr="Flags.DEFAULT_DIFFICULTY" line="67" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_DIFFICULTY</e></m></meta>
			<haxe_doc>* The selected difficulty name.</haxe_doc>
		</difficulty>
		<fromMods public="1" expr="false" line="71" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the week is coming from the mods folder or not.</haxe_doc>
		</fromMods>
		<chartingMode public="1" expr="false" line="75" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever Charting Mode is enabled for this song.</haxe_doc>
		</chartingMode>
		<opponentMode public="1" expr="Flags.DEFAULT_OPPONENT_MODE" line="79" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>Flags.DEFAULT_OPPONENT_MODE</e></m></meta>
			<haxe_doc>* Whenever the song is started with opponent mode on.</haxe_doc>
		</opponentMode>
		<coopMode public="1" expr="Flags.DEFAULT_COOP_MODE" line="83" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>Flags.DEFAULT_COOP_MODE</e></m></meta>
			<haxe_doc>* Whenever the song is started with co-op mode on.</haxe_doc>
		</coopMode>
		<deathCounter public="1" expr="0" line="98" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Death counter on current week (or song if from freeplay).</haxe_doc>
		</deathCounter>
		<smoothTransitionData static="1">
			<t path="funkin.game.PlayStateTransitionData"/>
			<haxe_doc>* Previous cam follow.</haxe_doc>
		</smoothTransitionData>
		<campaignScore public="1" expr="0" line="342" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Score for the current week.</haxe_doc>
		</campaignScore>
		<campaignMisses public="1" expr="0" line="347" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Misses for the current week.</haxe_doc>
		</campaignMisses>
		<campaignAccuracy public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Accuracy for the current week.</haxe_doc>
		</campaignAccuracy>
		<campaignAccuracyTotal public="1" expr="0" line="354" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</campaignAccuracyTotal>
		<campaignAccuracyCount public="1" expr="0" line="355" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</campaignAccuracyCount>
		<daPixelZoom public="1" expr="Flags.PIXEL_ART_SCALE" line="417" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.PIXEL_ART_SCALE</e></m></meta>
			<haxe_doc>* Zoom for the pixel assets.</haxe_doc>
		</daPixelZoom>
		<seenCutscene public="1" expr="false" line="430" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the game has already played a specific cutscene for the current song. Check `startCutscene` for more details.</haxe_doc>
		</seenCutscene>
		<getSongChanges get="inline" set="null" line="1676" static="1"><f a=""><c path="Array"><e path="funkin.savedata.HighscoreChange"/></c></f></getSongChanges>
		<get_campaignAccuracy get="inline" set="null" line="2092" static="1"><f a=""><x path="Float"/></f></get_campaignAccuracy>
		<loadWeek public="1" set="method" line="2100" static="1">
			<f a="weekData:?difficulty">
				<t path="funkin.backend.week.WeekData"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Load a week into PlayState.
	 * @param weekData Week Data
	 * @param difficulty Week Difficulty</haxe_doc>
		</loadWeek>
		<loadSong public="1" set="method" line="2121" static="1">
			<f a="_name:?_difficulty:?_opponentMode:?_coopMode" v="::false:false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ _coopMode : false, _opponentMode : false }</e></m></meta>
			<haxe_doc>* Loads a song into PlayState
	 * @param name Song name
	 * @param difficulty Chart difficulty (if invalid, will load an empty chart)
	 * @param opponentMode Whenever opponent mode is on
	 * @param coopMode Whenever co-op mode is on.</haxe_doc>
		</loadSong>
		<__loadSong public="1" set="method" line="2135" static="1">
			<f a="_name:_difficulty">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* (INTERNAL) Loads a song without resetting story mode/opponent mode/coop mode values.
	 * @param name Song name
	 * @param difficulty Song difficulty</haxe_doc>
		</__loadSong>
		<scripts public="1">
			<c path="funkin.backend.scripting.ScriptPack"/>
			<haxe_doc>* Script Pack of all the scripts being ran.</haxe_doc>
		</scripts>
		<strumLines public="1" expr="new FlxTypedGroup&lt;StrumLine&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="funkin.game.StrumLine"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup&lt;StrumLine&gt;()</e></m></meta>
			<haxe_doc>* Array of all the players in the stage.</haxe_doc>
		</strumLines>
		<gameOverSong public="1" expr="Flags.DEFAULT_GAMEOVER_MUSIC">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_GAMEOVER_MUSIC</e></m></meta>
			<haxe_doc>* Game Over Song. (assets/music/gameOver.ogg).</haxe_doc>
		</gameOverSong>
		<lossSFX public="1" expr="Flags.DEFAULT_GAMEOVERSFX_SOUND">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_GAMEOVERSFX_SOUND</e></m></meta>
			<haxe_doc>* Game Over Song. (assets/sounds/gameOverSFX.ogg).</haxe_doc>
		</lossSFX>
		<retrySFX public="1" expr="Flags.DEFAULT_GAMEOVEREND_SOUND">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_GAMEOVEREND_SOUND</e></m></meta>
			<haxe_doc>* Game Over End SFX, used when retrying. (assets/sounds/gameOverEnd.ogg).</haxe_doc>
		</retrySFX>
		<stage public="1">
			<c path="funkin.game.Stage"/>
			<haxe_doc>* Current Stage.</haxe_doc>
		</stage>
		<validScore public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the score will save when you beat the song.</haxe_doc>
		</validScore>
		<canDie public="1" expr="!opponentMode &amp;&amp; !coopMode">
			<x path="Bool"/>
			<meta><m n=":value"><e>!opponentMode &amp;&amp; !coopMode</e></m></meta>
			<haxe_doc>* Whenever the player can die.</haxe_doc>
		</canDie>
		<ghostTapping public="1" expr="Options.ghostTapping">
			<x path="Bool"/>
			<meta><m n=":value"><e>Options.ghostTapping</e></m></meta>
			<haxe_doc>* Whenever Ghost Tapping is enabled.</haxe_doc>
		</ghostTapping>
		<canDadDie public="1" expr="opponentMode &amp;&amp; !coopMode">
			<x path="Bool"/>
			<meta><m n=":value"><e>opponentMode &amp;&amp; !coopMode</e></m></meta>
			<haxe_doc>* Whenever the opponent can die.</haxe_doc>
		</canDadDie>
		<scrollSpeed public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current scroll speed for all strums.
	 * To set a scroll speed for a specific strum, use `strum.scrollSpeed`.</haxe_doc>
		</scrollSpeed>
		<downscroll public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whenever the game is in downscroll or not. (Can be set)</haxe_doc>
		</downscroll>
		<set_downscroll get="inline" set="null" line="142"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_downscroll>
		<get_downscroll get="inline" set="null" line="143"><f a=""><x path="Bool"/></f></get_downscroll>
		<inst public="1">
			<c path="flixel.sound.FlxSound"/>
			<haxe_doc>* Instrumental sound (Inst.ogg).</haxe_doc>
		</inst>
		<vocals public="1">
			<c path="flixel.sound.FlxSound"/>
			<haxe_doc>* Vocals sound (Vocals.ogg).</haxe_doc>
		</vocals>
		<dad public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Dad character.</haxe_doc>
		</dad>
		<gf public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Girlfriend character.</haxe_doc>
		</gf>
		<boyfriend public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Boyfriend character.</haxe_doc>
		</boyfriend>
		<bf public="1" get="accessor" set="accessor">
			<c path="funkin.game.Character"/>
			<haxe_doc>* Boyfriend character.
	 * Same as boyfriend, just shorter.</haxe_doc>
		</bf>
		<strumLine public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Strum line position.</haxe_doc>
		</strumLine>
		<ratingNum public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Number of ratings.</haxe_doc>
		</ratingNum>
		<camFollow public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Object defining the camera follow target.</haxe_doc>
		</camFollow>
		<playerStrums public="1" get="accessor" set="accessor">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* Player strums.</haxe_doc>
		</playerStrums>
		<cpuStrums public="1" get="accessor" set="accessor">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* CPU strums.</haxe_doc>
		</cpuStrums>
		<player public="1" get="accessor" set="accessor">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* Shortcut to `playerStrums`.</haxe_doc>
		</player>
		<cpu public="1" get="accessor" set="accessor">
			<c path="funkin.game.StrumLine"/>
			<haxe_doc>* Shortcut to `cpuStrums`.</haxe_doc>
		</cpu>
		<splashHandler public="1">
			<c path="funkin.game.SplashHandler"/>
			<haxe_doc>* Note splashes container.</haxe_doc>
		</splashHandler>
		<muteVocalsOnMiss public="1" expr="Flags.DEFAULT_MUTE_VOCALS_ON_MISS">
			<x path="Bool"/>
			<meta><m n=":value"><e>Flags.DEFAULT_MUTE_VOCALS_ON_MISS</e></m></meta>
			<haxe_doc>* Whenever the vocals should be muted when a note is missed.</haxe_doc>
		</muteVocalsOnMiss>
		<canAccessDebugMenus public="1" expr="!Flags.DISABLE_EDITORS">
			<x path="Bool"/>
			<meta><m n=":value"><e>!Flags.DISABLE_EDITORS</e></m></meta>
			<haxe_doc>* Whenever the player can press 7, 8 or 9 to access the debug menus.</haxe_doc>
		</canAccessDebugMenus>
		<allowGitaroo public="1" expr="Flags.DEFAULT_GITAROO">
			<x path="Bool"/>
			<meta><m n=":value"><e>Flags.DEFAULT_GITAROO</e></m></meta>
			<haxe_doc>* Whether or not to show the secret gitaroo pause.</haxe_doc>
		</allowGitaroo>
		<doIconBop public="1" expr="Flags.DEFAULT_ICONBOP">
			<x path="Bool"/>
			<meta><m n=":value"><e>Flags.DEFAULT_ICONBOP</e></m></meta>
			<haxe_doc>* Whether or not to bop the icons on beat.</haxe_doc>
		</doIconBop>
		<curSong public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
			<haxe_doc>* Current song name (lowercase).</haxe_doc>
		</curSong>
		<curSongID public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
			<haxe_doc>* Current song name (lowercase and spaces to dashes).</haxe_doc>
		</curSongID>
		<curStage public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Current stage name.</haxe_doc>
		</curStage>
		<gfSpeed public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Interval at which Girlfriend dances.</haxe_doc>
		</gfSpeed>
		<health public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Current health. Goes from 0 to maxHealth (defaults to 2).</haxe_doc>
		</health>
		<maxHealth public="1" set="accessor" expr="Flags.DEFAULT_MAX_HEALTH">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.DEFAULT_MAX_HEALTH</e></m></meta>
			<haxe_doc>* Maximum health the player can have. Defaults to 2.</haxe_doc>
		</maxHealth>
		<combo public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current combo.</haxe_doc>
		</combo>
		<comboBreaks public="1" expr="!Options.ghostTapping">
			<x path="Bool"/>
			<meta><m n=":value"><e>!Options.ghostTapping</e></m></meta>
			<haxe_doc>* Whenever the misses should show "Combo Breaks" instead of "Misses".</haxe_doc>
		</comboBreaks>
		<healthBarBG public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Health bar background.</haxe_doc>
		</healthBarBG>
		<healthBar public="1">
			<c path="flixel.ui.FlxBar"/>
			<haxe_doc>* Health bar.</haxe_doc>
		</healthBar>
		<generatedMusic public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the music has been generated.</haxe_doc>
		</generatedMusic>
		<startingSong public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the song is currently being started.</haxe_doc>
		</startingSong>
		<iconP1 public="1">
			<c path="funkin.game.HealthIcon"/>
			<haxe_doc>* Player's icon.</haxe_doc>
		</iconP1>
		<iconP2 public="1">
			<c path="funkin.game.HealthIcon"/>
			<haxe_doc>* Opponent's icon.</haxe_doc>
		</iconP2>
		<iconArray public="1" expr="[]">
			<c path="Array"><c path="funkin.game.HealthIcon"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Every active icon that will be updated during gameplay (defaults to `iconP1` and `iconP1` between `create` and `postCreate` in scripts).</haxe_doc>
		</iconArray>
		<camHUD public="1">
			<c path="funkin.game.HudCamera"/>
			<haxe_doc>* Camera for the HUD (notes, misses).</haxe_doc>
		</camHUD>
		<camGame public="1">
			<c path="flixel.FlxCamera"/>
			<haxe_doc>* Camera for the game (stages, characters).</haxe_doc>
		</camGame>
		<songScore public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The player's current score.</haxe_doc>
		</songScore>
		<misses public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The player's amount of misses.</haxe_doc>
		</misses>
		<accuracy public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The player's accuracy (shortcut to `accuracyPressedNotes / totalAccuracyAmount`).</haxe_doc>
		</accuracy>
		<accuracyPressedNotes public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The number of pressed notes.</haxe_doc>
		</accuracyPressedNotes>
		<totalAccuracyAmount public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The total accuracy amount.</haxe_doc>
		</totalAccuracyAmount>
		<scoreTxt public="1">
			<c path="funkin.backend.FunkinText"/>
			<haxe_doc>* FunkinText that shows your score.</haxe_doc>
		</scoreTxt>
		<missesTxt public="1">
			<c path="funkin.backend.FunkinText"/>
			<haxe_doc>* FunkinText that shows your amount of misses.</haxe_doc>
		</missesTxt>
		<accuracyTxt public="1">
			<c path="funkin.backend.FunkinText"/>
			<haxe_doc>* FunkinText that shows your accuracy.</haxe_doc>
		</accuracyTxt>
		<defaultCamZoom public="1" expr="Flags.DEFAULT_CAM_ZOOM">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.DEFAULT_CAM_ZOOM</e></m></meta>
			<haxe_doc>* Camera zoom at which the game lerps to.</haxe_doc>
		</defaultCamZoom>
		<camGameZoomLerp public="1" expr="Flags.DEFAULT_CAM_ZOOM_LERP">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.DEFAULT_CAM_ZOOM_LERP</e></m></meta>
			<haxe_doc>* Speed at which the game camera zoom lerps to.</haxe_doc>
		</camGameZoomLerp>
		<defaultHudZoom public="1" expr="Flags.DEFAULT_HUD_ZOOM">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.DEFAULT_HUD_ZOOM</e></m></meta>
			<haxe_doc>* Camera zoom at which the hud lerps to.</haxe_doc>
		</defaultHudZoom>
		<camHUDZoomLerp public="1" expr="Flags.DEFAULT_HUD_ZOOM_LERP">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.DEFAULT_HUD_ZOOM_LERP</e></m></meta>
			<haxe_doc>* Speed at which the hud camera zoom lerps to.</haxe_doc>
		</camHUDZoomLerp>
		<camZooming public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever cam zooming is enabled, enables on a note hit if not cancelled.</haxe_doc>
		</camZooming>
		<camZoomingInterval public="1" expr="Flags.DEFAULT_CAM_ZOOM_INTERVAL">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.DEFAULT_CAM_ZOOM_INTERVAL</e></m></meta>
			<haxe_doc>* Interval of cam zooming (in conductor values).
	 * Example: If Interval is 1 and Beat Type is on MEASURE, it'll zoom every a measure.
	 * NOTE: Will set to 4 if not found any other time signatures unlike 4/4.</haxe_doc>
		</camZoomingInterval>
		<camZoomingOffset public="1" expr="Flags.DEFAULT_CAM_ZOOM_OFFSET">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.DEFAULT_CAM_ZOOM_OFFSET</e></m></meta>
			<haxe_doc>* Number of Conductor values to offset camZooming by.</haxe_doc>
		</camZoomingOffset>
		<camZoomingEvery public="1" expr="MEASURE">
			<e path="funkin.backend.system.BeatType"/>
			<meta><m n=":value"><e>MEASURE</e></m></meta>
			<haxe_doc>* Beat type for interval of cam zooming.
	 * Example: If Beat Type is on STEP and Interval is 2, it'll zoom every 2 steps.
	 * NOTE: Will set to BEAT if not found any other time signatures unlike 4/4.</haxe_doc>
		</camZoomingEvery>
		<camZoomingLastBeat public="1">
			<x path="Float"/>
			<haxe_doc>* Stores what was the last beat for the cam zooming intervals.</haxe_doc>
		</camZoomingLastBeat>
		<camZoomingStrength public="1" expr="Flags.DEFAULT_CAM_ZOOM_STRENGTH">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.DEFAULT_CAM_ZOOM_STRENGTH</e></m></meta>
			<haxe_doc>* How strong the cam zooms should be (defaults to 1).</haxe_doc>
		</camZoomingStrength>
		<maxCamZoomMult public="1" expr="Flags.MAX_CAMERA_ZOOM_MULT">
			<x path="Float"/>
			<meta><m n=":value"><e>Flags.MAX_CAMERA_ZOOM_MULT</e></m></meta>
			<haxe_doc>* Default multiplier for `maxCamZoom`.</haxe_doc>
		</maxCamZoomMult>
		<maxCamZoom public="1" get="accessor" expr="Math.NaN">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.NaN</e></m></meta>
			<haxe_doc>* Maximum amount of zoom for the camera (based on `maxCamZoomMult` and the camera's zoom IF not set).</haxe_doc>
		</maxCamZoom>
		<get_maxCamZoom get="inline" set="null" line="412"><f a=""><x path="Float"/></f></get_maxCamZoom>
		<inCutscene public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the game is currently in a cutscene or not.</haxe_doc>
		</inCutscene>
		<playCutscenes public="1" expr="isStoryMode">
			<x path="Bool"/>
			<meta><m n=":value"><e>isStoryMode</e></m></meta>
			<haxe_doc>* Whenever the game should play the cutscenes. Defaults to whenever the game is currently in Story Mode or not.</haxe_doc>
		</playCutscenes>
		<cutscene public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Cutscene script path.</haxe_doc>
		</cutscene>
		<endCutscene public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* End cutscene script path.</haxe_doc>
		</endCutscene>
		<curRating public="1">
			<c path="funkin.game.ComboRating"/>
			<haxe_doc>* Last rating (may be null).</haxe_doc>
		</curRating>
		<startTimer public="1">
			<c path="flixel.util.FlxTimer"/>
			<haxe_doc>* Timer for the start countdown.</haxe_doc>
		</startTimer>
		<events public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.chart.ChartEvent"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Remaining events.</haxe_doc>
		</events>
		<curCameraTarget public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current camera target. -1 means no automatic camera targeting.</haxe_doc>
		</curCameraTarget>
		<introLength public="1" expr="Flags.DEFAULT_INTRO_LENGTH">
			<x path="Int"/>
			<meta><m n=":value"><e>Flags.DEFAULT_INTRO_LENGTH</e></m></meta>
			<haxe_doc>* Length of the intro countdown.</haxe_doc>
		</introLength>
		<introSprites public="1" expr="Flags.DEFAULT_INTRO_SPRITES.copy()">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>Flags.DEFAULT_INTRO_SPRITES.copy()</e></m></meta>
			<haxe_doc>* Array of sprites for the intro.</haxe_doc>
		</introSprites>
		<introSounds public="1" expr="Flags.DEFAULT_INTRO_SOUNDS.copy()">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>Flags.DEFAULT_INTRO_SOUNDS.copy()</e></m></meta>
			<haxe_doc>* Array of sounds for the intro.</haxe_doc>
		</introSounds>
		<paused public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the game is paused or not.</haxe_doc>
		</paused>
		<startedCountdown public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the countdown has started or not.</haxe_doc>
		</startedCountdown>
		<canPause public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the game can be paused or not.</haxe_doc>
		</canPause>
		<accFormat public="1" expr="new FlxTextFormat(0xFF888888, false, false, 0)">
			<c path="flixel.text.FlxTextFormat"/>
			<meta><m n=":value"><e>new FlxTextFormat(0xFF888888, false, false, 0)</e></m></meta>
			<haxe_doc>* Format for the accuracy rating.</haxe_doc>
		</accFormat>
		<endingSong public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the song is ending or not.</haxe_doc>
		</endingSong>
		<comboGroup public="1">
			<c path="funkin.backend.system.RotatingSpriteGroup"/>
			<haxe_doc>* Group containing all of the combo sprites.</haxe_doc>
		</comboGroup>
		<defaultDisplayRating public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the Rating sprites should be shown or not.
	 *
	 * NOTE: This is just a default value for the final value, the final value can be changed through notes hit events.</haxe_doc>
		</defaultDisplayRating>
		<defaultDisplayCombo public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the Combo sprite should be shown or not (like old Week 7 patches).
	 *
	 * NOTE: This is just a default value for the final value, the final value can be changed through notes hit events.</haxe_doc>
		</defaultDisplayCombo>
		<minDigitDisplay public="1" expr="10">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
			<haxe_doc>* Minimum Combo Count to display the combo digits. Anything less than 0 means it won't be shown.</haxe_doc>
		</minDigitDisplay>
		<noteTypesArray public="1" expr="[null]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[null]</e></m></meta>
			<haxe_doc>* Array containing all of the note types names.</haxe_doc>
		</noteTypesArray>
		<hitWindow public="1" expr="Options.hitWindow">
			<x path="Float"/>
			<meta><m n=":value"><e>Options.hitWindow</e></m></meta>
			<haxe_doc>* Hit window, in milliseconds. Defaults to 250ms unless changed in options.
	 * Base game hit window is 175ms.</haxe_doc>
		</hitWindow>
		<_startCountdownCalled expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_startCountdownCalled>
		<_endSongCalled expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_endSongCalled>
		<__vocalSyncTimer expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__vocalSyncTimer>
		<get_accuracy set="method" line="529"><f a=""><x path="Float"/></f></get_accuracy>
		<set_accuracy set="method" line="533"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_accuracy>
		<comboRatings public="1" expr="[new ComboRating(0, &quot;F&quot;, 0xFFFF4444), new ComboRating(0.5, &quot;E&quot;, 0xFFFF8844), new ComboRating(0.7, &quot;D&quot;, 0xFFFFAA44), new ComboRating(0.8, &quot;C&quot;, 0xFFFFFF44), new ComboRating(0.85, &quot;B&quot;, 0xFFAAFF44), new ComboRating(0.9, &quot;A&quot;, 0xFF88FF44), new ComboRating(0.95, &quot;S&quot;, 0xFF44FFFF), new ComboRating(1, &quot;S++&quot;, 0xFF44FFFF)]">
			<c path="Array"><c path="funkin.game.ComboRating"/></c>
			<meta><m n=":value"><e>[new ComboRating(0, "F", 0xFFFF4444), new ComboRating(0.5, "E", 0xFFFF8844), new ComboRating(0.7, "D", 0xFFFFAA44), new ComboRating(0.8, "C", 0xFFFFFF44), new ComboRating(0.85, "B", 0xFFAAFF44), new ComboRating(0.9, "A", 0xFF88FF44), new ComboRating(0.95, "S", 0xFF44FFFF), new ComboRating(1, "S++", 0xFF44FFFF)]</e></m></meta>
			<haxe_doc>* All combo ratings.</haxe_doc>
		</comboRatings>
		<detailsText public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</detailsText>
		<detailsPausedText public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</detailsPausedText>
		<__cachedGraphics expr="[]">
			<c path="Array"><c path="flixel.graphics.FlxGraphic"/></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":unreflective"/>
			</meta>
		</__cachedGraphics>
		<updateRating public="1" set="method" line="561">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the rating.</haxe_doc>
		</updateRating>
		<set_health get="inline" set="null" line="575"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_health>
		<set_maxHealth get="inline" set="null" line="576"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxHealth>
		<get_curStage get="inline" set="null" line="584"><f a=""><c path="String"/></f></get_curStage>
		<set_curStage get="inline" set="null" line="586"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></set_curStage>
		<callOnCharacters public="1" get="inline" set="null" line="591"><f a="func:?parameters">
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></callOnCharacters>
		<gameAndCharsCall public="1" get="inline" set="null" line="598"><f a="func:?parameters:?charsFunc">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
	<x path="Void"/>
</f></gameAndCharsCall>
		<gameAndCharsEvent public="1" params="T" get="inline" set="null" line="603"><f a="func:?event:?charsFunc">
	<c path="String"/>
	<x path="Null"><c path="gameAndCharsEvent.T"/></x>
	<c path="String"/>
	<c path="gameAndCharsEvent.T"/>
</f></gameAndCharsEvent>
		<create public="1" set="method" line="610" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</create>
		<createPost public="1" set="method" line="864" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</createPost>
		<updateDiscordPresence public="1" set="dynamic" line="886">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function used to update Discord Presence.
	 *
	 * This function is dynamic, which means you can do `updateDiscordPresence = function() {}` in scripts.</haxe_doc>
		</updateDiscordPresence>
		<startCutscene public="1" set="method" line="896">
			<f a="?prefix:?cutsceneScriptPath:?callback:?checkSeen:?canSkipTransIn" v="&quot;&quot;:::false:true">
				<c path="String"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ canSkipTransIn : true, checkSeen : false, prefix : "" }</e></m></meta>
			<haxe_doc>* Starts a cutscene.
	 * @param prefix Custom prefix. Using `midsong-` will require you to for example rename your video cutscene to `songs/song/midsong-cutscene.mp4` instead of `songs/song/cutscene.mp4`
	 * @param cutsceneScriptPath Optional: Custom script path.
	 * @param callback Callback called after the cutscene ended. If equals to `null`, `startCountdown` will be called.
	 * @param checkSeen Bool that by default is false, if true and `seenCutscene` is also true, it won't play the cutscene but directly call `callback` (PS: `seenCutscene` becomes true if the cutscene gets played and `checkSeen` was true)
	 * @param canSkipTransIn Bool that by default is true makes the in transition skip on certain types of cutscenes like dialogues.</haxe_doc>
		</startCutscene>
		<startCountdown public="1" set="method" line="938">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</startCountdown>
		<countdown public="1" set="method" line="962">
			<f a="swagCounter">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a fake countdown.</haxe_doc>
		</countdown>
		<startSong set="method" line="1010">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</startSong>
		<destroy public="1" set="method" line="1026" override="1"><f a=""><x path="Void"/></f></destroy>
		<scrollSpeedTween public="1" get="accessor" set="accessor">
			<c path="flixel.tweens.FlxTween"/>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":deprecated"><e>"scrollSpeedTween is deprecated, use eventsTween['scrollSpeed'] instead"</e></m>
			</meta>
		</scrollSpeedTween>
		<get_scrollSpeedTween get="inline" set="null" line="1049">
			<f a=""><c path="flixel.tweens.FlxTween"/></f>
			<meta><m n=":deprecated"><e>"scrollSpeedTween is deprecated, use eventsTween['scrollSpeed'] instead"</e></m></meta>
		</get_scrollSpeedTween>
		<set_scrollSpeedTween get="inline" set="null" line="1050">
			<f a="val">
				<c path="flixel.tweens.FlxTween"/>
				<c path="flixel.tweens.FlxTween"/>
			</f>
			<meta><m n=":deprecated"><e>"scrollSpeedTween is deprecated, use eventsTween['scrollSpeed'] instead"</e></m></meta>
		</set_scrollSpeedTween>
		<generateSong set="method" line="1054">
			<f a="?songData">
				<x path="Null"><t path="funkin.backend.chart.ChartData"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</generateSong>
		<sortByShit set="method" line="1100">
			<f a="Obj1:Obj2">
				<c path="funkin.game.Note"/>
				<c path="funkin.game.Note"/>
				<x path="Int"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</sortByShit>
		<generateStrums get="inline" set="null" line="1105">
			<f a="?amount" v="null">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ amount : null }</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</generateStrums>
		<openSubState public="1" set="method" line="1114" override="1">
			<f a="SubState">
				<c path="flixel.FlxSubState"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</openSubState>
		<closeSubState public="1" set="method" line="1140" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</closeSubState>
		<getIconRPC public="1" get="inline" set="null" line="1165">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the Discord RPC icon.</haxe_doc>
		</getIconRPC>
		<onFocus public="1" set="method" line="1169" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onFocus>
		<onFocusLost public="1" set="method" line="1182" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onFocusLost>
		<resyncVocals set="method" line="1195">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</resyncVocals>
		<pauseGame public="1" set="method" line="1207">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pauses the game.</haxe_doc>
		</pauseGame>
		<saveWarn public="1" set="method" line="1228">
			<f a="?closingWindow" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ closingWindow : true }</e></m></meta>
		</saveWarn>
		<updateIconPositions set="dynamic" line="1272"><f a=""><x path="Void"/></f></updateIconPositions>
		<TEXT_GAME_SCORE expr="TU.getRaw(&quot;game.score&quot;)">
			<c path="funkin.backend.utils.translations.IFormatInfo"/>
			<meta><m n=":value"><e>TU.getRaw("game.score")</e></m></meta>
		</TEXT_GAME_SCORE>
		<TEXT_GAME_MISSES expr="TU.getRaw(&quot;game.misses&quot;)">
			<c path="funkin.backend.utils.translations.IFormatInfo"/>
			<meta><m n=":value"><e>TU.getRaw("game.misses")</e></m></meta>
		</TEXT_GAME_MISSES>
		<TEXT_GAME_COMBOBREAKS expr="TU.getRaw(&quot;game.comboBreaks&quot;)">
			<c path="funkin.backend.utils.translations.IFormatInfo"/>
			<meta><m n=":value"><e>TU.getRaw("game.comboBreaks")</e></m></meta>
		</TEXT_GAME_COMBOBREAKS>
		<TEXT_GAME_ACCURACY expr="TU.getRaw(&quot;game.accuracy&quot;)">
			<c path="funkin.backend.utils.translations.IFormatInfo"/>
			<meta><m n=":value"><e>TU.getRaw("game.accuracy")</e></m></meta>
		</TEXT_GAME_ACCURACY>
		<updateRatingStuff set="dynamic" line="1291"><f a=""><x path="Void"/></f></updateRatingStuff>
		<update public="1" set="method" line="1312" override="1">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</update>
		<draw public="1" set="method" line="1401" override="1"><f a=""><x path="Void"/></f></draw>
		<moveCamera public="1" set="method" line="1408"><f a=""><x path="Void"/></f></moveCamera>
		<getStrumlineCamPos public="1" get="inline" set="null" line="1424">
			<f a="strumLine:?pos:?ignoreInvisible" v=":null:true">
				<x path="Int"/>
				<x path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
				<c path="funkin.game.CamPosData"/>
			</f>
			<meta><m n=":value"><e>{ ignoreInvisible : true, pos : null }</e></m></meta>
			<haxe_doc>* Returns the camera position of the specified strumline.
	 * @param strumLine The strumline to get the camera position of.
	 * @param pos The position to put the camera position in. If `null`, a new FlxPoint will be created.
	 * @param ignoreInvisible Whenever invisible characters should be ignored.</haxe_doc>
		</getStrumlineCamPos>
		<getCharactersCamPos public="1" set="dynamic" line="1434">
			<f a="chars:?pos:?ignoreInvisible" v=":null:true">
				<c path="Array"><c path="funkin.game.Character"/></c>
				<x path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
				<c path="funkin.game.CamPosData"/>
			</f>
			<meta><m n=":value"><e>{ ignoreInvisible : true, pos : null }</e></m></meta>
			<haxe_doc>* Returns the camera position of the specified characters.
	 * @param chars The characters to get the camera position of.
	 * @param pos The position to put the camera position in. If `null`, a new FlxPoint will be created.
	 * @param ignoreInvisible Whenever invisible characters should be ignored.</haxe_doc>
		</getCharactersCamPos>
		<eventsTween public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.tweens.FlxTween"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</eventsTween>
		<executeEvent public="1" set="method" line="1455"><f a="event">
	<t path="funkin.backend.chart.ChartEvent"/>
	<x path="Void"/>
</f></executeEvent>
		<__updateNote_event public="1" expr="null">
			<c path="funkin.backend.scripting.events.note.NoteUpdateEvent"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__updateNote_event>
		<gameOver public="1" set="method" line="1609">
			<f a="?character:?deathCharID:?gameOverSong:?lossSFX:?retrySFX">
				<c path="funkin.game.Character"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Forces a game over.
	 * @param character Character which died. Default to `boyfriend`.
	 * @param deathCharID Character ID (name) for game over. Default to whatever is specified in the character's XML.
	 * @param gameOverSong Song for the game over screen. Default to `this.gameOverSong` (`gameOver`)
	 * @param lossSFX SFX at the beginning of the game over (Mic drop). Default to `this.lossSFX` (`gameOverSFX`)
	 * @param retrySFX SFX played whenever the player retries. Defaults to `retrySFX` (`gameOverEnd`)</haxe_doc>
		</gameOver>
		<endSong public="1" set="method" line="1647">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Ends the song.</haxe_doc>
		</endSong>
		<nextSong public="1" set="method" line="1688">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately switches to the next song, or goes back to the Story/Freeplay menu.</haxe_doc>
		</nextSong>
		<registerSmoothTransition public="1" set="method" line="1736"><f a=""><x path="Void"/></f></registerSmoothTransition>
		<keyShit get="inline" set="null" line="1750"><f a=""><x path="Void"/></f></keyShit>
		<noteMiss public="1" set="method" line="1763">
			<f a="strumLine:note:?direction:?player">
				<c path="funkin.game.StrumLine"/>
				<c path="funkin.game.Note"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Misses a note
	 * @param strumLine The strumline the miss happened on.
	 * @param note Note to miss.
	 * @param direction Specify a custom direction in case note is null.
	 * @param player Specify a custom player in case note is null.</haxe_doc>
		</noteMiss>
		<getNoteType public="1" set="method" line="1809">
			<f a="id">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</getNoteType>
		<goodNoteHit public="1" set="method" line="1818">
			<f a="strumLine:note">
				<c path="funkin.game.StrumLine"/>
				<c path="funkin.game.Note"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Hits a note
	 * @param note Note to hit.</haxe_doc>
		</goodNoteHit>
		<displayRating public="1" set="method" line="1907">
			<f a="myRating:?evt" v=":null">
				<c path="String"/>
				<c path="funkin.backend.scripting.events.note.NoteHitEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ evt : null }</e></m></meta>
			<haxe_doc>* CALCULATES RATING</haxe_doc>
		</displayRating>
		<displayCombo public="1" set="method" line="1932">
			<f a="?evt" v="null">
				<c path="funkin.backend.scripting.events.note.NoteHitEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ evt : null }</e></m></meta>
		</displayCombo>
		<deleteNote public="1" get="inline" set="null" line="1987"><f a="note">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></deleteNote>
		<stepHit public="1" set="method" line="1992" override="1">
			<f a="curStep">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</stepHit>
		<measureHit public="1" set="method" line="1999" override="1">
			<f a="curMeasure">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</measureHit>
		<beatHit public="1" set="method" line="2006" override="1">
			<f a="curBeat">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</beatHit>
		<addScript public="1" set="method" line="2017"><f a="file">
	<c path="String"/>
	<x path="Void"/>
</f></addScript>
		<get_player get="inline" set="null" line="2026"><f a=""><c path="funkin.game.StrumLine"/></f></get_player>
		<set_player get="inline" set="null" line="2028"><f a="s">
	<c path="funkin.game.StrumLine"/>
	<c path="funkin.game.StrumLine"/>
</f></set_player>
		<get_cpu get="inline" set="null" line="2031"><f a=""><c path="funkin.game.StrumLine"/></f></get_cpu>
		<set_cpu get="inline" set="null" line="2033"><f a="s">
	<c path="funkin.game.StrumLine"/>
	<c path="funkin.game.StrumLine"/>
</f></set_cpu>
		<get_boyfriend set="method" line="2035"><f a=""><c path="funkin.game.Character"/></f></get_boyfriend>
		<set_boyfriend set="method" line="2040"><f a="bf">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_boyfriend>
		<set_bf set="method" line="2045"><f a="bf">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_bf>
		<get_bf set="method" line="2050"><f a=""><c path="funkin.game.Character"/></f></get_bf>
		<get_dad set="method" line="2055"><f a=""><c path="funkin.game.Character"/></f></get_dad>
		<set_dad set="method" line="2060"><f a="dad">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_dad>
		<get_gf set="method" line="2065"><f a=""><c path="funkin.game.Character"/></f></get_gf>
		<set_gf set="method" line="2070"><f a="gf">
	<c path="funkin.game.Character"/>
	<c path="funkin.game.Character"/>
</f></set_gf>
		<get_cpuStrums get="inline" set="null" line="2076"><f a=""><c path="funkin.game.StrumLine"/></f></get_cpuStrums>
		<set_cpuStrums get="inline" set="null" line="2078"><f a="v">
	<c path="funkin.game.StrumLine"/>
	<c path="funkin.game.StrumLine"/>
</f></set_cpuStrums>
		<get_playerStrums get="inline" set="null" line="2080"><f a=""><c path="funkin.game.StrumLine"/></f></get_playerStrums>
		<set_playerStrums get="inline" set="null" line="2082"><f a="v">
	<c path="funkin.game.StrumLine"/>
	<c path="funkin.game.StrumLine"/>
</f></set_playerStrums>
		<get_gfSpeed get="inline" set="null" line="2084"><f a=""><x path="Int"/></f></get_gfSpeed>
		<set_gfSpeed get="inline" set="null" line="2085"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_gfSpeed>
		<new public="1" set="method" line="41"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>flixel.text.FlxText.FlxTextFormatRange</e></m>
			<m n=":access"><e>funkin.game.StrumLine</e></m>
		</meta>
	</class>
	<class path="funkin.game.ComboRating" params="" file="source/funkin/game/PlayState.hx" module="funkin.game.PlayState" final="1">
		<percent public="1"><x path="Float"/></percent>
		<rating public="1"><c path="String"/></rating>
		<color public="1"><x path="flixel.util.FlxColor"/></color>
		<maxMisses public="1"><x path="Float"/></maxMisses>
		<new public="1" set="method" line="2151"><f a="?percent:?rating:?color:?misses">
	<x path="Float"/>
	<c path="String"/>
	<x path="flixel.util.FlxColor"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.game.PlayStateTransitionData" params="" file="source/funkin/game/PlayState.hx" module="funkin.game.PlayState"><a>
	<stage><c path="String"/></stage>
	<camZoom><x path="Float"/></camZoom>
	<camY><x path="Float"/></camY>
	<camX><x path="Float"/></camX>
	<camFollowY><x path="Float"/></camFollowY>
	<camFollowX><x path="Float"/></camFollowX>
</a></typedef>
	<class path="funkin.game.CamPosData" params="" file="source/funkin/game/PlayState.hx" module="funkin.game.PlayState">
		<pos public="1">
			<x path="flixel.math.FlxPoint"/>
			<haxe_doc>* The camera position.</haxe_doc>
		</pos>
		<amount public="1">
			<x path="Int"/>
			<haxe_doc>* The amount of characters that was involved in the calculation.</haxe_doc>
		</amount>
		<put public="1" set="method" line="2186">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Puts the position back into the pool, making it reusable.</haxe_doc>
		</put>
		<new public="1" set="method" line="2178"><f a="pos:amount">
	<x path="flixel.math.FlxPoint"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.Splash" params="" file="source/funkin/game/Splash.hx">
		<extends path="funkin.backend.FunkinSprite"/>
		<copyFrom public="1" set="method" line="18" static="1"><f a="source">
	<c path="funkin.game.Splash"/>
	<c path="funkin.game.Splash"/>
</f></copyFrom>
		<strum public="1">
			<x path="Null"><c path="funkin.game.Strum"/></x>
			<haxe_doc>* The current splash strum
	 * WARNING: It can be null</haxe_doc>
		</strum>
		<strumID public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>* Shortcut to `strum.ID`
	 * WARNING: It can be null</haxe_doc>
		</strumID>
		<new public="1" set="method" line="3"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.SplashGroup" params="" file="source/funkin/game/SplashGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.game.Splash"/></extends>
		<valid public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the splash group has successfully loaded or not.</haxe_doc>
		</valid>
		<xml public="1">
			<x path="haxe.xml.Access"/>
			<haxe_doc>* XML data for the note splashes.</haxe_doc>
		</xml>
		<animationNames public="1" expr="[]">
			<c path="Array"><c path="Array"><c path="String"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Animation names sorted by strum IDs.
	 * Use `getSplashAnim` to get one.</haxe_doc>
		</animationNames>
		<_scale expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</_scale>
		<_alpha expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</_alpha>
		<_antialiasing expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</_antialiasing>
		<createSplash set="method" line="53"><f a="imagePath">
	<c path="String"/>
	<c path="funkin.game.Splash"/>
</f></createSplash>
		<setupAnims set="method" line="63"><f a="xml:splash">
	<x path="haxe.xml.Access"/>
	<c path="funkin.game.Splash"/>
	<x path="Void"/>
</f></setupAnims>
		<pregenerateSplashes set="method" line="94"><f a="splash">
	<c path="funkin.game.Splash"/>
	<x path="Void"/>
</f></pregenerateSplashes>
		<getSplashAnim public="1" set="method" line="107"><f a="id">
	<x path="Int"/>
	<c path="String"/>
</f></getSplashAnim>
		<__splash><c path="funkin.game.Splash"/></__splash>
		<showOnStrum public="1" set="method" line="116"><f a="strum">
	<c path="funkin.game.Strum"/>
	<x path="Null"><c path="funkin.game.Splash"/></x>
</f></showOnStrum>
		<new public="1" set="method" line="26">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new Splash group
	 * @param path Path to the splash data (xml)</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.SplashHandler" params="" file="source/funkin/game/SplashHandler.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.game.Splash"/></extends>
		<grpMap public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.game.SplashGroup"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Map containing all of the splashes group.</haxe_doc>
		</grpMap>
		<getSplashGroup public="1" set="method" line="19">
			<f a="name">
				<c path="String"/>
				<x path="Null"><c path="funkin.game.SplashGroup"/></x>
			</f>
			<haxe_doc>* Returns a group of splashes, and creates it if it doesn't exist.
	 * @param path Path to the splashes XML (`Paths.xml('splashes/splash')`)</haxe_doc>
		</getSplashGroup>
		<destroy public="1" set="method" line="27" override="1"><f a=""><x path="Void"/></f></destroy>
		<_firstDraw expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</_firstDraw>
		<draw public="1" set="method" line="35" override="1"><f a=""><x path="Void"/></f></draw>
		<__grp><c path="funkin.game.SplashGroup"/></__grp>
		<showSplash public="1" set="method" line="43"><f a="name:strum">
	<c path="String"/>
	<c path="funkin.game.Strum"/>
	<x path="Void"/>
</f></showSplash>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.Stage" params="" file="source/funkin/game/Stage.hx">
		<extends path="flixel.FlxBasic"/>
		<implements path="funkin.backend.system.interfaces.IBeatReceiver"/>
		<DEFAULT_ATTRIBUTES public="1" expr="[&quot;name&quot;, &quot;startCamPosX&quot;, &quot;startCamPosY&quot;, &quot;zoom&quot;, &quot;folder&quot;]" line="73" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["name", "startCamPosX", "startCamPosY", "zoom", "folder"]</e></m></meta>
		</DEFAULT_ATTRIBUTES>
		<getDefaultPos public="1" set="method" line="225" static="1"><f a="name">
	<c path="String"/>
	<t path="funkin.game.StageCharPosInfo"/>
</f></getDefaultPos>
		<getList public="1" set="method" line="367" static="1">
			<f a="?mods:?xmlOnly" v="false:false">
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ xmlOnly : false, mods : false }</e></m></meta>
			<haxe_doc>* Gets a list of stages that are available to be used.
	 * @param mods Whenever only the mods folder should be checked</haxe_doc>
		</getList>
		<extra public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extra>
		<stageXML public="1"><x path="haxe.xml.Access"/></stageXML>
		<stagePath public="1"><c path="String"/></stagePath>
		<stageFile public="1"><c path="String"/></stageFile>
		<stageName public="1"><c path="String"/></stageName>
		<stageSprites public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</stageSprites>
		<stageScript public="1"><c path="funkin.backend.scripting.Script"/></stageScript>
		<state public="1"><c path="flixel.FlxState"/></state>
		<characterPoses public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.game.StageCharPos"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</characterPoses>
		<xmlImportedScripts public="1" expr="[]">
			<c path="Array"><c path="funkin.backend.utils.XMLImportedScriptInfo"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</xmlImportedScripts>
		<defaultZoom public="1" expr="1.05">
			<x path="Float"/>
			<meta><m n=":value"><e>1.05</e></m></meta>
		</defaultZoom>
		<startCam public="1" expr="new FlxPoint()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</startCam>
		<onXMLLoaded public="1" expr="null">
			<f a=":">
				<x path="haxe.xml.Access"/>
				<c path="Array"><x path="haxe.xml.Access"/></c>
				<c path="Array"><x path="haxe.xml.Access"/></c>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onXMLLoaded>
		<onNodeLoaded public="1" expr="null">
			<f a=":">
				<x path="haxe.xml.Access"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onNodeLoaded>
		<onNodeFinished public="1" expr="null">
			<f a=":">
				<x path="haxe.xml.Access"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onNodeFinished>
		<onAddSprite public="1" expr="null">
			<f a="">
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onAddSprite>
		<onXMLPostLoaded public="1" expr="null">
			<f a=":">
				<x path="haxe.xml.Access"/>
				<c path="Array"><x path="haxe.xml.Access"/></c>
				<c path="Array"><x path="haxe.xml.Access"/></c>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</onXMLPostLoaded>
		<spritesParentFolder public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</spritesParentFolder>
		<getSprite public="1" get="inline" set="null" line="47"><f a="name">
	<c path="String"/>
	<x path="Null"><c path="flixel.FlxSprite"/></x>
</f></getSprite>
		<setStagesSprites public="1" set="method" line="53">
			<f a="script">
				<c path="funkin.backend.scripting.Script"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the sprites in the script, so you can access them by the name.</haxe_doc>
		</setStagesSprites>
		<prepareInfos public="1" set="method" line="56"><f a="node">
	<x path="haxe.xml.Access"/>
	<x path="Null"><x path="Null"><c path="funkin.backend.utils.XMLImportedScriptInfo"/></x></x>
</f></prepareInfos>
		<loadXml public="1" set="method" line="75">
			<f a="xml:?forceLoadAll" v=":false">
				<x path="haxe.xml.Access"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceLoadAll : false }</e></m></meta>
		</loadXml>
		<__pushNcheckNode set="method" line="254">
			<f a="array:node">
				<c path="Array"><x path="haxe.xml.Access"/></c>
				<x path="haxe.xml.Access"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</__pushNcheckNode>
		<addCharPos public="1" set="method" line="266">
			<f a="name:node:?nonXMLInfo">
				<c path="String"/>
				<x path="haxe.xml.Access"/>
				<x path="Null"><t path="funkin.game.StageCharPosInfo"/></x>
				<c path="funkin.game.StageCharPos"/>
			</f>
			<haxe_doc>* Adds a character position to the stage.
	 * @param name The name of the character
	 * @param node The XML node
	 * @param nonXMLInfo (Optional) Non-XML information</haxe_doc>
		</addCharPos>
		<addSprite params="T" set="method" line="321"><f a="sprite">
	<c path="addSprite.T"/>
	<c path="addSprite.T"/>
</f></addSprite>
		<isCharFlipped public="1" get="inline" set="null" line="333">
			<f a="posName:?def" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ def : false }</e></m></meta>
			<haxe_doc>* Checks if a character is flipped or not.
	 * @param posName The name of the character position
	 * @param def The default value</haxe_doc>
		</isCharFlipped>
		<applyCharStuff public="1" set="method" line="342">
			<f a="char:posName:?id" v="::0">
				<c path="funkin.game.Character"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
			<haxe_doc>* Applies the character stuff to the character.
	 * Adds the character to the stage, or inserts it into the stage.
	 * @param char The character
	 * @param posName The name of the character position
	 * @param id The ID of the character</haxe_doc>
		</applyCharStuff>
		<beatHit public="1" set="method" line="352"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="354"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<measureHit public="1" set="method" line="356"><f a="curMeasure">
	<x path="Int"/>
	<x path="Void"/>
</f></measureHit>
		<destroy public="1" set="method" line="358" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="58">
			<f a="stage:?state:?autoLoad" v="::true">
				<c path="String"/>
				<c path="flixel.FlxState"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ autoLoad : true }</e></m></meta>
		</new>
		<haxe_doc>* A class that handles loading a stage and putting the sprites into the state.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.StageCharPos" params="" file="source/funkin/game/Stage.hx" module="funkin.game.Stage">
		<extends path="flixel.FlxObject"/>
		<extra public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extra>
		<name public="1"><c path="String"/></name>
		<charSpacingX public="1" expr="20">
			<x path="Float"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</charSpacingX>
		<charSpacingY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</charSpacingY>
		<camxoffset public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</camxoffset>
		<camyoffset public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</camyoffset>
		<skewX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewX>
		<skewY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</skewY>
		<alpha public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</alpha>
		<flipX public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</flipX>
		<scale public="1" expr="FlxPoint.get(1, 1)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(1, 1)</e></m></meta>
		</scale>
		<zoomFactor public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</zoomFactor>
		<destroy public="1" set="method" line="405" override="1"><f a=""><x path="Void"/></f></destroy>
		<_id expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</_id>
		<oldInfo expr="null">
			<t path="funkin.game.OldCharInfo"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</oldInfo>
		<prepareCharacter public="1" set="method" line="414">
			<f a="char:?id" v=":0">
				<c path="funkin.game.Character"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
		</prepareCharacter>
		<getOldInfo public="1" set="method" line="429"><f a="char">
	<c path="funkin.game.Character"/>
	<a>
		<zoomFactor><x path="Float"/></zoomFactor>
		<y><x path="Float"/></y>
		<x><x path="Float"/></x>
		<skewY><x path="Float"/></skewY>
		<skewX><x path="Float"/></skewX>
		<scrollY><x path="Float"/></scrollY>
		<scrollX><x path="Float"/></scrollX>
		<scaleY><x path="Float"/></scaleY>
		<scaleX><x path="Float"/></scaleX>
		<camyoffset><x path="Float"/></camyoffset>
		<camxoffset><x path="Float"/></camxoffset>
		<angle><x path="Float"/></angle>
		<alpha><x path="Float"/></alpha>
	</a>
</f></getOldInfo>
		<revertCharacter public="1" set="method" line="441"><f a="char">
	<c path="funkin.game.Character"/>
	<x path="Void"/>
</f></revertCharacter>
		<new public="1" set="method" line="399"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.game.StageCharPosInfo" params="" file="source/funkin/game/Stage.hx" module="funkin.game.Stage"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<scroll><x path="Float"/></scroll>
	<flip><x path="Bool"/></flip>
</a></typedef>
	<typedef path="funkin.game.OldCharInfo" params="" file="source/funkin/game/Stage.hx" module="funkin.game.Stage"><a>
	<zoomFactor><x path="Float"/></zoomFactor>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<skewY><x path="Float"/></skewY>
	<skewX><x path="Float"/></skewX>
	<scrollY><x path="Float"/></scrollY>
	<scrollX><x path="Float"/></scrollX>
	<scaleY><x path="Float"/></scaleY>
	<scaleX><x path="Float"/></scaleX>
	<camyoffset><x path="Float"/></camyoffset>
	<camxoffset><x path="Float"/></camxoffset>
	<angle><x path="Float"/></angle>
	<alpha><x path="Float"/></alpha>
</a></typedef>
	<class path="funkin.game.Strum" params="" file="source/funkin/game/Strum.hx">
		<extends path="flixel.FlxSprite"/>
		<PIX180 final="1" public="1" get="inline" set="null" expr="565.4866776461628" line="135" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>565.4866776461628</e></m>
				<m n=":noCompletion"/>
			</meta>
		</PIX180>
		<N_WIDTHDIV2 final="1" public="1" set="null" expr="Note.swagWidth / 2" line="136" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>Note.swagWidth / 2</e></m>
				<m n=":noCompletion"/>
			</meta>
		</N_WIDTHDIV2>
		<extra public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Extra data that can be added to the strum.</haxe_doc>
		</extra>
		<animSuffix public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
			<haxe_doc>* Which animation suffix on characters that should be used when hitting notes.</haxe_doc>
		</animSuffix>
		<cpu public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
			<haxe_doc>* Whenever the strum should act as a CPU strum.
	 * WARNING: Unused.</haxe_doc>
		</cpu>
		<lastHit public="1" expr="-5000">
			<x path="Float"/>
			<meta><m n=":value"><e>-5000</e></m></meta>
			<haxe_doc>* The last time the note/confirm animation was hit.</haxe_doc>
		</lastHit>
		<strumLine public="1" expr="null">
			<c path="funkin.game.StrumLine"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The strum line that this strum belongs to.</haxe_doc>
		</strumLine>
		<scrollSpeed public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The scroll speed of the notes.</haxe_doc>
		</scrollSpeed>
		<noteAngle public="1" expr="null">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The direction of the notes.
	 * If you don't want angle of the strum to interfere with the direction the notes are going,
	 * you can set noteAngle to = 0, and then you can use the angle of the strum without it affecting the direction of the notes.</haxe_doc>
		</noteAngle>
		<lastDrawCameras public="1" set="null" expr="[]">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</lastDrawCameras>
		<copyStrumCamera public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</copyStrumCamera>
		<copyStrumScrollX public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</copyStrumScrollX>
		<copyStrumScrollY public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</copyStrumScrollY>
		<copyStrumAngle public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</copyStrumAngle>
		<updateNotesPosX public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</updateNotesPosX>
		<updateNotesPosY public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</updateNotesPosY>
		<extraCopyFields public="1" set="accessor" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</extraCopyFields>
		<set_extraCopyFields get="inline" set="null" line="55"><f a="val">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></set_extraCopyFields>
		<getPressed public="1" expr="null">
			<f a="">
				<c path="funkin.game.StrumLine"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Whenever the strum is pressed.</haxe_doc>
		</getPressed>
		<getJustPressed public="1" expr="null">
			<f a="">
				<c path="funkin.game.StrumLine"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Whenever the strum was just pressed.</haxe_doc>
		</getJustPressed>
		<getJustReleased public="1" expr="null">
			<f a="">
				<c path="funkin.game.StrumLine"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Whenever the strum was just released.</haxe_doc>
		</getJustReleased>
		<__getPressed public="1" get="inline" set="null" line="70">
			<f a="strumLine">
				<c path="funkin.game.StrumLine"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</__getPressed>
		<__getJustPressed public="1" get="inline" set="null" line="79">
			<f a="strumLine">
				<c path="funkin.game.StrumLine"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</__getJustPressed>
		<__getJustReleased public="1" get="inline" set="null" line="88">
			<f a="strumLine">
				<c path="funkin.game.StrumLine"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</__getJustReleased>
		<getScrollSpeed public="1" get="inline" set="null" line="102">
			<f a="?note">
				<c path="funkin.game.Note"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Gets the scroll speed of the notes.
	 * @param note (Optional) The note</haxe_doc>
		</getScrollSpeed>
		<getNotesAngle public="1" get="inline" set="null" line="115">
			<f a="?note">
				<c path="funkin.game.Note"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Gets the angle of the notes.
	 * If you don't want angle of the strum to interfere with the direction the notes are going,
	 * you can set noteAngle to = 0, and then you can use the angle of the strum without it affecting the direction of the notes.
	 * @param note (Optional) The note</haxe_doc>
		</getNotesAngle>
		<update public="1" set="method" line="121" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="130" override="1"><f a=""><x path="Void"/></f></draw>
		<updateNotePosition public="1" set="method" line="142">
			<f a="daNote">
				<c path="funkin.game.Note"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates the position of a note.
	 * @param daNote The note</haxe_doc>
		</updateNotePosition>
		<updateNotePos get="inline" set="null" line="159"><f a="daNote">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></updateNotePos>
		<updateSustain public="1" get="inline" set="null" line="207">
			<f a="daNote">
				<c path="funkin.game.Note"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates a sustain note.
	 * @param daNote The note</haxe_doc>
		</updateSustain>
		<updatePlayerInput public="1" set="method" line="218">
			<f a="pressed:justPressed:justReleased">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates the animation state based on the player input.
	 * @param pressed Whenever the player is pressing the button
	 * @param justPressed Whenever the player just pressed the button
	 * @param justReleased Whenever the player just released the button</haxe_doc>
		</updatePlayerInput>
		<press public="1" get="inline" set="null" line="238">
			<f a="time">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Plays the confirm animation.
	 * @param time The time</haxe_doc>
		</press>
		<playAnim public="1" set="method" line="248">
			<f a="anim:?force" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : true }</e></m></meta>
			<haxe_doc>* Plays an animation.
	 * @param anim The animation name
	 * @param force Whenever the animation should be forced to play</haxe_doc>
		</playAnim>
		<getAnim public="1" get="inline" set="null" line="257">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Gets the current animation name.</haxe_doc>
		</getAnim>
		<new public="1" set="method" line="6"><f a="?X:?Y:?SimpleGraphic">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Null"><t path="flixel.system.FlxGraphicAsset"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.StrumLine" params="" file="source/funkin/game/StrumLine.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="funkin.game.Strum"/></extends>
		<calculateStartingXPos public="1" get="inline" set="null" line="420" static="1"><f a="hudXRatio:scale:spacing:keyCount">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></calculateStartingXPos>
		<onHit public="1" expr="new FlxTypedSignal&lt;NoteHitEvent&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.backend.scripting.events.note.NoteHitEvent"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;NoteHitEvent&gt;()</e></m></meta>
			<haxe_doc>* Signal that triggers whenever a note is hit. Similar to onPlayerHit and onDadHit, except strumline specific.
	 * To add a listener, do
	 * `strumLine.onHit.add(function(e:NoteHitEvent) {});`</haxe_doc>
		</onHit>
		<onMiss public="1" expr="new FlxTypedSignal&lt;NoteMissEvent&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.backend.scripting.events.note.NoteMissEvent"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;NoteMissEvent&gt;()</e></m></meta>
			<haxe_doc>* Signal that triggers whenever a note is missed. Similar to onPlayerMiss, except strumline specific.
	 * To add a listener, do
	 * `strumLine.onMiss.add(function(e:NoteMissEvent) {});`</haxe_doc>
		</onMiss>
		<onNoteUpdate public="1" expr="new FlxTypedSignal&lt;NoteUpdateEvent&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.backend.scripting.events.note.NoteUpdateEvent"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;NoteUpdateEvent&gt;()</e></m></meta>
			<haxe_doc>* Signal that triggers whenever a note is being updated. Similar to onNoteUpdate, except strumline specific.
	 * To add a listener, do
	 * `strumLine.onNoteUpdate.add(function(e:NoteUpdateEvent) {});`</haxe_doc>
		</onNoteUpdate>
		<onNoteDelete public="1" expr="new FlxTypedSignal&lt;SimpleNoteEvent&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.backend.scripting.events.note.SimpleNoteEvent"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;SimpleNoteEvent&gt;()</e></m></meta>
			<haxe_doc>* Signal that triggers whenever a note is being deleted. Similar to onNoteDelete, except strumline specific.
	 * To add a listener, do
	 * `strumLine.onNoteDelete.add(function(e:SimpleNoteEvent) {});`</haxe_doc>
		</onNoteDelete>
		<characters public="1">
			<c path="Array"><c path="funkin.game.Character"/></c>
			<haxe_doc>* Array containing all of the characters "attached" to those strums.</haxe_doc>
		</characters>
		<cpu public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever this strumline is controlled by cpu or not.</haxe_doc>
		</cpu>
		<opponentSide public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever this strumline is from the opponent side or the player side.</haxe_doc>
		</opponentSide>
		<controls public="1" expr="null">
			<c path="funkin.backend.system.Controls"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Controls assigned to this strumline.</haxe_doc>
		</controls>
		<data public="1" expr="null">
			<t path="funkin.backend.chart.ChartStrumLine"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Chart JSON data assigned to this StrumLine (Codename format)</haxe_doc>
		</data>
		<ghostTapping public="1" get="accessor" set="accessor" expr="null">
			<x path="Null"><x path="Bool"/></x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":isVar"/>
			</meta>
			<haxe_doc>* Whenever Ghost Tapping is enabled.</haxe_doc>
		</ghostTapping>
		<notes public="1">
			<c path="funkin.game.NoteGroup"/>
			<haxe_doc>* Group of all of the notes in this strumline. Using `forEach` on this group will only loop through the first notes for performance reasons.</haxe_doc>
		</notes>
		<altAnim public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whenever alt animation is enabled on this strumline.</haxe_doc>
		</altAnim>
		<animSuffix public="1" set="accessor" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
			<haxe_doc>* Which animation suffix on characters that should be used when hitting notes.</haxe_doc>
		</animSuffix>
		<strumAnimPrefix public="1" expr="[&quot;left&quot;, &quot;down&quot;, &quot;up&quot;, &quot;right&quot;]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["left", "down", "up", "right"]</e></m></meta>
			<haxe_doc>* TODO: Write documentation about this being a variable that can help when making multi key</haxe_doc>
		</strumAnimPrefix>
		<vocals public="1">
			<c path="flixel.sound.FlxSound"/>
			<haxe_doc>* Vocals sound (Vocals.ogg). Used for individual vocals per strumline.</haxe_doc>
		</vocals>
		<extra public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<d/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Extra data that can be added to the strum line.</haxe_doc>
		</extra>
		<get_ghostTapping set="method" line="90"><f a=""><x path="Null"><x path="Bool"/></x></f></get_ghostTapping>
		<set_ghostTapping get="inline" set="null" line="97"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ghostTapping>
		<startingPos expr="FlxPoint.get(0, 0)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(0, 0)</e></m></meta>
		</startingPos>
		<strumScale public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The scale of the strums.
	 * If called after generate, the strums wont be scaled.
	 * You can only change it in the Charter.</haxe_doc>
		</strumScale>
		<generate public="1" set="method" line="126">
			<f a="strumLine:?startTime">
				<t path="funkin.backend.chart.ChartStrumLine"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Generates the notes for the strumline.</haxe_doc>
		</generate>
		<update public="1" set="method" line="180" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="185" override="1"><f a=""><x path="Void"/></f></draw>
		<updateNotes public="1" get="inline" set="null" line="194">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the notes.</haxe_doc>
		</updateNotes>
		<__updateNote_strum><c path="funkin.game.Strum"/></__updateNote_strum>
		<__updateNote_songPos><x path="Float"/></__updateNote_songPos>
		<__updateNote_event><c path="funkin.backend.scripting.events.note.NoteUpdateEvent"/></__updateNote_event>
		<updateNote public="1" set="method" line="207">
			<f a="daNote">
				<c path="funkin.game.Note"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates a note.
	 * This updates the position, state, and handles the input.</haxe_doc>
		</updateNote>
		<__funcsToExec expr="[]">
			<c path="Array"><f a="">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__funcsToExec>
		<__pressed expr="[]">
			<c path="Array"><x path="Bool"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__pressed>
		<__justPressed expr="[]">
			<c path="Array"><x path="Bool"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__justPressed>
		<__justReleased expr="[]">
			<c path="Array"><x path="Bool"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__justReleased>
		<__notePerStrum expr="[]">
			<c path="Array"><c path="funkin.game.Note"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__notePerStrum>
		<__inputProcessPressed set="method" line="251"><f a="note">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></__inputProcessPressed>
		<__inputProcessJustPressed set="method" line="257"><f a="note">
	<c path="funkin.game.Note"/>
	<x path="Void"/>
</f></__inputProcessJustPressed>
		<updateInput public="1" set="method" line="269">
			<f a="?id" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
			<haxe_doc>* Updates the input for the strumline, and handles the input.
	 * @param id The ID of the strum</haxe_doc>
		</updateInput>
		<addHealth public="1" get="inline" set="null" line="330">
			<f a="health">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds/removes health to/from the strumline.
	 * If the strumline is an opponent strumline, it will subtract the health, otherwise it will add the health.
	 * @param health The amount of health to add/remove</haxe_doc>
		</addHealth>
		<generateStrums public="1" get="inline" set="null" line="336">
			<f a="?amount" v="-1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ amount : -1 }</e></m></meta>
			<haxe_doc>* Generates strums, and adds them to the strumline.
	 * @param amount The amount of strums to generate (-1 for the default amount)</haxe_doc>
		</generateStrums>
		<destroy public="1" set="method" line="342" override="1"><f a=""><x path="Void"/></f></destroy>
		<createStrum public="1" set="method" line="356">
			<f a="i:?animPrefix:?spritePath:?playIntroAnimation">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="funkin.game.Strum"/>
			</f>
			<haxe_doc>* Creates a strum and returns the created strum (needs to be added manually).
	 * @param i Index of the strum
	 * @param animPrefix (Optional) Animation prefix (`left` = `arrowLEFT`, `left press`, `left confirm`).
	 * @param spritePath (Optional) The sprite's graphic path if you don't want the default one.
	 * @param playIntroAnimation (Optional) Whenever the intro animation should be played, by default might be `true` under certain conditions.</haxe_doc>
		</createStrum>
		<deleteNote public="1" set="method" line="409">
			<f a="note">
				<c path="funkin.game.Note"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Deletes a note from this strumline.
	 * @param note Note to delete</haxe_doc>
		</deleteNote>
		<set_cpu get="inline" set="null" line="428">
			<f a="b">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* SETTERS &amp; GETTERS</haxe_doc>
		</set_cpu>
		<set_animSuffix get="inline" set="null" line="434"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></set_animSuffix>
		<set_altAnim get="inline" set="null" line="440"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_altAnim>
		<get_altAnim get="inline" set="null" line="444"><f a=""><x path="Bool"/></f></get_altAnim>
		<new public="1" set="method" line="108">
			<f a="characters:startingPos:strumScale:?cpu:?opponentSide:?controls:?vocalPrefix" v=":::false:true::&quot;&quot;">
				<c path="Array"><c path="funkin.game.Character"/></c>
				<x path="flixel.math.FlxPoint"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="funkin.backend.system.Controls"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ vocalPrefix : "", opponentSide : true, cpu : false }</e></m></meta>
		</new>
		<haxe_doc>* Group of strums, that contains the strums and notes.
 * Used in PlayState.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.cutscenes.Cutscene" params="" file="source/funkin/game/cutscenes/Cutscene.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<__callback><f a=""><x path="Void"/></f></__callback>
		<game expr="PlayState.instance">
			<c path="funkin.game.PlayState"/>
			<meta><m n=":value"><e>PlayState.instance</e></m></meta>
		</game>
		<paused public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</paused>
		<pauseItems public="1"><c path="Array"><c path="String"/></c></pauseItems>
		<pausable public="1"><x path="Bool"/></pausable>
		<skippable public="1" set="accessor"><x path="Bool"/></skippable>
		<set_skippable public="1" set="method" line="18"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_skippable>
		<update public="1" set="method" line="35" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<pauseCheck public="1" set="method" line="41"><f a=""><x path="Bool"/></f></pauseCheck>
		<_before expr="[false, true]">
			<c path="Array"><x path="Bool"/></c>
			<meta><m n=":value"><e>[false, true]</e></m></meta>
		</_before>
		<pauseCutscene public="1" set="method" line="44"><f a=""><x path="Void"/></f></pauseCutscene>
		<closeSubState public="1" set="method" line="53" override="1"><f a=""><x path="Void"/></f></closeSubState>
		<onSkipCutscene public="1" set="method" line="63"><f a="event">
	<c path="funkin.backend.scripting.events.NameEvent"/>
	<x path="Void"/>
</f></onSkipCutscene>
		<onRestartCutscene public="1" set="method" line="64"><f a="event">
	<c path="funkin.backend.scripting.events.NameEvent"/>
	<x path="Void"/>
</f></onRestartCutscene>
		<onResumeCutscene public="1" set="method" line="65"><f a="event">
	<c path="funkin.backend.scripting.events.NameEvent"/>
	<x path="Void"/>
</f></onResumeCutscene>
		<selectPauseOption public="1" set="method" line="67"><f a="event">
	<c path="funkin.backend.scripting.events.NameEvent"/>
	<x path="Bool"/>
</f></selectPauseOption>
		<close public="1" set="method" line="77" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="24">
			<f a="callback:?allowPause:?canSkip" v=":true:true">
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ canSkip : true, allowPause : true }</e></m></meta>
		</new>
		<haxe_doc>* Substate made for cutscenes.</haxe_doc>
	</class>
	<class path="funkin.game.cutscenes.ScriptedCutscene" params="" file="source/funkin/game/cutscenes/ScriptedCutscene.hx">
		<extends path="funkin.game.cutscenes.Cutscene"/>
		<scriptPath><c path="String"/></scriptPath>
		<script><c path="funkin.backend.scripting.Script"/></script>
		<create public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></create>
		<onErrorScriptLoading public="1" set="method" line="36"><f a=""><x path="Void"/></f></onErrorScriptLoading>
		<pauseCheck public="1" set="method" line="42" override="1"><f a=""><x path="Bool"/></f></pauseCheck>
		<update public="1" set="method" line="49" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<pauseCutscene public="1" set="method" line="56" override="1"><f a=""><x path="Void"/></f></pauseCutscene>
		<onSkipCutscene public="1" set="method" line="63" override="1"><f a="event">
	<c path="funkin.backend.scripting.events.NameEvent"/>
	<x path="Void"/>
</f></onSkipCutscene>
		<onRestartCutscene public="1" set="method" line="69" override="1"><f a="event">
	<c path="funkin.backend.scripting.events.NameEvent"/>
	<x path="Void"/>
</f></onRestartCutscene>
		<onResumeCutscene public="1" set="method" line="75" override="1"><f a="event">
	<c path="funkin.backend.scripting.events.NameEvent"/>
	<x path="Void"/>
</f></onResumeCutscene>
		<measureHit public="1" set="method" line="81" override="1"><f a="curMeasure">
	<x path="Int"/>
	<x path="Void"/>
</f></measureHit>
		<beatHit public="1" set="method" line="87" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<stepHit public="1" set="method" line="93" override="1"><f a="curStep">
	<x path="Int"/>
	<x path="Void"/>
</f></stepHit>
		<openSubState public="1" set="method" line="99" override="1"><f a="sub">
	<c path="flixel.FlxSubState"/>
	<x path="Void"/>
</f></openSubState>
		<closeSubState public="1" set="method" line="106" override="1"><f a=""><x path="Void"/></f></closeSubState>
		<destroy public="1" set="method" line="112" override="1"><f a=""><x path="Void"/></f></destroy>
		<startVideo public="1" set="method" line="120"><f a="path:?callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></startVideo>
		<isVideoPlaying public="1" get="accessor" set="null"><x path="Bool"/></isVideoPlaying>
		<get_isVideoPlaying get="inline" set="null" line="131"><f a=""><x path="Bool"/></f></get_isVideoPlaying>
		<startDialogue public="1" set="method" line="136"><f a="path:?callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></startDialogue>
		<isDialoguePlaying public="1" get="accessor" set="null"><x path="Bool"/></isDialoguePlaying>
		<get_isDialoguePlaying get="inline" set="null" line="147"><f a=""><x path="Bool"/></f></get_isDialoguePlaying>
		<new public="1" set="method" line="19"><f a="scriptPath:callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Substate made for scripted cutscenes.
 * To add cutscenes to your songs, add a `cutscene.hx` file in your song's directory (ex: `songs/song/cutscene.hx`)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.game.cutscenes.DialogueCutscene" params="" file="source/funkin/game/cutscenes/DialogueCutscene.hx">
		<extends path="funkin.game.cutscenes.ScriptedCutscene"/>
		<cutscene public="1" static="1"><c path="funkin.game.cutscenes.DialogueCutscene"/></cutscene>
		<dialoguePath public="1"><c path="String"/></dialoguePath>
		<dialogueData public="1"><x path="haxe.xml.Access"/></dialogueData>
		<charMap public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.game.cutscenes.dialogue.DialogueCharacter"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</charMap>
		<dialogueLines public="1" expr="[]">
			<c path="Array"><t path="funkin.game.cutscenes.DialogueLine"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</dialogueLines>
		<curLine public="1" set="accessor" expr="null">
			<t path="funkin.game.cutscenes.DialogueLine"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curLine>
		<lastLine public="1" expr="null">
			<t path="funkin.game.cutscenes.DialogueLine"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastLine>
		<dialogueBox public="1"><c path="funkin.game.cutscenes.dialogue.DialogueBox"/></dialogueBox>
		<dialogueCamera public="1"><c path="flixel.FlxCamera"/></dialogueCamera>
		<curMusic public="1" expr="null">
			<c path="flixel.sound.FlxSound"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</curMusic>
		<dialogueScript public="1" get="accessor" set="accessor"><c path="funkin.backend.scripting.Script"/></dialogueScript>
		<set_curLine public="1" get="inline" set="null" line="33"><f a="val">
	<t path="funkin.game.cutscenes.DialogueLine"/>
	<t path="funkin.game.cutscenes.DialogueLine"/>
</f></set_curLine>
		<set_dialogueScript public="1" get="inline" set="null" line="39"><f a="val">
	<c path="funkin.backend.scripting.Script"/>
	<c path="funkin.backend.scripting.Script"/>
</f></set_dialogueScript>
		<get_dialogueScript public="1" get="inline" set="null" line="40"><f a=""><c path="funkin.backend.scripting.Script"/></f></get_dialogueScript>
		<onErrorScriptLoading public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></onErrorScriptLoading>
		<parentDisabler><c path="funkin.backend.utils.FunkinParentDisabler"/></parentDisabler>
		<create public="1" set="method" line="57" override="1"><f a=""><x path="Void"/></f></create>
		<pauseCheck public="1" set="method" line="130" override="1"><f a=""><x path="Bool"/></f></pauseCheck>
		<update public="1" set="method" line="134" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<canProceed public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Use this to cancel `next`!</haxe_doc>
		</canProceed>
		<next public="1" set="method" line="147">
			<f a="?playFirst" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ playFirst : false }</e></m></meta>
		</next>
		<close public="1" set="method" line="191" override="1"><f a=""><x path="Void"/></f></close>
		<destroy public="1" set="method" line="201" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="42"><f a="dialoguePath:callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Substate made for dialogue cutscenes. To use it in a scripted cutscene, call `startDialogue`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.game.cutscenes.DialogueLine" params="" file="source/funkin/game/cutscenes/DialogueCutscene.hx" module="funkin.game.cutscenes.DialogueCutscene"><a>
	<textSound><c path="flixel.sound.FlxSound"/></textSound>
	<text><c path="String"/></text>
	<speed><x path="Float"/></speed>
	<playSound><c path="flixel.sound.FlxSound"/></playSound>
	<nextSound><c path="flixel.sound.FlxSound"/></nextSound>
	<musicVolume><x path="Null"><x path="Float"/></x></musicVolume>
	<format><c path="Array"><t path="funkin.backend.utils.TextFormat"/></c></format>
	<char><c path="String"/></char>
	<changeMusic><c path="flixel.sound.FlxSound"/></changeMusic>
	<changeDefAnim><c path="String"/></changeDefAnim>
	<callback><c path="String"/></callback>
	<bubble><c path="String"/></bubble>
</a></typedef>
	<class path="funkin.game.cutscenes.VideoCutscene" params="" file="source/funkin/game/cutscenes/VideoCutscene.hx">
		<extends path="funkin.game.cutscenes.Cutscene"/>
		<curVideo expr="0" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curVideo>
		<splitTime public="1" set="method" line="168" static="1"><f a="str">
	<c path="String"/>
	<x path="Float"/>
</f></splitTime>
		<path><c path="String"/></path>
		<localPath><c path="String"/></localPath>
		<video><c path="hxvlc.flixel.FlxVideoSprite"/></video>
		<mutex final="1" expr="new sys.thread.Mutex()">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new sys.thread.Mutex()</e></m></meta>
		</mutex>
		<cutsceneCamera><c path="flixel.FlxCamera"/></cutsceneCamera>
		<text><c path="funkin.backend.FunkinText"/></text>
		<loadingBackdrop><c path="flixel.addons.display.FlxBackdrop"/></loadingBackdrop>
		<__loaded expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__loaded>
		<bg><c path="flixel.FlxSprite"/></bg>
		<subtitle><c path="funkin.backend.FunkinText"/></subtitle>
		<subtitles public="1" expr="[]">
			<c path="Array"><t path="funkin.game.cutscenes.CutsceneSubtitle"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</subtitles>
		<curSubtitle expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSubtitle>
		<create public="1" set="method" line="49" override="1"><f a=""><x path="Void"/></f></create>
		<parseSubtitles public="1" set="method" line="125"><f a=""><x path="Void"/></f></parseSubtitles>
		<onReady public="1" get="inline" set="null" line="182"><f a=""><x path="Void"/></f></onReady>
		<update public="1" set="method" line="193" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onFocus public="1" set="method" line="208" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onFocus>
		<onFocusLost public="1" set="method" line="213" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onFocusLost>
		<pauseCutscene public="1" set="method" line="218" override="1"><f a=""><x path="Void"/></f></pauseCutscene>
		<onResumeCutscene public="1" set="method" line="223" override="1"><f a="event">
	<c path="funkin.backend.scripting.events.NameEvent"/>
	<x path="Void"/>
</f></onResumeCutscene>
		<onRestartCutscene public="1" set="method" line="228" override="1"><f a="event">
	<c path="funkin.backend.scripting.events.NameEvent"/>
	<x path="Void"/>
</f></onRestartCutscene>
		<setSubtitle public="1" set="method" line="235"><f a="sub">
	<t path="funkin.game.cutscenes.CutsceneSubtitle"/>
	<x path="Void"/>
</f></setSubtitle>
		<destroy public="1" set="method" line="245" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="44"><f a="path:callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Substate made for video cutscenes. To use it in a scripted cutscene, call `startVideo`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.game.cutscenes.CutsceneSubtitle" params="" file="source/funkin/game/cutscenes/VideoCutscene.hx" module="funkin.game.cutscenes.VideoCutscene"><a>
	<time><x path="Float"/></time>
	<subtitle><c path="String"/></subtitle>
</a></typedef>
	<class path="funkin.game.cutscenes.dialogue.DialogueBox" params="" file="source/funkin/game/cutscenes/dialogue/DialogueBox.hx">
		<extends path="funkin.backend.FunkinSprite"/>
		<dialogueBoxData public="1"><x path="haxe.xml.Access"/></dialogueBoxData>
		<positions public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<t path="funkin.game.cutscenes.dialogue.CharPosDef"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</positions>
		<dialogueEnded public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dialogueEnded>
		<nextSFX public="1" expr="Paths.sound(&quot;dialogue/next&quot;)">
			<c path="String"/>
			<meta><m n=":value"><e>Paths.sound("dialogue/next")</e></m></meta>
		</nextSFX>
		<defaultTextTypeSFX public="1"><c path="Array"><c path="flixel.sound.FlxSound"/></c></defaultTextTypeSFX>
		<text public="1"><c path="flixel.addons.text.FlxTypeText"/></text>
		<defPath public="1" expr="&quot;dialogue/boxes/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"dialogue/boxes/"</e></m></meta>
		</defPath>
		<dialogueBoxScript public="1"><c path="funkin.backend.scripting.Script"/></dialogueBoxScript>
		<cutscene public="1" expr="DialogueCutscene.cutscene">
			<c path="funkin.game.cutscenes.DialogueCutscene"/>
			<meta><m n=":value"><e>DialogueCutscene.cutscene</e></m></meta>
		</cutscene>
		<playAnim public="1" set="method" line="99" override="1">
			<f a="AnimName:?Force:?Context:?Reversed:?Frame" v="::NONE:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Context : NONE }</e></m></meta>
		</playAnim>
		<beatHit public="1" set="method" line="107" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<update public="1" set="method" line="112" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<popupChar public="1" set="method" line="117">
			<f a="char:?force" v=":false">
				<c path="funkin.game.cutscenes.dialogue.DialogueCharacter"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</popupChar>
		<playBubbleAnim public="1" set="method" line="129">
			<f a="bubble:?suffix:?text:?format:?speed:?customSFX:?customTypeSFX:?setTextAfter:?allowDefault" v=":&quot;&quot;:&quot;&quot;::0.05:::false:true">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
				<x path="Float"/>
				<c path="flixel.sound.FlxSound"/>
				<c path="Array"><c path="flixel.sound.FlxSound"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ allowDefault : true, setTextAfter : false, speed : 0.05, text : "", suffix : "" }</e></m></meta>
		</playBubbleAnim>
		<resetText public="1" set="method" line="156">
			<f a="?text:?formats:?event" v="&quot;&quot;::">
				<c path="String"/>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
				<c path="funkin.backend.scripting.events.dialogue.DialogueBoxSetTextEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ text : "" }</e></m></meta>
		</resetText>
		<startText public="1" set="method" line="169">
			<f a="?text:?format:?speed:?customTypeSFX" v="&quot;&quot;::0.05:">
				<c path="String"/>
				<c path="Array"><t path="funkin.backend.utils.TextFormat"/></c>
				<x path="Float"/>
				<c path="Array"><c path="flixel.sound.FlxSound"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ speed : 0.05, text : "" }</e></m></meta>
		</startText>
		<destroy public="1" set="method" line="182" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="23"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.game.cutscenes.dialogue.CharPosDef" params="" file="source/funkin/game/cutscenes/dialogue/DialogueBox.hx" module="funkin.game.cutscenes.dialogue.DialogueBox"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<flipBubble><x path="Bool"/></flipBubble>
</a></typedef>
	<class path="funkin.game.cutscenes.dialogue.DialogueCharacter" params="" file="source/funkin/game/cutscenes/dialogue/DialogueCharacter.hx">
		<extends path="funkin.backend.FunkinSprite"/>
		<charData public="1"><x path="haxe.xml.Access"/></charData>
		<curTween public="1"><c path="flixel.tweens.FlxTween"/></curTween>
		<curAnimContext public="1" expr="NONE">
			<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</curAnimContext>
		<positionName public="1"><c path="String"/></positionName>
		<finishAnimCallback public="1" expr="null">
			<f a="">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
		</finishAnimCallback>
		<defaultAnim public="1" expr="&quot;normal&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"normal"</e></m></meta>
		</defaultAnim>
		<defPath public="1" expr="&quot;dialogue/characters/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"dialogue/characters/"</e></m></meta>
		</defPath>
		<dialogueCharScript public="1"><c path="funkin.backend.scripting.Script"/></dialogueCharScript>
		<cutscene public="1" expr="DialogueCutscene.cutscene">
			<c path="funkin.game.cutscenes.DialogueCutscene"/>
			<meta><m n=":value"><e>DialogueCutscene.cutscene</e></m></meta>
		</cutscene>
		<playAnim public="1" set="method" line="64" override="1">
			<f a="AnimName:?Force:?Context:?Reversed:?Frame" v="::NONE:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="funkin.backend.scripting.events.sprite.PlayAnimContext"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Context : NONE }</e></m></meta>
		</playAnim>
		<beatHit public="1" set="method" line="72" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<update public="1" set="method" line="77" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<show public="1" set="method" line="82">
			<f a="x:y:?animation:?force" v=":::false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</show>
		<hide public="1" set="method" line="107">
			<f a="?animation:?force" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</hide>
		<destroy public="1" set="method" line="126" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="22"><f a="name:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext" params="" file="source/funkin/game/cutscenes/dialogue/DialogueCharacter.hx" module="funkin.game.cutscenes.dialogue.DialogueCharacter">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.game.cutscenes.dialogue._DialogueCharacter.DialogueCharAnimContext_Impl_" params="" file="source/funkin/game/cutscenes/dialogue/DialogueCharacter.hx" private="1" module="funkin.game.cutscenes.dialogue.DialogueCharacter" extern="1" final="1">
	<NONE public="1" get="inline" set="null" expr="cast -1" line="135" static="1">
		<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<POPIN public="1" get="inline" set="null" expr="cast 0" line="136" static="1">
		<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POPIN>
	<POPOUT public="1" get="inline" set="null" expr="cast 1" line="137" static="1">
		<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POPOUT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.game.cutscenes.dialogue._DialogueCharacter.DialogueCharAnimContext_Impl_" params="" file="source/funkin/game/cutscenes/dialogue/DialogueCharacter.hx" private="1" module="funkin.game.cutscenes.dialogue.DialogueCharacter" extern="1" final="1">
		<NONE public="1" get="inline" set="null" expr="cast -1" line="135" static="1">
			<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<POPIN public="1" get="inline" set="null" expr="cast 0" line="136" static="1">
			<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POPIN>
		<POPOUT public="1" get="inline" set="null" expr="cast 1" line="137" static="1">
			<x path="funkin.game.cutscenes.dialogue.DialogueCharAnimContext"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POPOUT>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.menus.FreeplayState" params="" file="source/funkin/menus/FreeplayState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<songs public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.chart.ChartMetaData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array containing all of the songs' metadata.</haxe_doc>
		</songs>
		<curSelected public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Currently selected song</haxe_doc>
		</curSelected>
		<curDifficulty public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Currently selected difficulty</haxe_doc>
		</curDifficulty>
		<curCoopMode public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Currently selected coop/opponent mode</haxe_doc>
		</curCoopMode>
		<scoreText public="1">
			<c path="flixel.text.FlxText"/>
			<haxe_doc>* Text containing the score info (PERSONAL BEST: 0)</haxe_doc>
		</scoreText>
		<diffText public="1">
			<c path="flixel.text.FlxText"/>
			<haxe_doc>* Text containing the current difficulty (&lt; HARD &gt;)</haxe_doc>
		</diffText>
		<coopText public="1">
			<c path="flixel.text.FlxText"/>
			<haxe_doc>* Text containing the current coop/opponent mode ([TAB] Co-Op mode)</haxe_doc>
		</coopText>
		<lerpScore public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Currently lerped score. Is updated to go towards `intendedScore`.</haxe_doc>
		</lerpScore>
		<intendedScore public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Destination for the currently lerped score.</haxe_doc>
		</intendedScore>
		<songList public="1">
			<c path="funkin.menus.FreeplaySonglist"/>
			<haxe_doc>* Assigned FreeplaySonglist item.</haxe_doc>
		</songList>
		<scoreBG public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Black background around the score, the difficulty text and the co-op text.</haxe_doc>
		</scoreBG>
		<bg public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Background.</haxe_doc>
		</bg>
		<canSelect public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the player can navigate and select</haxe_doc>
		</canSelect>
		<grpSongs public="1">
			<c path="flixel.group.FlxTypedGroup"><c path="funkin.menus.ui.Alphabet"/></c>
			<haxe_doc>* Group containing all of the alphabets</haxe_doc>
		</grpSongs>
		<curPlaying public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the currently selected song is playing.</haxe_doc>
		</curPlaying>
		<iconArray public="1" expr="[]">
			<c path="Array"><c path="funkin.game.HealthIcon"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array containing all of the icons.</haxe_doc>
		</iconArray>
		<interpColor public="1">
			<c path="funkin.backend.utils.FlxInterpolateColor"/>
			<haxe_doc>* FlxInterpolateColor object for smooth transition between Freeplay colors.</haxe_doc>
		</interpColor>
		<create public="1" set="method" line="100" override="1"><f a=""><x path="Void"/></f></create>
		<timeUntilAutoplay public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* How much time a song stays selected until it autoplays.</haxe_doc>
		</timeUntilAutoplay>
		<disableAutoPlay public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the song autoplays when hovered over.</haxe_doc>
		</disableAutoPlay>
		<disableAsyncLoading public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whenever the autoplayed song gets async loaded.</haxe_doc>
		</disableAsyncLoading>
		<autoplayElapsed public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Time elapsed since last autoplay. If this time exceeds `timeUntilAutoplay`, the currently selected song will play.</haxe_doc>
		</autoplayElapsed>
		<songInstPlaying public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whenever the currently selected song instrumental is playing.</haxe_doc>
		</songInstPlaying>
		<curPlayingInst public="1" expr="null">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Path to the currently playing song instrumental.</haxe_doc>
		</curPlayingInst>
		<autoplayShouldPlay public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If it should play the song automatically.</haxe_doc>
		</autoplayShouldPlay>
		<TEXT_FREEPLAY_SCORE expr="TU.getRaw(&quot;freeplay.score&quot;)">
			<c path="funkin.backend.utils.translations.IFormatInfo"/>
			<meta><m n=":value"><e>TU.getRaw("freeplay.score")</e></m></meta>
		</TEXT_FREEPLAY_SCORE>
		<update public="1" set="method" line="212" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<__opponentMode expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__opponentMode>
		<__coopMode expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__coopMode>
		<updateCoopModes set="method" line="302"><f a=""><x path="Void"/></f></updateCoopModes>
		<select public="1" set="method" line="319">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Selects the current song.</haxe_doc>
		</select>
		<convertChart public="1" set="method" line="339"><f a=""><x path="Void"/></f></convertChart>
		<changeDiff public="1" set="method" line="351">
			<f a="?change:?force" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false, change : 0 }</e></m></meta>
			<haxe_doc>* Changes the current difficulty
	 * @param change How much to change.
	 * @param force Force the change if `change` is equal to 0</haxe_doc>
		</changeDiff>
		<updateScore set="method" line="370"><f a=""><x path="Void"/></f></updateScore>
		<coopLabels public="1" expr="[TU.translate(&quot;freeplay.solo&quot;), TU.translate(&quot;freeplay.opponentMode&quot;), TU.translate(&quot;freeplay.coopMode&quot;), TU.translate(&quot;freeplay.coopModeSwitched&quot;)]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[TU.translate("freeplay.solo"), TU.translate("freeplay.opponentMode"), TU.translate("freeplay.coopMode"), TU.translate("freeplay.coopModeSwitched")]</e></m></meta>
			<haxe_doc>* Array containing all labels for Co-Op / Opponent modes.</haxe_doc>
		</coopLabels>
		<changeCoopMode public="1" set="method" line="398">
			<f a="?change:?force" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false, change : 0 }</e></m></meta>
			<haxe_doc>* Change the current coop mode context.
	 * @param change How much to change
	 * @param force Force the change, even if `change` is equal to 0.</haxe_doc>
		</changeCoopMode>
		<changeSelection public="1" set="method" line="426">
			<f a="?change:?force" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false, change : 0 }</e></m></meta>
			<haxe_doc>* Change the current selection.
	 * @param change How much to change
	 * @param force Force the change, even if `change` is equal to 0.</haxe_doc>
		</changeSelection>
		<updateOptionsAlpha set="method" line="446"><f a=""><x path="Void"/></f></updateOptionsAlpha>
		<new public="1" set="method" line="15"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.FreeplaySonglist" params="" file="source/funkin/menus/FreeplayState.hx" module="funkin.menus.FreeplayState">
		<get public="1" set="method" line="494" static="1">
			<f a="?useTxt" v="true">
				<x path="Bool"/>
				<c path="funkin.menus.FreeplaySonglist"/>
			</f>
			<meta><m n=":value"><e>{ useTxt : true }</e></m></meta>
		</get>
		<songs public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.chart.ChartMetaData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</songs>
		<getSongsFromSource public="1" set="method" line="475">
			<f a="source:?useTxt" v=":true">
				<x path="funkin.backend.assets.AssetSource"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ useTxt : true }</e></m></meta>
		</getSongsFromSource>
		<new public="1" set="method" line="473"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.GitarooPause" params="" file="source/funkin/menus/GitarooPause.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<replayButton><c path="flixel.FlxSprite"/></replayButton>
		<cancelButton><c path="flixel.FlxSprite"/></cancelButton>
		<replaySelect expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</replaySelect>
		<create public="1" set="method" line="18" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="52" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeThing set="method" line="77"><f a=""><x path="Void"/></f></changeThing>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.MainMenuState" params="" file="source/funkin/menus/MainMenuState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<curSelected expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<menuItems><c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxSprite"/></c></menuItems>
		<optionShit expr="CoolUtil.coolTextFile(Paths.txt(&quot;config/menuItems&quot;))">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>CoolUtil.coolTextFile(Paths.txt("config/menuItems"))</e></m></meta>
		</optionShit>
		<bg><c path="flixel.FlxSprite"/></bg>
		<magenta><c path="flixel.FlxSprite"/></magenta>
		<camFollow><c path="flixel.FlxObject"/></camFollow>
		<versionText><c path="funkin.backend.FunkinText"/></versionText>
		<canAccessDebugMenus public="1" expr="!Flags.DISABLE_EDITORS">
			<x path="Bool"/>
			<meta><m n=":value"><e>!Flags.DISABLE_EDITORS</e></m></meta>
		</canAccessDebugMenus>
		<create public="1" set="method" line="31" override="1"><f a=""><x path="Void"/></f></create>
		<selectedSomethin expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selectedSomethin>
		<forceCenterX expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</forceCenterX>
		<update public="1" set="method" line="94" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<switchTo public="1" set="method" line="146" override="1"><f a="nextState">
	<c path="flixel.FlxState"/>
	<x path="Bool"/>
</f></switchTo>
		<selectItem set="method" line="155"><f a=""><x path="Void"/></f></selectItem>
		<changeItem set="method" line="177">
			<f a="?huh" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ huh : 0 }</e></m></meta>
		</changeItem>
		<new public="1" set="method" line="15"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.ModSwitchMenu" params="" file="source/funkin/menus/ModSwitchMenu.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<mods expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</mods>
		<alphabets><c path="flixel.group.FlxTypedGroup"><c path="funkin.menus.ui.Alphabet"/></c></alphabets>
		<curSelected expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<subCam><c path="flixel.FlxCamera"/></subCam>
		<create public="1" set="method" line="17" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="48" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeSelection public="1" set="method" line="62">
			<f a="change:?force" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</changeSelection>
		<destroy public="1" set="method" line="76" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="10"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.PauseSubState" params="" file="source/funkin/menus/PauseSubState.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<script public="1" expr="Flags.DEFAULT_PAUSE_SCRIPT" line="21" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>Flags.DEFAULT_PAUSE_SCRIPT</e></m></meta>
		</script>
		<grpMenuShit><c path="flixel.group.FlxTypedGroup"><c path="funkin.menus.ui.Alphabet"/></c></grpMenuShit>
		<levelInfo><c path="funkin.backend.FunkinText"/></levelInfo>
		<levelDifficulty><c path="funkin.backend.FunkinText"/></levelDifficulty>
		<deathCounter><c path="funkin.backend.FunkinText"/></deathCounter>
		<multiplayerText><c path="funkin.backend.FunkinText"/></multiplayerText>
		<menuItems><c path="Array"><c path="String"/></c></menuItems>
		<curSelected expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<pauseMusic><c path="flixel.sound.FlxSound"/></pauseMusic>
		<pauseScript public="1"><c path="funkin.backend.scripting.Script"/></pauseScript>
		<selectCall public="1"><f a="">
	<c path="funkin.backend.scripting.events.NameEvent"/>
	<x path="Void"/>
</f></selectCall>
		<game public="1" expr="PlayState.instance">
			<c path="funkin.game.PlayState"/>
			<meta><m n=":value"><e>PlayState.instance</e></m></meta>
		</game>
		<__cancelDefault expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__cancelDefault>
		<parentDisabler><c path="funkin.backend.utils.FunkinParentDisabler"/></parentDisabler>
		<create public="1" set="method" line="51" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="129" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<selectOption public="1" set="method" line="150"><f a=""><x path="Void"/></f></selectOption>
		<destroy public="1" set="method" line="187" override="1"><f a=""><x path="Void"/></f></destroy>
		<changeSelection set="method" line="203">
			<f a="?change" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ change : 0 }</e></m></meta>
		</changeSelection>
		<new public="1" set="method" line="43"><f a="?items:?selectCall">
	<c path="Array"><c path="String"/></c>
	<f a="">
		<c path="funkin.backend.scripting.events.NameEvent"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.PlaytestingWarningSubstate" params="" file="source/funkin/menus/PlaytestingWarningSubstate.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<titleAlphabet><c path="funkin.menus.ui.Alphabet"/></titleAlphabet>
		<disclaimer><c path="funkin.backend.FunkinText"/></disclaimer>
		<windowClosing expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</windowClosing>
		<curSelected expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<options expr="[]">
			<c path="Array"><c path="funkin.backend.FunkinText"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</options>
		<buttonsData expr="[]">
			<c path="Array"><t path="funkin.editors.ui.WarningButton"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</buttonsData>
		<indicator><c path="funkin.backend.FunkinText"/></indicator>
		<create public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></create>
		<sinner expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</sinner>
		<__firstFrame expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__firstFrame>
		<update public="1" set="method" line="75" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeSelection set="method" line="103"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<destroy public="1" set="method" line="108" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="23"><f a="closingWindow:buttons">
	<x path="Bool"/>
	<c path="Array"><t path="funkin.editors.ui.WarningButton"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.StoryMenuState" params="" file="source/funkin/menus/StoryMenuState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<characters public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<t path="funkin.backend.week.WeekCharacter"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</characters>
		<weeks public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.week.WeekData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</weeks>
		<weekList public="1"><c path="funkin.menus.StoryWeeklist"/></weekList>
		<scoreMessage public="1" expr="&quot;WEEK SCORE:{0}&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"WEEK SCORE:{0}"</e></m></meta>
		</scoreMessage>
		<scoreText public="1"><c path="flixel.text.FlxText"/></scoreText>
		<tracklist public="1"><c path="flixel.text.FlxText"/></tracklist>
		<weekTitle public="1"><c path="flixel.text.FlxText"/></weekTitle>
		<curDifficulty public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curDifficulty>
		<curWeek public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curWeek>
		<difficultySprites public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</difficultySprites>
		<leftArrow public="1"><c path="flixel.FlxSprite"/></leftArrow>
		<rightArrow public="1"><c path="flixel.FlxSprite"/></rightArrow>
		<blackBar public="1"><c path="flixel.FlxSprite"/></blackBar>
		<weekBG public="1"><c path="flixel.FlxSprite"/></weekBG>
		<interpColor public="1"><c path="funkin.backend.utils.FlxInterpolateColor"/></interpColor>
		<lerpScore public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lerpScore>
		<intendedScore public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</intendedScore>
		<canSelect public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</canSelect>
		<weekSprites public="1"><c path="flixel.group.FlxTypedGroup"><c path="funkin.menus.MenuItem"/></c></weekSprites>
		<characterSprites public="1"><c path="flixel.group.FlxTypedGroup"><c path="funkin.backend.FunkinSprite"/></c></characterSprites>
		<create public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></create>
		<__lastDifficultyTween><c path="flixel.tweens.FlxTween"/></__lastDifficultyTween>
		<update public="1" set="method" line="139" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<beatHit public="1" set="method" line="168" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<goBack public="1" set="method" line="174"><f a=""><x path="Void"/></f></goBack>
		<changeWeek public="1" set="method" line="180">
			<f a="change:?force" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</changeWeek>
		<__oldDiffName expr="null">
			<x path="Null"><c path="String"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</__oldDiffName>
		<changeDifficulty public="1" set="method" line="210">
			<f a="change:?force" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</changeDifficulty>
		<loadXMLs public="1" set="method" line="236"><f a=""><x path="Void"/></f></loadXMLs>
		<addCharacter public="1" set="method" line="243"><f a="char">
	<x path="flixel.util.typeLimit.OneOfTwo">
		<c path="String"/>
		<t path="funkin.backend.week.WeekCharacter"/>
	</x>
	<x path="Void"/>
</f></addCharacter>
		<modifyCharacterAt public="1" set="method" line="253"><f a="i:?data">
	<x path="Int"/>
	<x path="Null"><t path="funkin.backend.week.WeekCharacter"/></x>
	<c path="funkin.backend.FunkinSprite"/>
</f></modifyCharacterAt>
		<selectWeek public="1" set="method" line="277"><f a=""><x path="Void"/></f></selectWeek>
		<new public="1" set="method" line="18"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.MenuItem" params="" file="source/funkin/menus/StoryMenuState.hx" module="funkin.menus.StoryMenuState">
		<extends path="flixel.FlxSprite"/>
		<targetY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</targetY>
		<isFlashing expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isFlashing>
		<startFlashing public="1" set="method" line="312"><f a=""><x path="Void"/></f></startFlashing>
		<time expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</time>
		<update public="1" set="method" line="329" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="301"><f a="x:y:path">
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.StoryWeeklist" params="" file="source/funkin/menus/StoryMenuState.hx" module="funkin.menus.StoryMenuState">
		<get public="1" set="method" line="359" static="1">
			<f a="?useTxt:?loadCharactersData" v="true:true">
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="funkin.menus.StoryWeeklist"/>
			</f>
			<meta><m n=":value"><e>{ loadCharactersData : true, useTxt : true }</e></m></meta>
		</get>
		<weeks public="1" expr="[]">
			<c path="Array"><t path="funkin.backend.week.WeekData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</weeks>
		<getWeeksFromSource public="1" set="method" line="344">
			<f a="source:?useTxt:?loadCharactersData" v=":true:true">
				<x path="funkin.backend.assets.AssetSource"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ loadCharactersData : true, useTxt : true }</e></m></meta>
		</getWeeksFromSource>
		<new public="1" set="method" line="342"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.TitleState" params="" file="source/funkin/menus/TitleState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<initialized expr="false" line="19" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</initialized>
		<hasCheckedUpdates expr="false" line="20" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasCheckedUpdates>
		<curWacky public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</curWacky>
		<blackScreen public="1"><c path="flixel.FlxSprite"/></blackScreen>
		<textGroup public="1"><t path="flixel.group.FlxGroup"/></textGroup>
		<create public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></create>
		<titleText><c path="flixel.FlxSprite"/></titleText>
		<titleScreenSprites><c path="funkin.backend.MusicBeatGroup"/></titleScreenSprites>
		<startIntro set="method" line="44"><f a=""><x path="Void"/></f></startIntro>
		<getIntroTextShit public="1" set="method" line="85"><f a=""><c path="Array"><c path="Array"><c path="String"/></c></c></f></getIntroTextShit>
		<transitioning expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transitioning>
		<update public="1" set="method" line="102" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<pressEnter public="1" set="method" line="146"><f a=""><x path="Void"/></f></pressEnter>
		<goToMainMenu set="method" line="158"><f a=""><x path="Void"/></f></goToMainMenu>
		<createCoolText public="1" set="method" line="174"><f a="textArray">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></createCoolText>
		<addMoreText public="1" set="method" line="185"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></addMoreText>
		<deleteCoolText public="1" set="method" line="192"><f a=""><x path="Void"/></f></deleteCoolText>
		<beatHit public="1" set="method" line="200" override="1"><f a="curBeat">
	<x path="Int"/>
	<x path="Void"/>
</f></beatHit>
		<xml public="1"><x path="haxe.xml.Access"/></xml>
		<titleLength public="1" expr="16">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</titleLength>
		<titleLines public="1" expr="[1 =&gt; new IntroText([&quot;ninjamuffin99&quot;, &quot;phantomArcade&quot;, &quot;kawaisprite&quot;, &quot;evilsk8er&quot;]), 3 =&gt; new IntroText([&quot;ninjamuffin99&quot;, &quot;phantomArcade&quot;, &quot;kawaisprite&quot;, &quot;evilsk8er&quot;, &quot;present&quot;]), 4 =&gt; new IntroText(), 5 =&gt; new IntroText([&quot;In association&quot;, &quot;with&quot;]), 7 =&gt; new IntroText([&quot;In association&quot;, &quot;with&quot;, &quot;newgrounds&quot;, { name : &quot;newgroundsLogo&quot;, path : &quot;menus/titlescreen/newgrounds_logo&quot;, scale : 0.8 }]), 8 =&gt; new IntroText(), 9 =&gt; new IntroText([&quot;{introText1}&quot;]), 11 =&gt; new IntroText([&quot;{introText1}&quot;, &quot;{introText2}&quot;]), 12 =&gt; new IntroText(), 13 =&gt; new IntroText([&quot;Friday&quot;]), 14 =&gt; new IntroText([&quot;Friday&quot;, &quot;Night&quot;]), 15 =&gt; new IntroText([&quot;Friday&quot;, &quot;Night&quot;, &quot;Funkin'&quot;])]">
			<t path="Map">
				<x path="Int"/>
				<c path="funkin.menus.IntroText"/>
			</t>
			<meta><m n=":value"><e>[1 =&gt; new IntroText(["ninjamuffin99", "phantomArcade", "kawaisprite", "evilsk8er"]), 3 =&gt; new IntroText(["ninjamuffin99", "phantomArcade", "kawaisprite", "evilsk8er", "present"]), 4 =&gt; new IntroText(), 5 =&gt; new IntroText(["In association", "with"]), 7 =&gt; new IntroText(["In association", "with", "newgrounds", { name : "newgroundsLogo", path : "menus/titlescreen/newgrounds_logo", scale : 0.8 }]), 8 =&gt; new IntroText(), 9 =&gt; new IntroText(["{introText1}"]), 11 =&gt; new IntroText(["{introText1}", "{introText2}"]), 12 =&gt; new IntroText(), 13 =&gt; new IntroText(["Friday"]), 14 =&gt; new IntroText(["Friday", "Night"]), 15 =&gt; new IntroText(["Friday", "Night", "Funkin'"])]</e></m></meta>
		</titleLines>
		<titleSprites public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</titleSprites>
		<loadXML public="1" set="method" line="235"><f a=""><x path="Void"/></f></loadXML>
		<skippedIntro expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skippedIntro>
		<skipIntro public="1" set="method" line="294"><f a=""><x path="Void"/></f></skipIntro>
		<new public="1" set="method" line="17"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.backend.assets.ModsFolder</e></m>
			<m n=":allow"><e>funkin.backend.system.MainState</e></m>
		</meta>
	</class>
	<class path="funkin.menus.IntroText" params="" file="source/funkin/menus/TitleState.hx" module="funkin.menus.TitleState">
		<lines public="1" expr="[]">
			<c path="Array"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<t path="funkin.menus.TitleStateImage"/>
</x></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</lines>
		<show public="1" set="method" line="313"><f a=""><x path="Void"/></f></show>
		<new public="1" set="method" line="309"><f a="?lines">
	<c path="Array"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<t path="funkin.menus.TitleStateImage"/>
</x></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.menus.TitleStateImage" params="" file="source/funkin/menus/TitleState.hx" module="funkin.menus.TitleState"><a>
	<scale>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</scale>
	<path><c path="String"/></path>
	<name><c path="String"/></name>
	<flipY>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</flipY>
	<flipX>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</flipX>
</a></typedef>
	<class path="funkin.menus.WarningState" params="" file="source/funkin/menus/WarningState.hx">
		<extends path="funkin.backend.MusicBeatState"/>
		<titleAlphabet><c path="funkin.menus.ui.Alphabet"/></titleAlphabet>
		<disclaimer><c path="funkin.backend.FunkinText"/></disclaimer>
		<transitioning expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</transitioning>
		<create public="1" set="method" line="13" override="1"><f a=""><x path="Void"/></f></create>
		<update public="1" set="method" line="40" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<goToTitle set="method" line="57"><f a=""><x path="Void"/></f></goToTitle>
		<new public="1" set="method" line="7"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.credits.CreditsCodename" params="" file="source/funkin/menus/credits/CreditsCodename.hx">
		<extends path="funkin.options.TreeMenuScreen"/>
		<error public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</error>
		<totalContributions public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</totalContributions>
		<contribFormats public="1" expr="[]">
			<c path="Array"><c path="flixel.text.FlxTextFormatMarkerPair"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</contribFormats>
		<_canReset expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</_canReset>
		<_downloadingSteps expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_downloadingSteps>
		<update public="1" set="method" line="25" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<tryUpdating public="1" set="method" line="40">
			<f a="?forceDisplaying" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceDisplaying : false }</e></m></meta>
		</tryUpdating>
		<updateMenuDesc public="1" set="method" line="49" override="1"><f a="?txt">
	<c path="String"/>
	<x path="Void"/>
</f></updateMenuDesc>
		<updateMarkup public="1" set="method" line="55"><f a=""><x path="Void"/></f></updateMarkup>
		<close public="1" set="method" line="65" override="1"><f a=""><x path="Void"/></f></close>
		<checkUpdate public="1" set="method" line="70"><f a=""><x path="Bool"/></f></checkUpdate>
		<displayList public="1" set="method" line="111"><f a=""><x path="Void"/></f></displayList>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.credits.CreditsMain" params="" file="source/funkin/menus/credits/CreditsMain.hx">
		<extends path="funkin.options.TreeMenu"/>
		<bg><c path="flixel.FlxSprite"/></bg>
		<items expr="[]">
			<c path="Array"><c path="funkin.options.type.OptionType"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</items>
		<create public="1" set="method" line="15" override="1"><f a=""><x path="Void"/></f></create>
		<updateBG public="1" set="method" line="43"><f a=""><x path="Void"/></f></updateBG>
		<parseCreditsFromXML public="1" set="method" line="51">
			<f a="xml:?source" v=":BOTH">
				<x path="haxe.xml.Access"/>
				<x path="funkin.backend.assets.AssetSource"/>
				<c path="Array"><c path="flixel.FlxSprite"/></c>
			</f>
			<meta><m n=":value"><e>{ source : BOTH }</e></m></meta>
		</parseCreditsFromXML>
		<new public="1" set="method" line="11"><f a="?exitCallback:?scriptsAllowed:?scriptName">
	<f a="">
		<c path="funkin.options.TreeMenu"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.ui.AlphabetOutline" params="" file="source/funkin/menus/ui/Alphabet.hx" module="funkin.menus.ui.Alphabet" final="1">
		<anim public="1"><c path="String"/></anim>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<new public="1" set="method" line="19">
			<f a="anim:x:y">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
		</new>
		<meta><m n=":structInit"/></meta>
	</class>
	<class path="funkin.menus.ui.AlphabetComponent" params="" file="source/funkin/menus/ui/Alphabet.hx" module="funkin.menus.ui.Alphabet" final="1">
		<refIndex public="1">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":optional"/></meta>
		</refIndex>
		<outIndex public="1">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":optional"/></meta>
		</outIndex>
		<anim public="1"><c path="String"/></anim>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<shouldRotate public="1"><x path="Bool"/></shouldRotate>
		<angle public="1"><x path="Float"/></angle>
		<sin public="1"><x path="Float"/></sin>
		<cos public="1"><x path="Float"/></cos>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<hasColorMode public="1"><x path="Bool"/></hasColorMode>
		<colorMode public="1"><x path="funkin.menus.ui.ColorMode"/></colorMode>
		<new public="1" set="method" line="25">
			<f a="?refIndex:?outIndex:anim:x:y:shouldRotate:angle:sin:cos:scaleX:scaleY:hasColorMode:colorMode">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="funkin.menus.ui.ColorMode"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="funkin.menus.ui.AlphabetLetterData" params="" file="source/funkin/menus/ui/Alphabet.hx" module="funkin.menus.ui.Alphabet" final="1">
		<isDefault public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":optional"/>
			</meta>
		</isDefault>
		<advance public="1"><x path="Float"/></advance>
		<advanceEmpty public="1"><x path="Bool"/></advanceEmpty>
		<components public="1"><c path="Array"><c path="funkin.menus.ui.AlphabetComponent"/></c></components>
		<startIndex public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</startIndex>
		<new public="1" set="method" line="45">
			<f a="?isDefault:advance:advanceEmpty:components:?startIndex">
				<x path="Null"><x path="Bool"/></x>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="funkin.menus.ui.AlphabetComponent"/></c>
				<x path="Null"><x path="Int"/></x>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="funkin.menus.ui.AlphabetAlignment" params="" file="source/funkin/menus/ui/Alphabet.hx" module="funkin.menus.ui.Alphabet">
		<from>
			<icast><t path="flixel.ByteUInt"/></icast>
			<icast field="fromString"><c path="String"/></icast>
		</from>
		<this><t path="flixel.ByteUInt"/></this>
		<to><icast><t path="flixel.ByteUInt"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.menus.ui._Alphabet.AlphabetAlignment_Impl_" params="" file="source/funkin/menus/ui/Alphabet.hx" private="1" module="funkin.menus.ui.Alphabet" final="1">
	<LEFT public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="funkin.menus.ui.AlphabetAlignment"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LEFT>
	<CENTER public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="funkin.menus.ui.AlphabetAlignment"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CENTER>
	<RIGHT public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="funkin.menus.ui.AlphabetAlignment"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RIGHT>
	<getMultiplier public="1" set="method" line="58" static="1"><f a="this">
	<t path="flixel.ByteUInt"/>
	<x path="Float"/>
</f></getMultiplier>
	<fromString public="1" set="method" line="68" static="1">
		<f a="value">
			<c path="String"/>
			<x path="funkin.menus.ui.AlphabetAlignment"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="funkin.menus.ui._Alphabet.AlphabetAlignment_Impl_" params="" file="source/funkin/menus/ui/Alphabet.hx" private="1" module="funkin.menus.ui.Alphabet" final="1">
		<LEFT public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="funkin.menus.ui.AlphabetAlignment"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LEFT>
		<CENTER public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="funkin.menus.ui.AlphabetAlignment"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CENTER>
		<RIGHT public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="funkin.menus.ui.AlphabetAlignment"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RIGHT>
		<getMultiplier public="1" set="method" line="58" static="1"><f a="this">
	<t path="flixel.ByteUInt"/>
	<x path="Float"/>
</f></getMultiplier>
		<fromString public="1" set="method" line="68" static="1">
			<f a="value">
				<c path="String"/>
				<x path="funkin.menus.ui.AlphabetAlignment"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="funkin.menus.ui.CaseMode" params="" file="source/funkin/menus/ui/Alphabet.hx" module="funkin.menus.ui.Alphabet">
		<from>
			<icast><t path="flixel.ByteUInt"/></icast>
			<icast field="fromString"><c path="String"/></icast>
		</from>
		<this><t path="flixel.ByteUInt"/></this>
		<to><icast><t path="flixel.ByteUInt"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.menus.ui._Alphabet.CaseMode_Impl_" params="" file="source/funkin/menus/ui/Alphabet.hx" private="1" module="funkin.menus.ui.Alphabet" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="funkin.menus.ui.CaseMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<UPPER public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="funkin.menus.ui.CaseMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</UPPER>
	<LOWER public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="funkin.menus.ui.CaseMode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</LOWER>
	<fromString public="1" set="method" line="83" static="1">
		<f a="value">
			<c path="String"/>
			<x path="funkin.menus.ui.CaseMode"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="funkin.menus.ui._Alphabet.CaseMode_Impl_" params="" file="source/funkin/menus/ui/Alphabet.hx" private="1" module="funkin.menus.ui.Alphabet" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="funkin.menus.ui.CaseMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<UPPER public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="funkin.menus.ui.CaseMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</UPPER>
		<LOWER public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="funkin.menus.ui.CaseMode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</LOWER>
		<fromString public="1" set="method" line="83" static="1">
			<f a="value">
				<c path="String"/>
				<x path="funkin.menus.ui.CaseMode"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="funkin.menus.ui.ColorMode" params="" file="source/funkin/menus/ui/Alphabet.hx" module="funkin.menus.ui.Alphabet">
		<from><icast><t path="flixel.ByteInt"/></icast></from>
		<this><t path="flixel.ByteInt"/></this>
		<to><icast><t path="flixel.ByteInt"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.menus.ui._Alphabet.ColorMode_Impl_" params="" file="source/funkin/menus/ui/Alphabet.hx" private="1" module="funkin.menus.ui.Alphabet" final="1">
	<TINT public="1" get="inline" set="null" expr="cast 0" line="92" static="1">
		<x path="funkin.menus.ui.ColorMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TINT>
	<OFFSET public="1" get="inline" set="null" expr="cast 1" line="93" static="1">
		<x path="funkin.menus.ui.ColorMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</OFFSET>
	<NONE public="1" get="inline" set="null" expr="cast 2" line="94" static="1">
		<x path="funkin.menus.ui.ColorMode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</NONE>
	<setColorTransform public="1" set="method" line="96" static="1"><f a="this:color:red:green:blue:alpha">
	<t path="flixel.ByteInt"/>
	<c path="openfl.geom.ColorTransform"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setColorTransform>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="funkin.menus.ui._Alphabet.ColorMode_Impl_" params="" file="source/funkin/menus/ui/Alphabet.hx" private="1" module="funkin.menus.ui.Alphabet" final="1">
		<TINT public="1" get="inline" set="null" expr="cast 0" line="92" static="1">
			<x path="funkin.menus.ui.ColorMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TINT>
		<OFFSET public="1" get="inline" set="null" expr="cast 1" line="93" static="1">
			<x path="funkin.menus.ui.ColorMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</OFFSET>
		<NONE public="1" get="inline" set="null" expr="cast 2" line="94" static="1">
			<x path="funkin.menus.ui.ColorMode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</NONE>
		<setColorTransform public="1" set="method" line="96" static="1"><f a="this:color:red:green:blue:alpha">
	<t path="flixel.ByteInt"/>
	<c path="openfl.geom.ColorTransform"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setColorTransform>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="funkin.menus.ui.AlphabetRenderMode" params="" file="source/funkin/menus/ui/Alphabet.hx" module="funkin.menus.ui.Alphabet">
		<from><icast><t path="flixel.ByteUInt"/></icast></from>
		<this><t path="flixel.ByteUInt"/></this>
		<to><icast><t path="flixel.ByteUInt"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="funkin.menus.ui._Alphabet.AlphabetRenderMode_Impl_" params="" file="source/funkin/menus/ui/Alphabet.hx" private="1" module="funkin.menus.ui.Alphabet" extern="1" final="1">
	<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="113" static="1">
		<x path="funkin.menus.ui.AlphabetRenderMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</DEFAULT>
	<MONOSPACE public="1" get="inline" set="null" expr="cast 1" line="114" static="1">
		<x path="funkin.menus.ui.AlphabetRenderMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</MONOSPACE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="funkin.menus.ui._Alphabet.AlphabetRenderMode_Impl_" params="" file="source/funkin/menus/ui/Alphabet.hx" private="1" module="funkin.menus.ui.Alphabet" extern="1" final="1">
		<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="113" static="1">
			<x path="funkin.menus.ui.AlphabetRenderMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</DEFAULT>
		<MONOSPACE public="1" get="inline" set="null" expr="cast 1" line="114" static="1">
			<x path="funkin.menus.ui.AlphabetRenderMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</MONOSPACE>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="funkin.menus.ui.Alphabet" params="" file="source/funkin/menus/ui/Alphabet.hx">
		<extends path="flixel.FlxSprite"/>
		<alphabetProperties expr="[&quot;fps&quot;, &quot;advance&quot;, &quot;lineGap&quot;, &quot;forceCasing&quot;, &quot;useColorOffsets&quot;, &quot;antialiasing&quot;]" line="760" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["fps", "advance", "lineGap", "forceCasing", "useColorOffsets", "antialiasing"]</e></m></meta>
		</alphabetProperties>
		<componentProperties expr="[&quot;name&quot;, &quot;anim&quot;, &quot;x&quot;, &quot;y&quot;, &quot;scaleX&quot;, &quot;scaleY&quot;, &quot;angle&quot;, &quot;offsetX&quot;, &quot;offsetY&quot;]" line="761" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["name", "anim", "x", "y", "scaleX", "scaleY", "angle", "offsetX", "offsetY"]</e></m></meta>
		</componentProperties>
		<effects public="1" expr="[]">
			<c path="Array"><c path="funkin.menus.ui.effects.RegionEffect"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</effects>
		<__renderData><c path="funkin.menus.ui.effects.AlphabetRenderData"/></__renderData>
		<__component><c path="funkin.menus.ui.AlphabetComponent"/></__component>
		<__useDrawScale expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__useDrawScale>
		<__drawScale expr="FlxPoint.get(1, 1)">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(1, 1)</e></m></meta>
		</__drawScale>
		<text public="1" set="accessor" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</text>
		<textWidth public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
		</textWidth>
		<textHeight public="1" get="accessor" set="null"><x path="Float"/></textHeight>
		<alignment public="1" expr="LEFT">
			<x path="funkin.menus.ui.AlphabetAlignment"/>
			<meta><m n=":value"><e>LEFT</e></m></meta>
		</alignment>
		<forceCase public="1" expr="NONE">
			<x path="funkin.menus.ui.CaseMode"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</forceCase>
		<__laneWidths expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__laneWidths>
		<__forceWidth expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</__forceWidth>
		<__queueResize expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__queueResize>
		<__animTime expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</__animTime>
		<__ogForceScreen expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__ogForceScreen>
		<originOffset public="1" expr="FlxPoint.get()">
			<x path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</originOffset>
		<font public="1" set="accessor"><c path="String"/></font>
		<colorMode expr="TINT">
			<x path="funkin.menus.ui.ColorMode"/>
			<meta><m n=":value"><e>TINT</e></m></meta>
		</colorMode>
		<defaultAdvance expr="40.0">
			<x path="Float"/>
			<meta><m n=":value"><e>40.0</e></m></meta>
		</defaultAdvance>
		<lineGap expr="75.0">
			<x path="Float"/>
			<meta><m n=":value"><e>75.0</e></m></meta>
		</lineGap>
		<fps expr="24.0">
			<x path="Float"/>
			<meta><m n=":value"><e>24.0</e></m></meta>
		</fps>
		<letterData expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="funkin.menus.ui.AlphabetLetterData"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</letterData>
		<defaults expr="{  var v = new Vector(3);  v[0] = null;  v[1] = null;  v[2] = null;  v; }">
			<x path="haxe.ds.Vector"><c path="funkin.menus.ui.AlphabetLetterData"/></x>
			<meta><m n=":value"><e>{
	var v = new Vector(3);
	v[0] = null;
	v[1] = null;
	v[2] = null;
	v;
}</e></m></meta>
		</defaults>
		<loaded expr="{  var v = new Vector(3);  v[0] = [];  v[1] = [];  v[2] = [];  v; }">
			<x path="haxe.ds.Vector"><c path="Array"><c path="String"/></c></x>
			<meta><m n=":value"><e>{
	var v = new Vector(3);
	v[0] = [];
	v[1] = [];
	v[2] = [];
	v;
}</e></m></meta>
		</loaded>
		<manualLetters expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</manualLetters>
		<failedLetters expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</failedLetters>
		<failedOutlines expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</failedOutlines>
		<renderMode public="1" expr="DEFAULT">
			<x path="funkin.menus.ui.AlphabetRenderMode"/>
			<meta><m n=":value"><e>DEFAULT</e></m></meta>
		</renderMode>
		<targetY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</targetY>
		<isMenuItem public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isMenuItem>
		<itemHeight public="1" expr="120">
			<x path="Float"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</itemHeight>
		<update public="1" set="method" line="180" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="211" override="1"><f a=""><x path="Void"/></f></draw>
		<isSimpleRender public="1" set="method" line="217" override="1"><f a="?camera">
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></isSimpleRender>
		<drawComplex set="method" line="221" override="1"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawComplex>
		<drawLetter set="method" line="344"><f a="camera">
	<x path="Null"><c path="flixel.FlxCamera"/></x>
	<x path="Void"/>
</f></drawLetter>
		<updateHitbox public="1" set="method" line="399" override="1"><f a=""><x path="Void"/></f></updateHitbox>
		<recalcSizes set="method" line="404"><f a=""><x path="Void"/></f></recalcSizes>
		<getAdvance set="method" line="432"><f a="letter:anim:data">
	<c path="String"/>
	<c path="flixel.animation.FlxAnimation"/>
	<c path="funkin.menus.ui.AlphabetLetterData"/>
	<x path="Float"/>
</f></getAdvance>
		<fastGetData set="method" line="443"><f a="char">
	<c path="String"/>
	<c path="funkin.menus.ui.AlphabetLetterData"/>
</f></fastGetData>
		<getData set="method" line="459"><f a="char">
	<c path="String"/>
	<c path="funkin.menus.ui.AlphabetLetterData"/>
</f></getData>
		<defaultsIndexOf final="1" set="method" line="477"><f a="data">
	<c path="funkin.menus.ui.AlphabetLetterData"/>
	<x path="Int"/>
</f></defaultsIndexOf>
		<fastGetLetterAnim set="method" line="486"><f a="char:data:component:index">
	<c path="String"/>
	<c path="funkin.menus.ui.AlphabetLetterData"/>
	<c path="funkin.menus.ui.AlphabetComponent"/>
	<x path="Int"/>
	<c path="flixel.animation.FlxAnimation"/>
</f></fastGetLetterAnim>
		<getLetterAnim set="method" line="496"><f a="char:data:component:index">
	<c path="String"/>
	<c path="funkin.menus.ui.AlphabetLetterData"/>
	<c path="funkin.menus.ui.AlphabetComponent"/>
	<x path="Int"/>
	<c path="flixel.animation.FlxAnimation"/>
</f></getLetterAnim>
		<checkNode set="method" line="527"><f a="node">
	<c path="Xml"/>
	<x path="Void"/>
</f></checkNode>
		<loadFont set="method" line="724"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></loadFont>
		<buildXML public="1" set="method" line="763"><f a=""><c path="Xml"/></f></buildXML>
		<copyData public="1" set="method" line="792"><f a="from">
	<c path="funkin.menus.ui.Alphabet"/>
	<x path="Void"/>
</f></copyData>
		<destroy public="1" set="method" line="812" override="1"><f a=""><x path="Void"/></f></destroy>
		<get_textWidth set="method" line="826"><f a=""><x path="Float"/></f></get_textWidth>
		<set_textWidth set="method" line="831"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_textWidth>
		<get_width set="method" line="837" override="1"><f a=""><x path="Float"/></f></get_width>
		<get_height set="method" line="840" override="1"><f a=""><x path="Float"/></f></get_height>
		<get_textHeight set="method" line="844"><f a=""><x path="Float"/></f></get_textHeight>
		<set_text set="method" line="850"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<set_font set="method" line="856"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_font>
		<new public="1" set="method" line="172">
			<f a="?x:?y:?text:?font" v="::&quot;&quot;:&quot;normal&quot;">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="flixel.util.typeLimit.OneOfTwo">
					<c path="String"/>
					<x path="Bool"/>
				</x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ font : "normal", text : "" }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>funkin.editors.alphabet.AlphabetEditor</e></m>
			<m n=":allow"><e>funkin.editors.alphabet.AlphabetMainDataScreen</e></m>
		</meta>
	</class>
	<class path="funkin.menus.ui.ClassicAlphabet" params="" file="source/funkin/menus/ui/ClassicAlphabet.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<delay public="1" expr="0.05">
			<x path="Float"/>
			<meta><m n=":value"><e>0.05</e></m></meta>
		</delay>
		<paused public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</paused>
		<targetY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</targetY>
		<isMenuItem public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isMenuItem>
		<text public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</text>
		<_finalText expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</_finalText>
		<_curText expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</_curText>
		<yMulti expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</yMulti>
		<lastSprite><c path="funkin.menus.ui.AlphaCharacter"/></lastSprite>
		<xPosResetted expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</xPosResetted>
		<splitWords expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</splitWords>
		<isBold expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isBold>
		<set_color set="method" line="41" override="1"><f a="c">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<refreshAlphabetXML public="1" set="method" line="52"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></refreshAlphabetXML>
		<addText public="1" set="method" line="127"><f a=""><x path="Void"/></f></addText>
		<doSplitWords set="method" line="163"><f a=""><x path="Void"/></f></doSplitWords>
		<startTypedText public="1" set="method" line="170"><f a=""><x path="Void"/></f></startTypedText>
		<update public="1" set="method" line="198" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="82">
			<f a="x:y:?text:?bold:?typed" v="::&quot;&quot;:false:false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ typed : false, bold : false, text : "" }</e></m></meta>
		</new>
		<haxe_doc>* Loosely based on FlxTypeText lolol</haxe_doc>
	</class>
	<class path="funkin.menus.ui.AlphaCharacter" params="" file="source/funkin/menus/ui/ClassicAlphabet.hx" module="funkin.menus.ui.ClassicAlphabet">
		<extends path="flixel.FlxSprite"/>
		<__alphaPath public="1" expr="null" line="222" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__alphaPath>
		<letterAlphabetPath public="1" static="1"><c path="String"/></letterAlphabetPath>
		<boldAlphabetPath public="1" static="1"><c path="String"/></boldAlphabetPath>
		<boldAnims public="1" expr="[]" line="227" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</boldAnims>
		<letterAnims public="1" expr="[]" line="228" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</letterAnims>
		<row public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</row>
		<setColor public="1" set="method" line="232"><f a="c:isBold">
	<x path="flixel.util.FlxColor"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColor>
		<createBold public="1" set="method" line="251"><f a="letter">
	<c path="String"/>
	<x path="Void"/>
</f></createBold>
		<createLetter public="1" set="method" line="270"><f a="letter">
	<c path="String"/>
	<x path="Void"/>
</f></createLetter>
		<new public="1" set="method" line="243"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.ui.FunkinSoundTray" params="" file="source/funkin/menus/ui/FunkinSoundTray.hx">
		<extends path="flixel.system.ui.FlxSoundTray"/>
		<script public="1"><c path="funkin.backend.scripting.Script"/></script>
		<callsUpdate public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</callsUpdate>
		<callsPostUpdate public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</callsPostUpdate>
		<reloadText public="1" set="method" line="36" override="1">
			<f a="?checkIfNull:?reloadDefaultTextFormat:?displayTxt:?y" v="true:true:&quot;VOLUME&quot;:16">
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 16, displayTxt : "VOLUME", reloadDefaultTextFormat : true, checkIfNull : true }</e></m></meta>
		</reloadText>
		<reloadDtf public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></reloadDtf>
		<regenerateBarsArray public="1" set="method" line="56" override="1"><f a=""><x path="Void"/></f></regenerateBarsArray>
		<regenerateBars public="1" set="method" line="66" override="1"><f a=""><x path="Void"/></f></regenerateBars>
		<update public="1" set="method" line="76" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<saveSoundPreferences public="1" set="method" line="83" override="1"><f a=""><x path="Void"/></f></saveSoundPreferences>
		<show public="1" set="method" line="93" override="1">
			<f a="?up" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ up : false }</e></m></meta>
		</show>
		<screenCenter public="1" set="method" line="103" override="1"><f a=""><x path="Void"/></f></screenCenter>
		<__cleanup set="method" line="113" override="1"><f a=""><x path="Void"/></f></__cleanup>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
			<m n=":autoBuild"><e>openfl.utils._internal.AssetsMacro.initBinding()</e></m>
		</meta>
	</class>
	<class path="funkin.menus.ui.Slider" params="" file="source/funkin/menus/ui/Slider.hx">
		<extends path="flixel.FlxSprite"/>
		<playSound public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</playSound>
		<selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<value public="1"><x path="Float"/></value>
		<segments public="1" set="accessor"><x path="Int"/></segments>
		<barWidth public="1" set="accessor"><x path="Float"/></barWidth>
		<barHeight public="1" set="null"><x path="Float"/></barHeight>
		<showSlider public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</showSlider>
		<barFramerate public="1" expr="24.0">
			<x path="Float"/>
			<meta><m n=":value"><e>24.0</e></m></meta>
		</barFramerate>
		<__animTime expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</__animTime>
		<__frameTime><x path="Int"/></__frameTime>
		<__curSegments><x path="Int"/></__curSegments>
		<__barFrame><c path="flixel.graphics.frames.FlxFrame"/></__barFrame>
		<__barClipRect><c path="flixel.math.FlxRect"/></__barClipRect>
		<__valueWidth><x path="Float"/></__valueWidth>
		<__cornerWidth><x path="Float"/></__cornerWidth>
		<__segmentWidth><x path="Float"/></__segmentWidth>
		<__barWidth><x path="Float"/></__barWidth>
		<__flipX><x path="Bool"/></__flipX>
		<__flipY><x path="Bool"/></__flipY>
		<initVars set="method" line="44" override="1"><f a=""><x path="Void"/></f></initVars>
		<destroy public="1" set="method" line="49" override="1"><f a=""><x path="Void"/></f></destroy>
		<playAnimOrDefault set="method" line="55"><f a="a:d">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></playAnimOrDefault>
		<update public="1" set="method" line="60" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<isSimpleRender public="1" set="method" line="83" override="1"><f a="?camera">
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></isSimpleRender>
		<drawComplex set="method" line="84" override="1"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawComplex>
		<prepareDrawMatrix get="inline" set="null" line="107"><f a="camera:x:y">
	<c path="flixel.FlxCamera"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prepareDrawMatrix>
		<forceDrawFrame set="method" line="140"><f a="camera:frame">
	<c path="flixel.FlxCamera"/>
	<c path="flixel.graphics.frames.FlxFrame"/>
	<x path="Void"/>
</f></forceDrawFrame>
		<drawCorner set="method" line="147"><f a="camera:x:flip">
	<c path="flixel.FlxCamera"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></drawCorner>
		<drawBar set="method" line="177"><f a="camera:x:width">
	<c path="flixel.FlxCamera"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></drawBar>
		<drawSegment set="method" line="210"><f a="camera:x:width:offset">
	<c path="flixel.FlxCamera"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></drawSegment>
		<getBarAnim set="method" line="239"><f a="type:filled">
	<x path="Int"/>
	<x path="Bool"/>
	<c path="flixel.animation.FlxAnimation"/>
</f></getBarAnim>
		<sliderResetFrameSize get="inline" set="null" line="247"><f a=""><x path="Void"/></f></sliderResetFrameSize>
		<resetHelpers set="method" line="254" override="1"><f a=""><x path="Void"/></f></resetHelpers>
		<set_frame set="method" line="288" override="1"><f a="v">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.graphics.frames.FlxFrame"/>
</f></set_frame>
		<set_barWidth set="method" line="294"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_barWidth>
		<set_segments set="method" line="299"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_segments>
		<new public="1" set="method" line="34">
			<f a="?x:?y:?value:?barWidth:?segments" v="::0.5:500:5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ segments : 5, barWidth : 500, value : 0.5 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.ui.effects.RegionEffect" params="" file="source/funkin/menus/ui/effects/RegionEffect.hx">
		<effectTime public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</effectTime>
		<speed public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</speed>
		<enabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enabled>
		<regionMin public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</regionMin>
		<regionMax public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</regionMax>
		<resetRegions public="1" set="method" line="51"><f a=""><x path="Void"/></f></resetRegions>
		<addRegion public="1" set="method" line="56"><f a="min:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addRegion>
		<willModify public="1" set="method" line="61"><f a="index:lineIndex:renderData">
	<x path="Int"/>
	<x path="Int"/>
	<c path="funkin.menus.ui.effects.AlphabetRenderData"/>
	<x path="Bool"/>
</f></willModify>
		<modify public="1" set="method" line="76"><f a="index:lineIndex:renderData">
	<x path="Int"/>
	<x path="Int"/>
	<c path="funkin.menus.ui.effects.AlphabetRenderData"/>
	<x path="Void"/>
</f></modify>
		<new public="1" set="method" line="49"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="funkin.menus.ui.effects.ColorWaveEffect" params="" file="source/funkin/menus/ui/effects/ColorWaveEffect.hx">
		<extends path="funkin.menus.ui.effects.RegionEffect"/>
		<period public="1" expr="30">
			<x path="Float"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</period>
		<color1 public="1"><x path="flixel.util.FlxColor"/></color1>
		<color2 public="1"><x path="flixel.util.FlxColor"/></color2>
		<modify public="1" set="method" line="19" override="1"><f a="index:lineIndex:renderData">
	<x path="Int"/>
	<x path="Int"/>
	<c path="funkin.menus.ui.effects.AlphabetRenderData"/>
	<x path="Void"/>
</f></modify>
		<new public="1" set="method" line="11">
			<f a="color1:color2:?period" v="::30">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ period : 30 }</e></m></meta>
		</new>
	</class>
	<class path="funkin.menus.ui.effects.AlphabetRenderData" params="" file="source/funkin/menus/ui/effects/RegionEffect.hx" module="funkin.menus.ui.effects.RegionEffect">
		<parent public="1"><c path="funkin.menus.ui.Alphabet"/></parent>
		<letter public="1"><c path="String"/></letter>
		<offsetX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetX>
		<offsetY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetY>
		<color public="1" get="accessor" set="accessor"><x path="flixel.util.FlxColor"/></color>
		<red public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</red>
		<green public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</green>
		<blue public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</blue>
		<alpha public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</alpha>
		<reset public="1" set="method" line="20"><f a="parent:red:green:blue:alpha:letter">
	<c path="funkin.menus.ui.Alphabet"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Void"/>
</f></reset>
		<get_color set="method" line="31"><f a=""><x path="flixel.util.FlxColor"/></f></get_color>
		<set_color set="method" line="34"><f a="value">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_color>
		<new public="1" set="method" line="16"><f a="parent">
	<c path="funkin.menus.ui.Alphabet"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.menus.ui.effects.ShakeEffect" params="" file="source/funkin/menus/ui/effects/ShakeEffect.hx">
		<extends path="funkin.menus.ui.effects.RegionEffect"/>
		<intensityX public="1" expr="2">
			<x path="Float"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</intensityX>
		<intensityY public="1" expr="2">
			<x path="Float"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</intensityY>
		<willModify public="1" set="method" line="15" override="1"><f a="index:lineIndex:renderData">
	<x path="Int"/>
	<x path="Int"/>
	<c path="funkin.menus.ui.effects.AlphabetRenderData"/>
	<x path="Bool"/>
</f></willModify>
		<modify public="1" set="method" line="19" override="1"><f a="index:lineIndex:renderData">
	<x path="Int"/>
	<x path="Int"/>
	<c path="funkin.menus.ui.effects.AlphabetRenderData"/>
	<x path="Void"/>
</f></modify>
		<new public="1" set="method" line="9">
			<f a="?x:?y" v="2:2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 2, x : 2 }</e></m></meta>
		</new>
	</class>
	<class path="funkin.menus.ui.effects.TypeEffect" params="" file="source/funkin/menus/ui/effects/TypeEffect.hx">
		<extends path="funkin.menus.ui.effects.RegionEffect"/>
		<interval public="1" expr="0.075">
			<x path="Float"/>
			<meta><m n=":value"><e>0.075</e></m></meta>
		</interval>
		<lastIndex expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</lastIndex>
		<alphaStart public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</alphaStart>
		<alphaEase public="1" expr="FlxEase.quadOut">
			<t path="flixel.tweens.EaseFunction"/>
			<meta><m n=":value"><e>FlxEase.quadOut</e></m></meta>
		</alphaEase>
		<offsetStart public="1" expr="0.0">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0</e></m></meta>
		</offsetStart>
		<offsetEase public="1" expr="FlxEase.quadOut">
			<t path="flixel.tweens.EaseFunction"/>
			<meta><m n=":value"><e>FlxEase.quadOut</e></m></meta>
		</offsetEase>
		<sounds public="1" expr="[]">
			<c path="Array"><c path="flixel.sound.FlxSound"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sounds>
		<randomSound public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</randomSound>
		<curSound expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</curSound>
		<modify public="1" set="method" line="20" override="1"><f a="index:lineIndex:renderData">
	<x path="Int"/>
	<x path="Int"/>
	<c path="funkin.menus.ui.effects.AlphabetRenderData"/>
	<x path="Void"/>
</f></modify>
		<addSound public="1" set="method" line="38"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></addSound>
		<clearSounds public="1" set="method" line="42"><f a=""><x path="Void"/></f></clearSounds>
		<resetTimer public="1" set="method" line="46"><f a=""><x path="Void"/></f></resetTimer>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="funkin.menus.ui.effects.WaveEffect" params="" file="source/funkin/menus/ui/effects/WaveEffect.hx">
		<extends path="funkin.menus.ui.effects.RegionEffect"/>
		<intensityX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</intensityX>
		<intensityY public="1" expr="5">
			<x path="Float"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</intensityY>
		<period public="1" expr="10">
			<x path="Float"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</period>
		<willModify public="1" set="method" line="18" override="1"><f a="index:lineIndex:renderData">
	<x path="Int"/>
	<x path="Int"/>
	<c path="funkin.menus.ui.effects.AlphabetRenderData"/>
	<x path="Bool"/>
</f></willModify>
		<modify public="1" set="method" line="22" override="1"><f a="index:lineIndex:renderData">
	<x path="Int"/>
	<x path="Int"/>
	<c path="funkin.menus.ui.effects.AlphabetRenderData"/>
	<x path="Void"/>
</f></modify>
		<new public="1" set="method" line="10">
			<f a="?x:?y:?p" v="0:5:10">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ p : 10, y : 5, x : 0 }</e></m></meta>
		</new>
	</class>
	<class path="funkin.options.Options" params="" file="source/funkin/options/Options.hx">
		<__save public="1" static="1">
			<c path="flixel.util.FlxSave"/>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":doNotSave"/>
			</meta>
		</__save>
		<__eventAdded expr="false" line="18" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
				<m n=":doNotSave"/>
			</meta>
		</__eventAdded>
		<naughtyness public="1" expr="true" line="23" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* SETTINGS</haxe_doc>
		</naughtyness>
		<downscroll public="1" expr="false" line="24" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</downscroll>
		<ghostTapping public="1" expr="true" line="25" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</ghostTapping>
		<flashingMenu public="1" expr="true" line="26" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</flashingMenu>
		<camZoomOnBeat public="1" expr="true" line="27" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</camZoomOnBeat>
		<fpsCounter public="1" expr="true" line="28" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</fpsCounter>
		<autoPause public="1" expr="true" line="29" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoPause>
		<antialiasing public="1" expr="true" line="30" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</antialiasing>
		<volume public="1" expr="1" line="31" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</volume>
		<volumeMusic public="1" expr="1" line="32" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</volumeMusic>
		<volumeSFX public="1" expr="1" line="33" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</volumeSFX>
		<week6PixelPerfect public="1" expr="true" line="34" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</week6PixelPerfect>
		<gameplayShaders public="1" expr="true" line="35" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</gameplayShaders>
		<colorHealthBar public="1" expr="true" line="36" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</colorHealthBar>
		<lowMemoryMode public="1" expr="false" line="37" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</lowMemoryMode>
		<devMode public="1" expr="false" line="38" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</devMode>
		<betaUpdates public="1" expr="false" line="39" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</betaUpdates>
		<splashesEnabled public="1" expr="true" line="40" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</splashesEnabled>
		<hitWindow public="1" expr="250" line="41" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>250</e></m></meta>
		</hitWindow>
		<songOffset public="1" expr="0" line="42" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</songOffset>
		<framerate public="1" expr="120" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</framerate>
		<gpuOnlyBitmaps public="1" expr="true" line="44" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</gpuOnlyBitmaps>
		<language public="1" expr="&quot;en&quot;" line="45" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"en"</e></m></meta>
		</language>
		<streamedMusic public="1" expr="true" line="46" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</streamedMusic>
		<streamedVocals public="1" expr="false" line="47" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</streamedVocals>
		<quality public="1" expr="1" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</quality>
		<allowConfigWarning public="1" expr="true" line="49" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowConfigWarning>
		<modchartingHoldSubdivisions public="1" expr="4" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</modchartingHoldSubdivisions>
		<lastLoadedMod public="1" expr="null" line="54" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</lastLoadedMod>
		<intensiveBlur public="1" expr="true" line="59" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* EDITORS SETTINGS</haxe_doc>
		</intensiveBlur>
		<editorSFX public="1" expr="true" line="60" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</editorSFX>
		<editorCharterPrettyPrint public="1" expr="false" line="62" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</editorCharterPrettyPrint>
		<editorCharacterPrettyPrint public="1" expr="true" line="63" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</editorCharacterPrettyPrint>
		<editorStagePrettyPrint public="1" expr="true" line="64" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</editorStagePrettyPrint>
		<editorsResizable public="1" expr="true" line="66" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</editorsResizable>
		<bypassEditorsResize public="1" expr="false" line="67" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</bypassEditorsResize>
		<maxUndos public="1" expr="120" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</maxUndos>
		<songOffsetAffectEditors public="1" expr="false" line="69" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</songOffsetAffectEditors>
		<freeplayLastSong public="1" expr="null" line="74" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* QOL FEATURES</haxe_doc>
		</freeplayLastSong>
		<freeplayLastDifficulty public="1" expr="&quot;normal&quot;" line="75" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"normal"</e></m></meta>
		</freeplayLastDifficulty>
		<contributors public="1" expr="[]" line="76" static="1">
			<c path="Array"><t path="funkin.backend.system.github.CreditsGitHubContributor"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</contributors>
		<mainDevs public="1" expr="[]" line="77" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</mainDevs>
		<lastUpdated public="1" static="1"><x path="Null"><x path="Float"/></x></lastUpdated>
		<charterMetronomeEnabled public="1" expr="false" line="83" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* CHARTER</haxe_doc>
		</charterMetronomeEnabled>
		<charterShowSections public="1" expr="true" line="84" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</charterShowSections>
		<charterShowBeats public="1" expr="true" line="85" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</charterShowBeats>
		<charterEnablePlaytestScripts public="1" expr="true" line="86" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</charterEnablePlaytestScripts>
		<charterRainbowWaveforms public="1" expr="false" line="87" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</charterRainbowWaveforms>
		<charterLowDetailWaveforms public="1" expr="false" line="88" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</charterLowDetailWaveforms>
		<charterAutoSaves public="1" expr="true" line="89" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</charterAutoSaves>
		<charterAutoSaveTime public="1" expr="60 * 5" line="90" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>60 * 5</e></m></meta>
		</charterAutoSaveTime>
		<charterAutoSaveWarningTime public="1" expr="5" line="91" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</charterAutoSaveWarningTime>
		<charterAutoSavesSeparateFolder public="1" expr="false" line="92" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</charterAutoSavesSeparateFolder>
		<stageSelected public="1" expr="null" line="97" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* CHARACTER EDITOR</haxe_doc>
		</stageSelected>
		<characterHitbox public="1" expr="true" line="98" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</characterHitbox>
		<characterCamera public="1" expr="true" line="99" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</characterCamera>
		<characterAxis public="1" expr="true" line="100" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</characterAxis>
		<characterDragging public="1" expr="true" line="101" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</characterDragging>
		<playAnimOnOffset public="1" expr="false" line="102" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</playAnimOnOffset>
		<P1_NOTE_LEFT public="1" expr="[A]" line="107" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[A]</e></m></meta>
			<haxe_doc>* PLAYER 1 CONTROLS</haxe_doc>
		</P1_NOTE_LEFT>
		<P1_NOTE_DOWN public="1" expr="[S]" line="108" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[S]</e></m></meta>
		</P1_NOTE_DOWN>
		<P1_NOTE_UP public="1" expr="[W]" line="109" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[W]</e></m></meta>
		</P1_NOTE_UP>
		<P1_NOTE_RIGHT public="1" expr="[D]" line="110" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[D]</e></m></meta>
		</P1_NOTE_RIGHT>
		<P1_LEFT public="1" expr="[A]" line="113" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[A]</e></m></meta>
		</P1_LEFT>
		<P1_DOWN public="1" expr="[S]" line="114" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[S]</e></m></meta>
		</P1_DOWN>
		<P1_UP public="1" expr="[W]" line="115" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[W]</e></m></meta>
		</P1_UP>
		<P1_RIGHT public="1" expr="[D]" line="116" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[D]</e></m></meta>
		</P1_RIGHT>
		<P1_ACCEPT public="1" expr="[ENTER]" line="117" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[ENTER]</e></m></meta>
		</P1_ACCEPT>
		<P1_BACK public="1" expr="[BACKSPACE]" line="118" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[BACKSPACE]</e></m></meta>
		</P1_BACK>
		<P1_PAUSE public="1" expr="[ENTER]" line="119" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[ENTER]</e></m></meta>
		</P1_PAUSE>
		<P1_RESET public="1" expr="[R]" line="122" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[R]</e></m></meta>
		</P1_RESET>
		<P1_SWITCHMOD public="1" expr="[TAB]" line="123" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[TAB]</e></m></meta>
		</P1_SWITCHMOD>
		<P1_VOLUME_UP public="1" expr="[PLUS]" line="124" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[PLUS]</e></m></meta>
		</P1_VOLUME_UP>
		<P1_VOLUME_DOWN public="1" expr="[MINUS]" line="125" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[MINUS]</e></m></meta>
		</P1_VOLUME_DOWN>
		<P1_VOLUME_MUTE public="1" expr="[ZERO]" line="126" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[ZERO]</e></m></meta>
		</P1_VOLUME_MUTE>
		<P1_DEV_ACCESS public="1" expr="[SEVEN]" line="129" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[SEVEN]</e></m></meta>
		</P1_DEV_ACCESS>
		<P1_DEV_CONSOLE public="1" expr="[F2]" line="130" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[F2]</e></m></meta>
		</P1_DEV_CONSOLE>
		<P1_DEV_RELOAD public="1" expr="[F5]" line="131" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[F5]</e></m></meta>
		</P1_DEV_RELOAD>
		<P2_NOTE_LEFT public="1" expr="[LEFT]" line="138" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[LEFT]</e></m></meta>
			<haxe_doc>* PLAYER 2 CONTROLS (ALT)</haxe_doc>
		</P2_NOTE_LEFT>
		<P2_NOTE_DOWN public="1" expr="[DOWN]" line="139" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[DOWN]</e></m></meta>
		</P2_NOTE_DOWN>
		<P2_NOTE_UP public="1" expr="[UP]" line="140" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[UP]</e></m></meta>
		</P2_NOTE_UP>
		<P2_NOTE_RIGHT public="1" expr="[RIGHT]" line="141" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[RIGHT]</e></m></meta>
		</P2_NOTE_RIGHT>
		<P2_LEFT public="1" expr="[LEFT]" line="144" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[LEFT]</e></m></meta>
		</P2_LEFT>
		<P2_DOWN public="1" expr="[DOWN]" line="145" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[DOWN]</e></m></meta>
		</P2_DOWN>
		<P2_UP public="1" expr="[UP]" line="146" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[UP]</e></m></meta>
		</P2_UP>
		<P2_RIGHT public="1" expr="[RIGHT]" line="147" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[RIGHT]</e></m></meta>
		</P2_RIGHT>
		<P2_ACCEPT public="1" expr="[SPACE]" line="148" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[SPACE]</e></m></meta>
		</P2_ACCEPT>
		<P2_BACK public="1" expr="[ESCAPE]" line="149" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[ESCAPE]</e></m></meta>
		</P2_BACK>
		<P2_PAUSE public="1" expr="[ESCAPE]" line="150" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[ESCAPE]</e></m></meta>
		</P2_PAUSE>
		<P2_RESET public="1" expr="[]" line="153" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</P2_RESET>
		<P2_SWITCHMOD public="1" expr="[]" line="154" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</P2_SWITCHMOD>
		<P2_VOLUME_UP public="1" expr="[NUMPADPLUS]" line="155" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[NUMPADPLUS]</e></m></meta>
		</P2_VOLUME_UP>
		<P2_VOLUME_DOWN public="1" expr="[NUMPADMINUS]" line="156" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[NUMPADMINUS]</e></m></meta>
		</P2_VOLUME_DOWN>
		<P2_VOLUME_MUTE public="1" expr="[NUMPADZERO]" line="157" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[NUMPADZERO]</e></m></meta>
		</P2_VOLUME_MUTE>
		<P2_DEV_ACCESS public="1" expr="[]" line="160" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</P2_DEV_ACCESS>
		<P2_DEV_CONSOLE public="1" expr="[]" line="161" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</P2_DEV_CONSOLE>
		<P2_DEV_RELOAD public="1" expr="[]" line="162" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</P2_DEV_RELOAD>
		<SOLO_NOTE_LEFT public="1" get="accessor" set="null" static="1">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<haxe_doc>* SOLO GETTERS</haxe_doc>
		</SOLO_NOTE_LEFT>
		<SOLO_NOTE_DOWN public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_NOTE_DOWN>
		<SOLO_NOTE_UP public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_NOTE_UP>
		<SOLO_NOTE_RIGHT public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_NOTE_RIGHT>
		<SOLO_LEFT public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_LEFT>
		<SOLO_DOWN public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_DOWN>
		<SOLO_UP public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_UP>
		<SOLO_RIGHT public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_RIGHT>
		<SOLO_ACCEPT public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_ACCEPT>
		<SOLO_BACK public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_BACK>
		<SOLO_PAUSE public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_PAUSE>
		<SOLO_RESET public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_RESET>
		<SOLO_SWITCHMOD public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_SWITCHMOD>
		<SOLO_VOLUME_UP public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_VOLUME_UP>
		<SOLO_VOLUME_DOWN public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_VOLUME_DOWN>
		<SOLO_VOLUME_MUTE public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_VOLUME_MUTE>
		<SOLO_DEV_ACCESS public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_DEV_ACCESS>
		<SOLO_DEV_CONSOLE public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_DEV_CONSOLE>
		<SOLO_DEV_RELOAD public="1" get="accessor" set="null" static="1"><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></SOLO_DEV_RELOAD>
		<load public="1" set="method" line="195" static="1"><f a=""><x path="Void"/></f></load>
		<applySettings public="1" set="method" line="220" static="1"><f a=""><x path="Void"/></f></applySettings>
		<applyKeybinds public="1" set="method" line="241" static="1"><f a=""><x path="Void"/></f></applyKeybinds>
		<save public="1" set="method" line="251" static="1"><f a=""><x path="Void"/></f></save>
		<get_SOLO_NOTE_LEFT get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_NOTE_LEFT>
		<get_SOLO_NOTE_DOWN get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_NOTE_DOWN>
		<get_SOLO_NOTE_UP get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_NOTE_UP>
		<get_SOLO_NOTE_RIGHT get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_NOTE_RIGHT>
		<get_SOLO_LEFT get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_LEFT>
		<get_SOLO_DOWN get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_DOWN>
		<get_SOLO_UP get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_UP>
		<get_SOLO_RIGHT get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_RIGHT>
		<get_SOLO_ACCEPT get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_ACCEPT>
		<get_SOLO_BACK get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_BACK>
		<get_SOLO_PAUSE get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_PAUSE>
		<get_SOLO_RESET get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_RESET>
		<get_SOLO_SWITCHMOD get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_SWITCHMOD>
		<get_SOLO_VOLUME_UP get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_VOLUME_UP>
		<get_SOLO_VOLUME_DOWN get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_VOLUME_DOWN>
		<get_SOLO_VOLUME_MUTE get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_VOLUME_MUTE>
		<get_SOLO_DEV_ACCESS get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_DEV_ACCESS>
		<get_SOLO_DEV_CONSOLE get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_DEV_CONSOLE>
		<get_SOLO_DEV_RELOAD get="inline" set="null" line="25" static="1"><f a=""><c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c></f></get_SOLO_DEV_RELOAD>
		<__flush public="1" set="method" line="12" static="1"><f a=""><x path="Void"/></f></__flush>
		<__load public="1" set="method" line="12" static="1"><f a=""><x path="Void"/></f></__load>
		<haxe_doc>* The save data of the engine.
 * Mod save data is stored in `FlxG.save.data`.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.OptionsMacro.build()</e></m>
			<m n=":build"><e>funkin.backend.system.macros.FunkinSaveMacro.build("__save", "__flush", "__load")</e></m>
		</meta>
	</class>
	<typedef path="funkin.options.OptionCategory" params="" file="source/funkin/options/OptionsMenu.hx" module="funkin.options.OptionsMenu"><a>
	<suffix>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</suffix>
	<substate>
		<x path="Null"><x path="flixel.util.typeLimit.OneOfThree">
	<c path="funkin.backend.MusicBeatSubstate"/>
	<x path="Class"><c path="funkin.backend.MusicBeatSubstate"/></x>
	<f a="name:desc">
		<c path="String"/>
		<c path="String"/>
		<c path="funkin.backend.MusicBeatSubstate"/>
	</f>
</x></x>
		<meta><m n=":optional"/></meta>
	</substate>
	<state>
		<x path="Null"><x path="flixel.util.typeLimit.OneOfThree">
	<c path="funkin.options.TreeMenuScreen"/>
	<x path="Class"><c path="funkin.options.TreeMenuScreen"/></x>
	<f a="name:desc">
		<c path="String"/>
		<c path="String"/>
		<c path="funkin.options.TreeMenuScreen"/>
	</f>
</x></x>
		<meta><m n=":optional"/></meta>
	</state>
	<name><c path="String"/></name>
	<desc><c path="String"/></desc>
</a></typedef>
	<class path="funkin.options.keybinds.KeybindsOptions" params="" file="source/funkin/options/keybinds/KeybindsOptions.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<instance public="1" static="1"><c path="funkin.options.keybinds.KeybindsOptions"/></instance>
		<translate public="1" set="method" line="12"><f a="id:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></translate>
		<categories public="1" expr="[]">
			<c path="Array"><t path="funkin.options.keybinds.ControlsCategory"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</categories>
		<settingCam public="1"><c path="flixel.FlxCamera"/></settingCam>
		<p2Selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</p2Selected>
		<curSelected public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curSelected>
		<canSelect public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</canSelect>
		<alphabets public="1"><c path="flixel.group.FlxTypedGroup"><c path="funkin.options.keybinds.KeybindSetting"/></c></alphabets>
		<bg public="1"><c path="flixel.FlxSprite"/></bg>
		<coloredBG public="1"><c path="flixel.FlxSprite"/></coloredBG>
		<noteColors public="1" expr="[0xFFC24B99, 0xFF00FFFF, 0xFF12FA05, 0xFFF9393F]">
			<c path="Array"><x path="flixel.util.FlxColor"/></c>
			<meta><m n=":value"><e>[0xFFC24B99, 0xFF00FFFF, 0xFF12FA05, 0xFFF9393F]</e></m></meta>
		</noteColors>
		<camFollow public="1" expr="new FlxObject(0, 0, 2, 2)">
			<c path="flixel.FlxObject"/>
			<meta><m n=":value"><e>new FlxObject(0, 0, 2, 2)</e></m></meta>
		</camFollow>
		<isSubState expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isSubState>
		<create public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="213" override="1"><f a=""><x path="Void"/></f></destroy>
		<skipThisFrame expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</skipThisFrame>
		<update public="1" set="method" line="221" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeSelection public="1" set="method" line="278"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<loadCustomCategories public="1" set="method" line="298"><f a=""><c path="Array"><t path="funkin.options.keybinds.ControlsCategory"/></c></f></loadCustomCategories>
		<new public="1" set="method" line="8"><f a="?scriptsAllowed:?scriptName">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.GameplayOptions" params="" file="source/funkin/options/categories/GameplayOptions.hx">
		<extends path="funkin.options.TreeMenuScreen"/>
		<__metronome expr="FlxG.sound.load(Paths.sound(&quot;editors/charter/metronome&quot;))">
			<c path="flixel.sound.FlxSound"/>
			<meta><m n=":value"><e>FlxG.sound.load(Paths.sound("editors/charter/metronome"))</e></m></meta>
		</__metronome>
		<offsetSetting><c path="funkin.options.type.NumOption"/></offsetSetting>
		<__changeAutoPause set="method" line="27"><f a=""><x path="Void"/></f></__changeAutoPause>
		<__changeOffset set="method" line="28"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></__changeOffset>
		<__changeVolumeMusic set="method" line="29"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></__changeVolumeMusic>
		<__lastBeat expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__lastBeat>
		<__lastSongBeat expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__lastSongBeat>
		<update public="1" set="method" line="34" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeSelection public="1" set="method" line="52" override="1">
			<f a="change:?force" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</changeSelection>
		<close public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.AppearanceOptions" params="" file="source/funkin/options/categories/AppearanceOptions.hx">
		<extends path="funkin.options.TreeMenuScreen"/>
		<__changeFPS set="method" line="20"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></__changeFPS>
		<new public="1" set="method" line="4"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.LanguageOptions" params="" file="source/funkin/options/categories/LanguageOptions.hx">
		<extends path="funkin.options.TreeMenuScreen"/>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.MiscOptions" params="" file="source/funkin/options/categories/MiscOptions.hx">
		<extends path="funkin.options.TreeMenuScreen"/>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.OptionsMenu" params="" file="source/funkin/options/OptionsMenu.hx">
		<extends path="funkin.options.TreeMenu"/>
		<mainOptions public="1" expr="[{ name : &quot;optionsTree.controls-name&quot;, desc : &quot;optionsTree.controls-desc&quot;, suffix : &quot;&quot;, substate : funkin.options.keybinds.KeybindsOptions }, { name : &quot;optionsTree.gameplay-name&quot;, desc : &quot;optionsTree.gameplay-desc&quot;, state : GameplayOptions }, { name : &quot;optionsTree.appearance-name&quot;, desc : &quot;optionsTree.appearance-desc&quot;, state : AppearanceOptions }, { name : &quot;optionsTree.language-name&quot;, desc : &quot;optionsTree.language-desc&quot;, state : LanguageOptions }, { name : &quot;optionsTree.miscellaneous-name&quot;, desc : &quot;optionsTree.miscellaneous-desc&quot;, state : MiscOptions }]" line="18" static="1">
			<c path="Array"><t path="funkin.options.OptionCategory"/></c>
			<meta><m n=":value"><e>[{ name : "optionsTree.controls-name", desc : "optionsTree.controls-desc", suffix : "", substate : funkin.options.keybinds.KeybindsOptions }, { name : "optionsTree.gameplay-name", desc : "optionsTree.gameplay-desc", state : GameplayOptions }, { name : "optionsTree.appearance-name", desc : "optionsTree.appearance-desc", state : AppearanceOptions }, { name : "optionsTree.language-name", desc : "optionsTree.language-desc", state : LanguageOptions }, { name : "optionsTree.miscellaneous-name", desc : "optionsTree.miscellaneous-desc", state : MiscOptions }]</e></m></meta>
		</mainOptions>
		<bg><c path="flixel.FlxSprite"/></bg>
		<debugOption><c path="funkin.options.type.TextOption"/></debugOption>
		<create public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></create>
		<checkDebugOption set="method" line="108"><f a=""><x path="Void"/></f></checkDebugOption>
		<updateBG public="1" set="method" line="124"><f a=""><x path="Void"/></f></updateBG>
		<onResize public="1" set="method" line="131" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<menuChanged public="1" set="method" line="138" override="1"><f a=""><x path="Void"/></f></menuChanged>
		<exit public="1" set="method" line="143" override="1"><f a=""><x path="Void"/></f></exit>
		<parseOptionsFromXML public="1" set="method" line="150"><f a="screen:xml">
	<c path="funkin.options.TreeMenuScreen"/>
	<x path="haxe.xml.Access"/>
	<c path="Array"><c path="flixel.FlxSprite"/></c>
</f></parseOptionsFromXML>
		<new public="1" set="method" line="17"><f a="?exitCallback:?scriptsAllowed:?scriptName">
	<f a="">
		<c path="funkin.options.TreeMenu"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.PlayerSettings" params="" file="source/funkin/options/PlayerSettings.hx">
		<numPlayers public="1" set="null" expr="0" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numPlayers>
		<numAvatars public="1" set="null" expr="0" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numAvatars>
		<solo public="1" set="null" static="1"><c path="funkin.options.PlayerSettings"/></solo>
		<player1 public="1" set="null" static="1"><c path="funkin.options.PlayerSettings"/></player1>
		<player2 public="1" set="null" static="1"><c path="funkin.options.PlayerSettings"/></player2>
		<onAvatarAdd final="1" public="1" set="null" expr="new FlxTypedSignal&lt;PlayerSettings&gt;()" line="17" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.options.PlayerSettings"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;PlayerSettings&gt;()</e></m></meta>
		</onAvatarAdd>
		<onAvatarRemove final="1" public="1" set="null" expr="new FlxTypedSignal&lt;PlayerSettings&gt;()" line="18" static="1">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="funkin.options.PlayerSettings"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e>new FlxTypedSignal&lt;PlayerSettings&gt;()</e></m></meta>
		</onAvatarRemove>
		<init public="1" set="method" line="44" static="1"><f a=""><x path="Void"/></f></init>
		<reset public="1" set="method" line="89" static="1"><f a=""><x path="Void"/></f></reset>
		<id public="1" set="null"><x path="Int"/></id>
		<controls final="1" public="1"><c path="funkin.backend.system.Controls"/></controls>
		<setKeyboardScheme public="1" set="method" line="39"><f a="scheme">
	<e path="funkin.backend.system.KeyboardScheme"/>
	<x path="Void"/>
</f></setKeyboardScheme>
		<new set="method" line="33"><f a="id:scheme">
	<x path="Int"/>
	<e path="funkin.backend.system.KeyboardScheme"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.ITreeFloatOption" params="" file="source/funkin/options/TreeMenu.hx" module="funkin.options.TreeMenu" interface="1">
		<extends path="funkin.options.ITreeOption"/>
		<changeValue public="1" set="method"><f a="change">
	<x path="Float"/>
	<x path="Void"/>
</f></changeValue>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.TreeMenuDrawer" params="" file="source/funkin/options/TreeMenu.hx" module="funkin.options.TreeMenu" final="1">
		<extends path="flixel.FlxBasic"/>
		<parent public="1"><c path="funkin.options.TreeMenu"/></parent>
		<draw public="1" set="method" line="288" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="283"><f a="parent">
	<c path="funkin.options.TreeMenu"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.AdvancedAppearanceOptions" params="" file="source/funkin/options/categories/AppearanceOptions.hx" module="funkin.options.categories.AppearanceOptions">
		<extends path="funkin.options.TreeMenuScreen"/>
		<qualityOptions expr="[]">
			<c path="Array"><c path="funkin.options.type.OptionType"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</qualityOptions>
		<updateQualityOptions set="method" line="50"><f a=""><x path="Void"/></f></updateQualityOptions>
		<__changeQuality set="method" line="54"><f a="value">
	<d/>
	<x path="Void"/>
</f></__changeQuality>
		<__changeAntialiasing set="method" line="60"><f a=""><x path="Void"/></f></__changeAntialiasing>
		<new public="1" set="method" line="30"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.DebugOptions" params="" file="source/funkin/options/categories/DebugOptions.hx">
		<extends path="funkin.options.TreeMenuScreen"/>
		<new public="1" set="method" line="4"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.AdvancedGameplayOptions" params="" file="source/funkin/options/categories/GameplayOptions.hx" module="funkin.options.categories.GameplayOptions">
		<extends path="funkin.options.TreeMenuScreen"/>
		<new public="1" set="method" line="67"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.RadioButton" params="" file="source/funkin/options/type/RadioButton.hx">
		<extends path="funkin.options.type.TextOption"/>
		<radio public="1"><c path="flixel.FlxSprite"/></radio>
		<checked public="1" set="accessor"><x path="Bool"/></checked>
		<parent public="1"><d/></parent>
		<optionName public="1"><c path="String"/></optionName>
		<screen public="1"><c path="funkin.options.TreeMenuScreen"/></screen>
		<forId public="1"><c path="String"/></forId>
		<value public="1"><d/></value>
		<offsets expr="[&quot;unchecked&quot; =&gt; FlxPoint.get(0, -65), &quot;checked&quot; =&gt; FlxPoint.get(0, -65), &quot;unchecking&quot; =&gt; FlxPoint.get(15, -55), &quot;checking&quot; =&gt; FlxPoint.get(17, -40)]">
			<t path="Map">
				<c path="String"/>
				<x path="flixel.math.FlxPoint"/>
			</t>
			<meta><m n=":value"><e>["unchecked" =&gt; FlxPoint.get(0, -65), "checked" =&gt; FlxPoint.get(0, -65), "unchecking" =&gt; FlxPoint.get(15, -55), "checking" =&gt; FlxPoint.get(17, -40)]</e></m></meta>
		</offsets>
		<firstFrame public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</firstFrame>
		<update public="1" set="method" line="51" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="63" override="1"><f a=""><x path="Void"/></f></draw>
		<set_checked set="method" line="71"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_checked>
		<select public="1" set="method" line="78" override="1"><f a=""><x path="Void"/></f></select>
		<destroy public="1" set="method" line="93" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="24"><f a="?screen:text:desc:?optionName:value:?selectCallback:?parent:?forId">
	<c path="funkin.options.TreeMenuScreen"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<d/>
	<f a=""><x path="Void"/></f>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.categories.LanguageRadio" params="" file="source/funkin/options/categories/LanguageOptions.hx" module="funkin.options.categories.LanguageOptions">
		<extends path="funkin.options.type.RadioButton"/>
		<langID public="1"><c path="String"/></langID>
		<set_rawDesc set="method" line="13" override="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_rawDesc>
		<select public="1" set="method" line="22" override="1"><f a=""><x path="Void"/></f></select>
		<new public="1" set="method" line="6"><f a="screen:name:langID">
	<c path="funkin.options.TreeMenuScreen"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.keybinds.ChangeKeybindSubState" params="" file="source/funkin/options/keybinds/ChangeKeybindSubState.hx">
		<extends path="funkin.backend.MusicBeatSubstate"/>
		<callback><f a="">
	<x path="flixel.input.keyboard.FlxKey"/>
	<x path="Void"/>
</f></callback>
		<cancelCallback><f a=""><x path="Void"/></f></cancelCallback>
		<stillPressed expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</stillPressed>
		<update public="1" set="method" line="16" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="10"><f a="callback:cancelCallback">
	<f a="">
		<x path="flixel.input.keyboard.FlxKey"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.keybinds.KeybindSetting" params="" file="source/funkin/options/keybinds/KeybindSetting.hx">
		<extends path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></extends>
		<title public="1"><c path="funkin.menus.ui.Alphabet"/></title>
		<bind1 public="1"><c path="funkin.menus.ui.Alphabet"/></bind1>
		<bind2 public="1"><c path="funkin.menus.ui.Alphabet"/></bind2>
		<icon public="1"><c path="flixel.FlxSprite"/></icon>
		<changingKeybind public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</changingKeybind>
		<p2Selected public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</p2Selected>
		<value public="1"><c path="String"/></value>
		<custom public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</custom>
		<option1 public="1"><x path="Null"><x path="flixel.input.keyboard.FlxKey"/></x></option1>
		<option2 public="1"><x path="Null"><x path="flixel.input.keyboard.FlxKey"/></x></option2>
		<update public="1" set="method" line="66" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeKeybind public="1" set="method" line="74">
			<f a="callback:cancelCallback:?p2" v="::false">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ p2 : false }</e></m></meta>
		</changeKeybind>
		<updateText public="1" set="method" line="116"><f a=""><x path="Void"/></f></updateText>
		<new public="1" set="method" line="22">
			<f a="x:y:name:value:?sparrowIcon:?sparrowAnim:?custom" v="::::::false">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ custom : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="funkin.options.keybinds.KeybindSettingData" params="" file="source/funkin/options/keybinds/KeybindsOptions.hx" module="funkin.options.keybinds.KeybindsOptions"><a>
	<sparrowIcon>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</sparrowIcon>
	<sparrowAnim>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</sparrowAnim>
	<name><c path="String"/></name>
	<custom>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</custom>
	<control><c path="String"/></control>
</a></typedef>
	<typedef path="funkin.options.keybinds.ControlsCategory" params="" file="source/funkin/options/keybinds/KeybindsOptions.hx" module="funkin.options.keybinds.KeybindsOptions"><a>
	<settings><c path="Array"><t path="funkin.options.keybinds.KeybindSettingData"/></c></settings>
	<name><c path="String"/></name>
	<devModeOnly>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</devModeOnly>
</a></typedef>
	<class path="funkin.options.type.ArrayOption" params="" file="source/funkin/options/type/ArrayOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<changedCallback public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></changedCallback>
		<options public="1"><c path="Array"><d/></c></options>
		<displayOptions public="1"><c path="Array"><c path="String"/></c></displayOptions>
		<currentSelection public="1"><x path="Int"/></currentSelection>
		<parent public="1"><d/></parent>
		<optionName public="1"><c path="String"/></optionName>
		<__selectionText><c path="funkin.menus.ui.Alphabet"/></__selectionText>
		<set_text set="method" line="15" override="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<reloadStrings public="1" set="method" line="36" override="1"><f a=""><x path="Void"/></f></reloadStrings>
		<formatTextOption set="method" line="41"><f a=""><c path="String"/></f></formatTextOption>
		<changeSelection public="1" set="method" line="54" override="1"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<select public="1" set="method" line="63" override="1"><f a=""><x path="Void"/></f></select>
		<new public="1" set="method" line="21">
			<f a="text:desc:options:displayOptions:?optionName:?changedCallback:?parent" v=":::::null:">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ changedCallback : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.Checkbox" params="" file="source/funkin/options/type/Checkbox.hx">
		<extends path="funkin.options.type.TextOption"/>
		<checkbox public="1"><c path="flixel.FlxSprite"/></checkbox>
		<checked public="1" set="accessor"><x path="Bool"/></checked>
		<parent public="1"><d/></parent>
		<optionName public="1"><c path="String"/></optionName>
		<offsets expr="[&quot;unchecked&quot; =&gt; FlxPoint.get(0, -70), &quot;checked&quot; =&gt; FlxPoint.get(23, -32), &quot;unchecking&quot; =&gt; FlxPoint.get(25, -12), &quot;checking&quot; =&gt; FlxPoint.get(35, 29)]">
			<t path="Map">
				<c path="String"/>
				<x path="flixel.math.FlxPoint"/>
			</t>
			<meta><m n=":value"><e>["unchecked" =&gt; FlxPoint.get(0, -70), "checked" =&gt; FlxPoint.get(23, -32), "unchecking" =&gt; FlxPoint.get(25, -12), "checking" =&gt; FlxPoint.get(35, 29)]</e></m></meta>
		</offsets>
		<set_text set="method" line="22" override="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<firstFrame public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</firstFrame>
		<update public="1" set="method" line="53" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="65" override="1"><f a=""><x path="Void"/></f></draw>
		<set_checked set="method" line="73"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_checked>
		<select public="1" set="method" line="80" override="1"><f a=""><x path="Void"/></f></select>
		<destroy public="1" set="method" line="92" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="28"><f a="text:desc:?optionName:?selectCallback:?parent">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Option type that allows you to toggle a checkbox.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.GithubIconOption" params="" file="source/funkin/options/type/GithubIconOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<user public="1" set="null"><t path="funkin.backend.system.github.CreditsGitHubContributor"/></user>
		<icon public="1" expr="null">
			<c path="funkin.options.type.GithubUserIcon"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</icon>
		<usePortrait public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</usePortrait>
		<set_usePortrait public="1" set="method" line="17"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_usePortrait>
		<new public="1" set="method" line="23">
			<f a="user:desc:?callback:?customName:?size:?usePortrait:?waitUntilLoad" v="::::96:true:0.25">
				<t path="funkin.backend.system.github.CreditsGitHubContributor"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ waitUntilLoad : 0.25, usePortrait : true, size : 96 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.GithubUserIcon" params="" file="source/funkin/options/type/GithubIconOption.hx" module="funkin.options.type.GithubIconOption">
		<extends path="flixel.FlxSprite"/>
		<waitUntilLoad public="1"><x path="Null"><x path="Float"/></x></waitUntilLoad>
		<user><t path="funkin.backend.system.github.CreditsGitHubContributor"/></user>
		<size><x path="Int"/></size>
		<update public="1" set="method" line="48" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<mutex final="1" expr="new sys.thread.Mutex()">
			<c path="sys.thread.Mutex"/>
			<meta><m n=":value"><e>new sys.thread.Mutex()</e></m></meta>
		</mutex>
		<acquireMutex get="inline" set="null" line="57"><f a=""><x path="Void"/></f></acquireMutex>
		<releaseMutex get="inline" set="null" line="62"><f a=""><x path="Void"/></f></releaseMutex>
		<drawComplex set="method" line="68" override="1"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawComplex>
		<updateDaFunni public="1" get="inline" set="null" line="119"><f a="graphic">
	<c path="flixel.graphics.FlxGraphic"/>
	<x path="Void"/>
</f></updateDaFunni>
		<new public="1" set="method" line="39">
			<f a="user:?size:?waitUntilLoad" v=":96:0.25">
				<t path="funkin.backend.system.github.CreditsGitHubContributor"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ waitUntilLoad : 0.25, size : 96 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.IconOption" params="" file="source/funkin/options/type/IconOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<iconSpr public="1"><c path="funkin.game.HealthIcon"/></iconSpr>
		<new public="1" set="method" line="12"><f a="name:desc:icon:callback">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Option type that has an icon.
 * Used for the credits menu.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.NewOption" params="" file="source/funkin/options/type/NewOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<iconSpr public="1"><c path="flixel.FlxSprite"/></iconSpr>
		<new public="1" set="method" line="11"><f a="name:desc:callback">
	<c path="String"/>
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Option type that has a new button, and is green.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.NumOption" params="" file="source/funkin/options/type/NumOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<changedCallback public="1"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></changedCallback>
		<min public="1"><x path="Float"/></min>
		<max public="1"><x path="Float"/></max>
		<step public="1"><x path="Float"/></step>
		<currentValue public="1"><x path="Float"/></currentValue>
		<parent public="1"><d/></parent>
		<optionName public="1"><c path="String"/></optionName>
		<__number><c path="funkin.menus.ui.Alphabet"/></__number>
		<set_text set="method" line="20" override="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<changeSelection public="1" set="method" line="41" override="1"><f a="change">
	<x path="Int"/>
	<x path="Void"/>
</f></changeSelection>
		<select public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></select>
		<new public="1" set="method" line="26">
			<f a="text:desc:min:max:?step:?optionName:?changedCallback:?parent" v="::::1::null:">
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ changedCallback : null, step : 1 }</e></m></meta>
		</new>
		<haxe_doc>* Option type that allows stepping through a number.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.PortraitOption" params="" file="source/funkin/options/type/PortraitOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<portrait public="1" expr="null">
			<c path="flixel.FlxSprite"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</portrait>
		<addPortrait public="1" set="method" line="20">
			<f a="graphic:?size:?usePortrait" v=":96:true">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ usePortrait : true, size : 96 }</e></m></meta>
		</addPortrait>
		<new public="1" set="method" line="13">
			<f a="name:desc:callback:?graphic:?size:?usePortrait" v="::::96:true">
				<c path="String"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ usePortrait : true, size : 96 }</e></m></meta>
		</new>
		<haxe_doc>* Option type that has a portrait.
 * Used in the credits menu.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.Separator" params="" file="source/funkin/options/type/Separator.hx">
		<extends path="flixel.FlxSprite"/>
		<separatorHeight><x path="Float"/></separatorHeight>
		<initVars set="method" line="14" override="1"><f a=""><x path="Void"/></f></initVars>
		<update public="1" set="method" line="25" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></draw>
		<get_height set="method" line="28" override="1"><f a=""><x path="Float"/></f></get_height>
		<get_width set="method" line="29" override="1"><f a=""><x path="Float"/></f></get_width>
		<new public="1" set="method" line="9">
			<f a="?height" v="67">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 67 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.options.type.SliderOption" params="" file="source/funkin/options/type/SliderOption.hx">
		<extends path="funkin.options.type.TextOption"/>
		<implements path="funkin.options.ITreeFloatOption"/>
		<changedCallback public="1"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></changedCallback>
		<min public="1"><x path="Float"/></min>
		<max public="1"><x path="Float"/></max>
		<step public="1"><x path="Float"/></step>
		<currentValue public="1"><x path="Float"/></currentValue>
		<parent public="1"><d/></parent>
		<optionName public="1"><c path="String"/></optionName>
		<slider public="1"><c path="funkin.menus.ui.Slider"/></slider>
		<dynamicWidth public="1"><x path="Bool"/></dynamicWidth>
		<__mouseControl><x path="Bool"/></__mouseControl>
		<getValue set="method" line="23"><f a=""><x path="Float"/></f></getValue>
		<set_text set="method" line="25" override="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<update public="1" set="method" line="56" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<changeValue public="1" set="method" line="79"><f a="change">
	<x path="Float"/>
	<x path="Void"/>
</f></changeValue>
		<select public="1" set="method" line="87" override="1"><f a=""><x path="Void"/></f></select>
		<new public="1" set="method" line="37">
			<f a="text:desc:min:max:?step:?segments:?optionName:?barWidth:?changedCallback:?parent" v="::::1:::-1:null:">
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ changedCallback : null, barWidth : -1, step : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="funkin.savedata.FunkinSave" params="" file="source/funkin/savedata/FunkinSave.hx">
		<highscores public="1" expr="[]" line="14" static="1">
			<t path="Map">
				<e path="funkin.savedata.HighscoreEntry"/>
				<t path="funkin.savedata.SongScore"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</highscores>
		<__eventAdded expr="false" line="22" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":dox"><e>hide</e></m>
				<m n=":doNotSave"/>
			</meta>
			<haxe_doc>* ONLY OPEN IF YOU WANT TO EDIT FUNCTIONS RELATED TO SAVING, LOADING OR HIGHSCORES.</haxe_doc>
		</__eventAdded>
		<save public="1" static="1">
			<c path="flixel.util.FlxSave"/>
			<meta><m n=":doNotSave"/></meta>
		</save>
		<init public="1" set="method" line="26" static="1"><f a=""><x path="Void"/></f></init>
		<getSongHighscore public="1" get="inline" set="null" line="55" static="1">
			<f a="name:diff:?changes">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><e path="funkin.savedata.HighscoreChange"/></c>
				<t path="funkin.savedata.SongScore"/>
			</f>
			<haxe_doc>* Returns the high-score for a song.
	 * @param name Song name
	 * @param diff Song difficulty
	 * @param changes Changes made to that song in freeplay.</haxe_doc>
		</getSongHighscore>
		<setSongHighscore public="1" get="inline" set="null" line="60" static="1"><f a="name:diff:highscore:?changes">
	<c path="String"/>
	<c path="String"/>
	<t path="funkin.savedata.SongScore"/>
	<c path="Array"><e path="funkin.savedata.HighscoreChange"/></c>
	<x path="Bool"/>
</f></setSongHighscore>
		<getWeekHighscore public="1" get="inline" set="null" line="70" static="1"><f a="name:diff">
	<c path="String"/>
	<c path="String"/>
	<t path="funkin.savedata.SongScore"/>
</f></getWeekHighscore>
		<setWeekHighscore public="1" get="inline" set="null" line="72" static="1"><f a="name:diff:highscore">
	<c path="String"/>
	<c path="String"/>
	<t path="funkin.savedata.SongScore"/>
	<x path="Bool"/>
</f></setWeekHighscore>
		<safeGetHighscore set="method" line="80" static="1"><f a="entry">
	<e path="funkin.savedata.HighscoreEntry"/>
	<t path="funkin.savedata.SongScore"/>
</f></safeGetHighscore>
		<safeRegisterHighscore set="method" line="93" static="1"><f a="entry:highscore">
	<e path="funkin.savedata.HighscoreEntry"/>
	<t path="funkin.savedata.SongScore"/>
	<x path="Bool"/>
</f></safeRegisterHighscore>
		<flush public="1" set="method" line="12" static="1"><f a=""><x path="Void"/></f></flush>
		<load public="1" set="method" line="12" static="1"><f a=""><x path="Void"/></f></load>
		<haxe_doc>* Class used for saves WITHOUT going through the struggle of type checks
 * Just add your save variables the way you would do in the Options.hx file.
 * The macro will automatically generate the `flush` and `load` functions.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>funkin.backend.system.macros.FunkinSaveMacro.build("save", "flush", "load")</e></m>
		</meta>
	</class>
	<enum path="funkin.savedata.HighscoreEntry" params="" file="source/funkin/savedata/FunkinSave.hx" module="funkin.savedata.FunkinSave">
		<HWeekEntry a="weekName:difficulty">
			<c path="String"/>
			<c path="String"/>
		</HWeekEntry>
		<HSongEntry a="songName:difficulty:changes">
			<c path="String"/>
			<c path="String"/>
			<c path="Array"><e path="funkin.savedata.HighscoreChange"/></c>
		</HSongEntry>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="funkin.savedata.HighscoreChange" params="" file="source/funkin/savedata/FunkinSave.hx" module="funkin.savedata.FunkinSave">
		<CCoopMode/>
		<COpponentMode/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="funkin.savedata.SongScore" params="" file="source/funkin/savedata/FunkinSave.hx" module="funkin.savedata.FunkinSave"><a>
	<score><x path="Int"/></score>
	<misses><x path="Int"/></misses>
	<hits><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></hits>
	<date><c path="String"/></date>
	<accuracy><x path="Float"/></accuracy>
</a></typedef>
	</haxe>
